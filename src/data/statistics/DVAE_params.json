{
    "bayesian_optimization/bo.py": {
        "sklearn": {
            "PCA_299": {
                "variable": {
                    "value": "pca",
                    "type": "variable",
                    "possible_values": []
                },
                "n_components": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "whiten": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        },
        "torch": {
            "manual_seed_158": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rand_idx",
                            "variable"
                        ]
                    ]
                }
            },
            "manual_seed_159": {
                "seed": {
                    "value": "random_seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "rand_idx",
                            "variable"
                        ]
                    ]
                }
            },
            "zeros_287": {
                "variable": {
                    "value": "z0",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "args.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_286": {
                "variable": {
                    "value": "z0",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "args.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_308": {
                "variable": {
                    "value": "grid_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[grid_inputs, z0[:, 2:].expand(grid_inputs.shape[0], -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "grad_446": {
                "outputs": {
                    "value": "[x for x in pred]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "inputs": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "X_train[train_idxs]",
                            "Subscript"
                        ],
                        [
                            "X_train.mean(0) + np.random.randn(10000, nz) * X_train.std(0)",
                            "BinOp"
                        ],
                        [
                            "torch.FloatTensor(grid).cuda()",
                            "Call"
                        ],
                        [
                            "X_train.min(0) + np.random.rand(10000, nz) * (X_train.max(0) - X_train.min(0))",
                            "BinOp"
                        ],
                        [
                            "grid + ga_lr * grads",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/cifar10/data_utils.py": {
        "tensorflow": {}
    },
    "software/enas/src/cifar10/eval_child.py": {
        "tensorflow": {
            "avg_pool_144": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_164": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_173": {
                "variable": {
                    "value": "final_path",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[path1, path2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "concat_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "int"
                        ],
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_604": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_606": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_608": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_609": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_610": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_611": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_612": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_619": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_660": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_661": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_662": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_663": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_664": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_700": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_701": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_702": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_703": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_704": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_149": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.avg_pool(x, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path1, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_169": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "case_300": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "default": {
                    "value": "lambda : tf.constant(0, tf.float32, shape=out_shape)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_510": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_512": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_551": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_572": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_574": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_649": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_650": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_651": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_652": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_653": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_675": {
                "variable": {
                    "value": "(x_valid_shuffle, y_valid_shuffle)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.images['valid_original'], self.labels['valid_original']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "25000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_137": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_146": {
                "name_or_scope": {
                    "value": "path1_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_166": {
                "name_or_scope": {
                    "value": "path2_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_193": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_199": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_233": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_242": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_331": {
                "variable": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[False] * (self.num_branches * out_filters)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_332": {
                "variable": {
                    "value": "new_range",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "boolean_mask_338": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([False] * (self.num_branches * out_filters), tf.bool)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(w_mask, new_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_339": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, -1, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_350": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_353": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_368": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "res_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "relu_456": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_457": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_476": {
                "variable": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res_layers + [out]",
                            "BinOp"
                        ],
                        [
                            "tf.concat(prev, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(prev, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_484": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_485": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_508": {
                "name_or_scope": {
                    "value": "inp_conv_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_514": {
                "name_or_scope": {
                    "value": "'out_conv_{}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_570": {
                "name_or_scope": {
                    "value": "conv_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_576": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "average_pooling2d_583": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "device_670": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_687": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_688": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_689": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_696": {
                "variable": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_pre_process, x_valid_shuffle, back_prop=False)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_134": {
                "name_or_scope": {
                    "value": "path_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_157": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "pad_161": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_197": {
                "name_or_scope": {
                    "value": "stem_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_234": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_268": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_272": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_276": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_280": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_306": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_309": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_313": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_316": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_329": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_and_335": {
                "variable": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start <= new_range",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "new_range < start + count[2 * i + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_or_337": {
                "variable": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([False] * (self.num_branches * out_filters), tf.bool)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(w_mask, new_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(start <= new_range, new_range < start + count[2 * i + 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_343": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_361": {
                "name_or_scope": {
                    "value": "skip",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_399": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "conv2d_400": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_406": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_407": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=out_shape), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_425": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_428": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_432": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_435": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_450": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_453": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_478": {
                "variable": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res_layers + [out]",
                            "BinOp"
                        ],
                        [
                            "tf.concat(prev, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(prev, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_481": {
                "name_or_scope": {
                    "value": "skip",
                    "type": "str",
                    "possible_values": []
                }
            },
            "separable_conv2d_520": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [self.filter_size, self.filter_size, out_filters, ch_mul])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [filter_size, filter_size, out_filters, ch_mul])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_525": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_532": {
                "variable": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_533": {
                "variable": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, out_filters * ch_mul, count]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "separable_conv2d_535": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [self.filter_size, self.filter_size, out_filters, ch_mul])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [filter_size, filter_size, out_filters, ch_mul])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_537": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_538": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_idx <= mask",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "mask < start_idx + count",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "transpose_543": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_545": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_546": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_547": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_548": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_idx <= mask",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "mask < start_idx + count",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "max_pooling2d_586": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "trainable_variables_615": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_691": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_208": {
                "name_or_scope": {
                    "value": "'layer_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_271": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_275": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_279": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_283": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_285": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_288": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_290": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_293": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc3[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc3[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_321": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_325": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_345": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_349": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, -1, H, W]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_397": {
                "name_or_scope": {
                    "value": "conv_1x1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_404": {
                "name_or_scope": {
                    "value": "'conv_{0}x{0}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_412": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "variable_scope_440": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_445": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_455": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_301": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "out_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self.batch_size, inp_h, inp_w, out_filters]",
                            "List"
                        ],
                        [
                            "[self.batch_size, out_filters, inp_h, inp_w]",
                            "List"
                        ]
                    ]
                }
            },
            "cond_364": {
                "pred": {
                    "value": "tf.equal(skip[i], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : prev_layers[i]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.zeros_like(prev_layers[i])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_411": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "average_pooling2d_416": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "variable_scope_217": {
                "name_or_scope": {
                    "value": "'pool_at_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_346": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "equal_364": {
                "x": {
                    "value": "skip[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_415": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_like_366": {
                "input": {
                    "value": "prev_layers[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_220": {
                "name_or_scope": {
                    "value": "'from_{0}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/eval_micro_child.py": {
        "tensorflow": {
            "Variable_103": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "avg_pool_130": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_150": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_159": {
                "variable": {
                    "value": "final_path",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[path1, path2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "concat_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "int"
                        ],
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "minimum_203": {
                "variable": {
                    "value": "step_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "step_ratio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self.global_step + 1) / tf.to_float(self.num_train_steps)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(1.0, step_ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_575": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_659": {
                "variable": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.num_cells + 2], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_660": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(used, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_int32_661": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_662": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "size_663": {
                "variable": {
                    "value": "num_outs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_664": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x, x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_665": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_694": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(prev_layers[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_703": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_705": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.aux_logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_715": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_716": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_717": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_718": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_719": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_766": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_767": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_768": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_769": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_770": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_805": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_806": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_807": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_808": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_809": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_135": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.avg_pool(x, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path1, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_155": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_331": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_420": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_421": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "average_pooling2d_525": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_541": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_639": {
                "variable": {
                    "value": "prev_layers",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x, x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_673": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_674": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, H, W, num_outs * out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_687": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_688": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, num_outs * out_filters, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_689": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                }
            },
            "conv2d_690": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_708": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.aux_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_710": {
                "variable": {
                    "value": "self.aux_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.aux_logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_755": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_756": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_757": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_758": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_759": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_781": {
                "variable": {
                    "value": "(x_valid_shuffle, y_valid_shuffle)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.images['valid_original'], self.labels['valid_original']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "25000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_123": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_132": {
                "name_or_scope": {
                    "value": "path1_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_152": {
                "name_or_scope": {
                    "value": "path2_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_float_202": {
                "x": {
                    "value": "self.num_train_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "calibrate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_246": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_250": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_334": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_338": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_359": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "separable_conv2d_360": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ],
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_382": {
                "name_or_scope": {
                    "value": "final_combine",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_395": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_416": {
                "name_or_scope": {
                    "value": "layer_base",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_524": {
                "name_or_scope": {
                    "value": "avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_540": {
                "name_or_scope": {
                    "value": "max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_561": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, x_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_562": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_563": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_583": {
                "name_or_scope": {
                    "value": "'conv_{0}x{0}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_660": {
                "x": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.num_cells + 2], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_680": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2, 3, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_681": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, num_outs * out_filters, H, W]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_685": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_694": {
                "input": {
                    "value": "prev_layers[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_776": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_793": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_794": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_795": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_801": {
                "variable": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_pre_process, x_valid_shuffle, back_prop=False)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_120": {
                "name_or_scope": {
                    "value": "path_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_143": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "pad_147": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "relu_220": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_234": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_235": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_248": {
                "name_or_scope": {
                    "value": "stem_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_335": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_356": {
                "name_or_scope": {
                    "value": "'sep_conv_{}'.format(conv_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_397": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_429": {
                "name_or_scope": {
                    "value": "'cell_{}'.format(cell_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_533": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, avg_pool_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_534": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(avg_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(avg_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(avg_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_535": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(avg_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(avg_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(avg_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_549": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, max_pool_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_550": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(max_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(max_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(max_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_551": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(max_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(max_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(max_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_558": {
                "name_or_scope": {
                    "value": "x_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_592": {
                "variable": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[filter_size, filter_size, inp_c, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_598": {
                "variable": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, inp_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_613": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "separable_conv2d_614": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fused_batch_norm_620": {
                "variable": {
                    "value": "(x, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('scale', [num_possible_inputs, out_filters], initializer=one_init)",
                            "Call"
                        ],
                        [
                            "scale[prev_cell]",
                            "Subscript"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('offset', [num_possible_inputs, out_filters], initializer=zero_init)",
                            "Call"
                        ],
                        [
                            "offset[prev_cell]",
                            "Subscript"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                },
                "is_training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_640": {
                "name_or_scope": {
                    "value": "'cell_{0}'.format(cell_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_646": {
                "variable": {
                    "value": "x_used",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "x_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc[4 * cell_id]",
                            "Subscript"
                        ],
                        [
                            "arc[4 * cell_id]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_653": {
                "variable": {
                    "value": "y_used",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "y_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc[4 * cell_id + 2]",
                            "Subscript"
                        ],
                        [
                            "arc[4 * cell_id + 2]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_669": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_670": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_671": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_672": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "trainable_variables_722": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_797": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_219": {
                "name_or_scope": {
                    "value": "pool_x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_225": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_226": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_232": {
                "name_or_scope": {
                    "value": "pool_y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_264": {
                "name_or_scope": {
                    "value": "'layer_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_294": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "average_pooling2d_295": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[5, 5]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_435": {
                "name_or_scope": {
                    "value": "x_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_475": {
                "name_or_scope": {
                    "value": "y_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_529": {
                "name_or_scope": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_545": {
                "name_or_scope": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_586": {
                "name_or_scope": {
                    "value": "'stack_{0}'.format(conv_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_601": {
                "variable": {
                    "value": "zero_init",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_602": {
                "variable": {
                    "value": "one_init",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_641": {
                "name_or_scope": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_648": {
                "name_or_scope": {
                    "value": "y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_676": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_677": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_678": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_679": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "variable_scope_223": {
                "name_or_scope": {
                    "value": "pool_x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_293": {
                "name_or_scope": {
                    "value": "aux_head",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_301": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_305": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_311": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_315": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_322": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_600": {
                "name_or_scope": {
                    "value": "bn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_298": {
                "name_or_scope": {
                    "value": "proj",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_307": {
                "name_or_scope": {
                    "value": "avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_317": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_326": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_388": {
                "name_or_scope": {
                    "value": "'calibrate_{0}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_442": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[x_stride, x_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_446": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[x_stride, x_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_451": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_452": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_462": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_463": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc2, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc2, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc2, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "average_pooling2d_482": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[y_stride, y_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_486": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[y_stride, y_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_491": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_492": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_502": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_503": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/eval_structure.py": {
        "tensorflow": {
            "Graph_228": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_234": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CheckpointSaverHook_235": {
                "variable": {
                    "value": "checkpoint_saver_hook",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_steps": {
                    "value": "child_ops['num_train_batches']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "{'child': child_model, 'global_step': child_model.global_step, 'loss': child_model.loss, 'train_op': child_model.train_op, 'lr': child_model.lr, 'grad_norm': child_model.grad_norm, 'train_acc': child_model.train_acc, 'optimizer': child_model.optimizer, 'num_train_batches': child_model.num_train_batches}",
                            "Dict"
                        ],
                        [
                            "ops['child']",
                            "Subscript"
                        ]
                    ]
                },
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(max_to_keep=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_248": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "run_283": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "SingularMonitoredSession_249": {
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "hooks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[checkpoint_saver_hook]",
                            "List"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/evaluation.py": {
        "tensorflow": {
            "Graph_232": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_309": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_238": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CheckpointSaverHook_239": {
                "variable": {
                    "value": "checkpoint_saver_hook",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_steps": {
                    "value": "child_ops['num_train_batches'] * 10000",
                    "type": "BinOp",
                    "possible_values": []
                },
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(max_to_keep=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_252": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "SingularMonitoredSession_254": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "hooks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[checkpoint_saver_hook]",
                            "List"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/general_child.py": {
        "tensorflow": {
            "avg_pool_145": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_165": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_174": {
                "variable": {
                    "value": "final_path",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[path1, path2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "concat_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "int"
                        ],
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_606": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_608": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_610": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_611": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_612": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_613": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_614": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_621": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_662": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_663": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_664": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_665": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_666": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_703": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_704": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_705": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_706": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_707": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_150": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.avg_pool(x, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path1, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_170": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "case_297": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "default": {
                    "value": "lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_511": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_513": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_553": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_574": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_576": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_651": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_652": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_653": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_654": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_655": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_678": {
                "variable": {
                    "value": "(x_valid_shuffle, y_valid_shuffle)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.images['valid_original'], self.labels['valid_original']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "25000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_138": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_147": {
                "name_or_scope": {
                    "value": "path1_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_167": {
                "name_or_scope": {
                    "value": "path2_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_194": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_200": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_234": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_243": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_332": {
                "variable": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[False] * (self.num_branches * out_filters)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_333": {
                "variable": {
                    "value": "new_range",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "boolean_mask_339": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([False] * (self.num_branches * out_filters), tf.bool)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(w_mask, new_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_340": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, -1, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_351": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_354": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_369": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "res_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "relu_457": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_458": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_477": {
                "variable": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res_layers + [out]",
                            "BinOp"
                        ],
                        [
                            "tf.concat(prev, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(prev, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_485": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_486": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_509": {
                "name_or_scope": {
                    "value": "inp_conv_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_516": {
                "name_or_scope": {
                    "value": "'out_conv_{}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_572": {
                "name_or_scope": {
                    "value": "conv_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_578": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "average_pooling2d_585": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "device_672": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_690": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_691": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_692": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_699": {
                "variable": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_pre_process, x_valid_shuffle, back_prop=False)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_135": {
                "name_or_scope": {
                    "value": "path_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_158": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "pad_162": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_198": {
                "name_or_scope": {
                    "value": "stem_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_235": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_269": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_273": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_277": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_281": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_307": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_310": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_314": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_317": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_330": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "logical_and_336": {
                "variable": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start <= new_range",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "new_range < start + count[2 * i + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_or_338": {
                "variable": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "w_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([False] * (self.num_branches * out_filters), tf.bool)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(w_mask, new_mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "new_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(start <= new_range, new_range < start + count[2 * i + 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_344": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_362": {
                "name_or_scope": {
                    "value": "skip",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_400": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "conv2d_401": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_407": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_408": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.case(branches, default=lambda : tf.constant(0, tf.float32, shape=[self.batch_size, out_filters, inp_h, inp_w]), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(branches, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.add_n(res_layers)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "prev",
                            "variable"
                        ],
                        [
                            "tf.nn.relu(branches)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_426": {
                "name_or_scope": {
                    "value": "branch_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_429": {
                "name_or_scope": {
                    "value": "branch_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_433": {
                "name_or_scope": {
                    "value": "branch_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_436": {
                "name_or_scope": {
                    "value": "branch_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_451": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_454": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_479": {
                "variable": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "res_layers + [out]",
                            "BinOp"
                        ],
                        [
                            "tf.concat(prev, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(prev, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_482": {
                "name_or_scope": {
                    "value": "skip",
                    "type": "str",
                    "possible_values": []
                }
            },
            "separable_conv2d_522": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [self.filter_size, self.filter_size, out_filters, ch_mul])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [filter_size, filter_size, out_filters, ch_mul])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_527": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_534": {
                "variable": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_535": {
                "variable": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, out_filters * ch_mul, count]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "separable_conv2d_537": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [self.filter_size, self.filter_size, out_filters, ch_mul])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [filter_size, filter_size, out_filters, ch_mul])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [out_filters, out_filters * ch_mul])",
                            "Call"
                        ],
                        [
                            "w_point[start_idx:start_idx + count, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w_point, [1, 0])",
                            "Call"
                        ],
                        [
                            "tf.reshape(w_point, [1, 1, out_filters * ch_mul, count])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_539": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_540": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_idx <= mask",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "mask < start_idx + count",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "transpose_545": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_547": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_548": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_branches * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(w, w_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, -1, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_out_channels, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, total_skip_channels * out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, inp_c, count])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [filter_size, filter_size, out_filters, out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(w, [3, 0, 1, 2])",
                            "Call"
                        ],
                        [
                            "w[start_idx:start_idx + count, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(w, [1, 2, 3, 0])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, self.out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_549": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "logical_and_550": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start_idx <= mask",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "mask < start_idx + count",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "max_pooling2d_588": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "trainable_variables_617": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_694": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, start_idx, out_filters, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, w_depth, w_point, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_with_mask(x, is_training, mask, out_filters, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(inputs, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "x[:, :, :, start_idx:start_idx + count]",
                            "Subscript"
                        ],
                        [
                            "x[:, start_idx:start_idx + count, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_209": {
                "name_or_scope": {
                    "value": "'layer_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_272": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_276": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_280": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_284": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_286": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_289": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_291": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "equal_294": {
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx:start_idx + 2 * self.num_branches] * self.out_filters_scale",
                            "BinOp"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_322": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_326": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_346": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_350": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, -1, H, W]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_398": {
                "name_or_scope": {
                    "value": "conv_1x1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_405": {
                "name_or_scope": {
                    "value": "'conv_{0}x{0}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_413": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "variable_scope_441": {
                "name_or_scope": {
                    "value": "branch_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_446": {
                "name_or_scope": {
                    "value": "branch_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_456": {
                "variable": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "branches",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branches, [N, -1, H, W])",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(branches, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(branches, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_297": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size, out_filters, inp_h, inp_w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cond_365": {
                "pred": {
                    "value": "tf.equal(skip[i], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : prev_layers[i]",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.zeros_like(prev_layers[i])",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "variable_scope_412": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pooling2d_417": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ],
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "variable_scope_218": {
                "name_or_scope": {
                    "value": "'pool_at_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_347": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[-1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "equal_365": {
                "x": {
                    "value": "skip[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_416": {
                "name_or_scope": {
                    "value": "pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_like_367": {
                "input": {
                    "value": "prev_layers[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_221": {
                "name_or_scope": {
                    "value": "'from_{0}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/general_controller.py": {
        "tensorflow": {
            "random_uniform_initializer_89": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "get_variable_146": {
                "variable": {
                    "value": "self.idx_arc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "idx_arc",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_150": {
                "variable": {
                    "value": "self.sample_arc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.gather(self.structures, self.idx_arc)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_152": {
                "variable": {
                    "value": "self.sample_arc3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[len(self.structures[0])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_174": {
                "variable": {
                    "value": "skip_targets",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[1.0 - self.skip_target, self.skip_target]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_284": {
                "variable": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(arc_seq, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_285": {
                "variable": {
                    "value": "self.sample_arc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(arc_seq, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_287": {
                "variable": {
                    "value": "entropys",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "entropys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(entropys)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_288": {
                "variable": {
                    "value": "self.sample_entropy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "entropys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(entropys)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_290": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_291": {
                "variable": {
                    "value": "self.sample_log_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_293": {
                "variable": {
                    "value": "skip_count",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "skip_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(skip_count)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_294": {
                "variable": {
                    "value": "self.skip_count",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "skip_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(skip_count)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_296": {
                "variable": {
                    "value": "skip_penaltys",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "skip_penaltys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(skip_penaltys)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_297": {
                "variable": {
                    "value": "self.skip_penaltys",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "skip_penaltys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(skip_penaltys)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_305": {
                "variable": {
                    "value": "normalize",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.num_layers * (self.num_layers - 1) / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_311": {
                "variable": {
                    "value": "self.sample_log_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.sample_log_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_312": {
                "variable": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_sub_313": {
                "variable": {
                    "value": "baseline_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "(1 - self.bl_dec) * (self.baseline - self.reward)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_323": {
                "variable": {
                    "value": "self.train_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "train_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_99": {
                "variable": {
                    "value": "self.g_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "g_emb",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_317": {
                "variable": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_90": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(minval=-0.1, maxval=0.1)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_127": {
                "variable": {
                    "value": "self.w_attn_1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_128": {
                "variable": {
                    "value": "self.w_attn_2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_129": {
                "variable": {
                    "value": "self.v_attn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "v",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_150": {
                "params": {
                    "value": "self.structures",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "self.idx_arc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_169": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_171": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_180": {
                "variable": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_194": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(branch_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branch_id, [1])",
                            "Call"
                        ],
                        [
                            "tf.constant([0], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_197": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_prob * tf.exp(-log_prob)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "embedding_lookup_199": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(branch_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branch_id, [1])",
                            "Call"
                        ],
                        [
                            "tf.constant([0], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_246": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "anchors_w_1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_247": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "query + tf.matmul(next_h[-1], self.w_attn_2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_248": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(anchors_w_1, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tanh(query + tf.matmul(next_h[-1], self.w_attn_2))",
                            "Call"
                        ],
                        [
                            "tf.matmul(query, self.v_attn)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.v_attn",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_249": {
                "variable": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[-query, query]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_255": {
                "variable": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_256": {
                "variable": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_257": {
                "variable": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[layer_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_260": {
                "variable": {
                    "value": "skip_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_262": {
                "variable": {
                    "value": "kl",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "kl",
                    "type": "variable",
                    "possible_values": [
                        [
                            "skip_prob * tf.log(skip_prob / skip_targets)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(kl)",
                            "Call"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_265": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_269": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_sum(log_prob * tf.exp(-log_prob), keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_273": {
                "variable": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_274": {
                "variable": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, layer_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_276": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.concat(anchors, axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_301": {
                "x": {
                    "value": "child_model.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_302": {
                "x": {
                    "value": "child_model.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_306": {
                "x": {
                    "value": "self.skip_count",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_316": {
                "control_inputs": {
                    "value": "[baseline_update]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_91": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_102": {
                "variable": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_branches, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_105": {
                "variable": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.num_branches]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_126": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_146": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_186": {
                "variable": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_187": {
                "variable": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(branch_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branch_id, [1])",
                            "Call"
                        ],
                        [
                            "tf.constant([0], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_188": {
                "variable": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "range(self.num_branches)",
                            "Call"
                        ],
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(branch_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(branch_id, [1])",
                            "Call"
                        ],
                        [
                            "tf.constant([0], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_204": {
                "variable": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_soft['start'][branch_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "multinomial_209": {
                "variable": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_210": {
                "variable": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(start)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(start)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_213": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(start)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_216": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_prob * tf.exp(-log_prob)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "embedding_lookup_218": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb['start'][branch_id]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "ids": {
                    "value": "start",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(start)",
                            "Call"
                        ],
                        [
                            "tf.reshape(start, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_222": {
                "variable": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_soft['count'][branch_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "range_227": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "limit": {
                    "value": "self.out_filters - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "delta": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_228": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, limit=self.out_filters - 1, delta=1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [1, self.out_filters - 1])",
                            "Call"
                        ],
                        [
                            "tf.less_equal(mask, self.out_filters - 1 - start)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, self.out_filters - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_equal_229": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, limit=self.out_filters - 1, delta=1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [1, self.out_filters - 1])",
                            "Call"
                        ],
                        [
                            "tf.less_equal(mask, self.out_filters - 1 - start)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.out_filters - 1 - start",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "where_230": {
                "variable": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, limit=self.out_filters - 1, delta=1, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [1, self.out_filters - 1])",
                            "Call"
                        ],
                        [
                            "tf.less_equal(mask, self.out_filters - 1 - start)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.fill(tf.shape(logit), -np.inf)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multinomial_231": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_232": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(count)",
                            "Call"
                        ],
                        [
                            "tf.reshape(count, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_233": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(count)",
                            "Call"
                        ],
                        [
                            "tf.reshape(count, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_235": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(count)",
                            "Call"
                        ],
                        [
                            "tf.reshape(count, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_238": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "log_prob * tf.exp(-log_prob)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "embedding_lookup_240": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb['count'][branch_id]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "ids": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(count)",
                            "Call"
                        ],
                        [
                            "tf.reshape(count, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_282": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_attn_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_326": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_95": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self.lstm_size, 4 * self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_101": {
                "name_or_scope": {
                    "value": "emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_104": {
                "name_or_scope": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_109": {
                "name_or_scope": {
                    "value": "emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_118": {
                "name_or_scope": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_190": {
                "variable": {
                    "value": "branch_id",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_261": {
                "x": {
                    "value": "skip_prob / skip_targets",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_267": {
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logit, labels=start)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logit, labels=branch_id)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logit, labels=skip)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logit, labels=count)",
                            "Call"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_270": {
                "input_tensor": {
                    "value": "log_prob * tf.exp(-log_prob)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_275": {
                "input_tensor": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_276": {
                "values": {
                    "value": "anchors",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_277": {
                "input_tensor": {
                    "value": "skip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logit, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [layer_id])",
                            "Call"
                        ],
                        [
                            "tf.to_float(skip)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip, [1, layer_id])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_94": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_184": {
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_197": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "matmul_247": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_attn_2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_253": {
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "'branch_{}'.format(branch_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_120": {
                "name_or_scope": {
                    "value": "'branch_{}'.format(branch_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_208": {
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_216": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tanh_226": {
                "x": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_230": {
                "dims": {
                    "value": "tf.shape(logit)",
                    "type": "Call",
                    "possible_values": []
                },
                "value": {
                    "value": "-np.inf",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_238": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_270": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "get_variable_112": {
                "name": {
                    "value": "w_start",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.out_filters, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_114": {
                "name": {
                    "value": "w_count",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.out_filters - 1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_121": {
                "name": {
                    "value": "w_start",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_123": {
                "name": {
                    "value": "w_count",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.out_filters - 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_230": {
                "input": {
                    "value": "logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "logit / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['start'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([-query, query], axis=1)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft['count'][branch_id])",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logit)",
                            "BinOp"
                        ],
                        [
                            "tf.where(mask, x=logit, y=tf.fill(tf.shape(logit), -np.inf))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/cifar10/image_ops.py": {
        "tensorflow": {
            "floor_16": {
                "variable": {
                    "value": "binary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "random_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob",
                            "variable"
                        ],
                        [
                            "random_tensor + tf.random_uniform(noise_shape, dtype=tf.float32)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "conv2d_35": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "out_filters",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "[filter_size, filter_size]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": []
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                },
                "kernel_initializer": {
                    "value": "tf.contrib.keras.initializers.he_normal(seed=seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_47": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [in_size, out_size], seed=seed)",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pooling2d_65": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "k_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "Method Argument"
                        ],
                        [
                            "'SAME'",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "actual_data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ],
                        [
                            "'channels_last'",
                            "str"
                        ],
                        [
                            "'channels_first'",
                            "str"
                        ]
                    ]
                }
            },
            "where_137": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_138": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(mask)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_139": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(mask)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_84": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_102": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "offset",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_105": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scale",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_108": {
                "variable": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_mean",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_111": {
                "variable": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_variance",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_142": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "offset",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_145": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scale",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "boolean_mask_148": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(offset, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "boolean_mask_149": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(scale, mask)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_151": {
                "variable": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_mean",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_154": {
                "variable": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_variance",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x.get_shape()[3]]",
                            "List"
                        ],
                        [
                            "[x.get_shape()[1]]",
                            "List"
                        ],
                        [
                            "[num_channels]",
                            "List"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_181": {
                "condition": {
                    "value": "tf.greater(x, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "x * leaky",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_12": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "div_17": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_45": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv'",
                            "Method Argument"
                        ],
                        [
                            "'fc'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_72": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, k_size, stride, padding, data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.pad(out, [[0, 0], [h_pad, h_pad], [w_pad, w_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(out, [[0, 0], [0, 0], [h_pad, h_pad], [w_pad, w_pad]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [h_pad, h_pad], [w_pad, w_pad], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_86": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_101": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv'",
                            "Method Argument"
                        ],
                        [
                            "'fc'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "None if is_training else True",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "fused_batch_norm_116": {
                "variable": {
                    "value": "(x, mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(scale, mask)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(offset, mask)",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                },
                "is_training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "fused_batch_norm_126": {
                "variable": {
                    "value": "(x, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(scale, mask)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(offset, mask)",
                            "Call"
                        ]
                    ]
                },
                "mean": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                },
                "is_training": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_141": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'conv'",
                            "Method Argument"
                        ],
                        [
                            "'fc'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ],
                        [
                            "'bn'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "None if is_training else True",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "fused_batch_norm_159": {
                "variable": {
                    "value": "(x, mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(scale, mask)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(offset, mask)",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                },
                "is_training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "scatter_sub_164": {
                "variable": {
                    "value": "update_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(mask)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1.0 - decay) * (tf.boolean_mask(moving_mean, mask) - mean)",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "scatter_sub_165": {
                "variable": {
                    "value": "update_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(mask)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1.0 - decay) * (tf.boolean_mask(moving_variance, mask) - variance)",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "boolean_mask_170": {
                "variable": {
                    "value": "masked_moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "boolean_mask_171": {
                "variable": {
                    "value": "masked_moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fused_batch_norm_172": {
                "variable": {
                    "value": "(x, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('scale', shape, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(scale, mask)",
                            "Call"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('offset', shape, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(offset, mask)",
                            "Call"
                        ]
                    ]
                },
                "mean": {
                    "value": "masked_moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(moving_mean, mask)",
                            "Call"
                        ]
                    ]
                },
                "variance": {
                    "value": "masked_moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(moving_variance, mask)",
                            "Call"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "epsilon",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Method Argument"
                        ],
                        [
                            "0.001",
                            "Method Argument"
                        ]
                    ]
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ],
                        [
                            "'NHWC'",
                            "Method Argument"
                        ]
                    ]
                },
                "is_training": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_181": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "he_normal_38": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pad_76": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, k_size, stride, padding, data_format=actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.pad(out, [[0, 0], [h_pad, h_pad], [w_pad, w_pad], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.pad(out, [[0, 0], [0, 0], [h_pad, h_pad], [w_pad, w_pad]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [h_pad, h_pad], [w_pad, w_pad]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_124": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_168": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.div(x, keep_prob) * binary_tensor",
                            "BinOp"
                        ],
                        [
                            "tf.layers.conv2d(x, out_filters, [filter_size, filter_size], stride, padding, data_format=actual_data_format, kernel_initializer=tf.contrib.keras.initializers.he_normal(seed=seed))",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(x, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ],
                        [
                            "tf.identity(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_104": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_107": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_110": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_113": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_123": {
                "control_inputs": {
                    "value": "[update_mean, update_variance]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_initializer_144": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_147": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_153": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_156": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_167": {
                "control_inputs": {
                    "value": "[update_mean, update_variance]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_162": {
                "tensor": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_mean', shape, trainable=False, initializer=tf.constant_initializer(0.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "boolean_mask_163": {
                "tensor": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('moving_variance', shape, trainable=False, initializer=tf.constant_initializer(1.0, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/main.py": {
        "tensorflow": {
            "Graph_222": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_228": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "6",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CheckpointSaverHook_229": {
                "variable": {
                    "value": "checkpoint_saver_hook",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_steps": {
                    "value": "child_ops['num_train_batches'] * 100",
                    "type": "BinOp",
                    "possible_values": []
                },
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(max_to_keep=6)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_242": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "run_360": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "SingularMonitoredSession_243": {
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "hooks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[checkpoint_saver_hook]",
                            "List"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/micro_child.py": {
        "tensorflow": {
            "Variable_103": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "avg_pool_130": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "avg_pool_150": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_159": {
                "variable": {
                    "value": "final_path",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[path1, path2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "concat_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "int"
                        ],
                        [
                            "1",
                            "int"
                        ]
                    ]
                }
            },
            "minimum_203": {
                "variable": {
                    "value": "step_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "step_ratio",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(self.global_step + 1) / tf.to_float(self.num_train_steps)",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(1.0, step_ratio)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_575": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_659": {
                "variable": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.num_cells + 2], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_660": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(used, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_int32_661": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_662": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "size_663": {
                "variable": {
                    "value": "num_outs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_664": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x, x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_665": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_694": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(prev_layers[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_703": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_705": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.aux_logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_715": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_716": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_717": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_718": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_719": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_766": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_767": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_768": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_769": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_770": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_805": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_806": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_807": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_808": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_809": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_135": {
                "variable": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.avg_pool(x, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path1, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_155": {
                "variable": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "path2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, pad_arr)[:, 1:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.pad(x, pad_arr)[:, :, 1:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.avg_pool(path2, [1, 1, 1, 1], stride_spec, 'VALID', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(path2, w, [1, 1, 1, 1], 'VALID', data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_331": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_420": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_421": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "average_pooling2d_525": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_541": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_639": {
                "variable": {
                    "value": "prev_layers",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x, x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[layers[-1], x]",
                            "List"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "[prev_layers[0], prev_layers[1]]",
                            "List"
                        ],
                        [
                            "self._maybe_calibrate_size(layers, out_filters, is_training=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_673": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 2, 3, 0, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_674": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, H, W, num_outs * out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_687": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.where(tf.equal(used, 0))",
                            "Call"
                        ],
                        [
                            "tf.to_int32(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(indices, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_688": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, num_outs * out_filters, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_689": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                }
            },
            "conv2d_690": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_708": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.aux_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_710": {
                "variable": {
                    "value": "self.aux_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=self.aux_logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_755": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, is_training=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, is_training=True, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_756": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_757": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_758": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_759": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_781": {
                "variable": {
                    "value": "(x_valid_shuffle, y_valid_shuffle)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.images['valid_original'], self.labels['valid_original']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "25000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_123": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_132": {
                "name_or_scope": {
                    "value": "path1_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_152": {
                "name_or_scope": {
                    "value": "path2_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_float_202": {
                "x": {
                    "value": "self.num_train_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "calibrate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_246": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "reuse",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "conv2d_250": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_334": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_338": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_359": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "separable_conv2d_360": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_strides(stride)",
                            "Call"
                        ],
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_382": {
                "name_or_scope": {
                    "value": "final_combine",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_395": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_416": {
                "name_or_scope": {
                    "value": "layer_base",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_524": {
                "name_or_scope": {
                    "value": "avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_540": {
                "name_or_scope": {
                    "value": "max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_561": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, x_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_562": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_563": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_583": {
                "name_or_scope": {
                    "value": "'conv_{0}x{0}'.format(filter_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_660": {
                "x": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.num_cells + 2], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_680": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2, 3, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_681": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[N, num_outs * out_filters, H, W]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_685": {
                "name_or_scope": {
                    "value": "final_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_694": {
                "input": {
                    "value": "prev_layers[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_776": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_793": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_794": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_795": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_801": {
                "variable": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_pre_process, x_valid_shuffle, back_prop=False)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_120": {
                "name_or_scope": {
                    "value": "path_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_143": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "pad_147": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "pad_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[0, 0], [0, 1], [0, 1], [0, 0]]",
                            "List"
                        ],
                        [
                            "[[0, 0], [0, 0], [0, 1], [0, 1]]",
                            "List"
                        ]
                    ]
                }
            },
            "relu_220": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_234": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_235": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_248": {
                "name_or_scope": {
                    "value": "stem_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_335": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_356": {
                "name_or_scope": {
                    "value": "'sep_conv_{}'.format(conv_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_397": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(out, axis=3)",
                            "Call"
                        ],
                        [
                            "tf.concat(out, axis=1)",
                            "Call"
                        ],
                        [
                            "self._fixed_combine(layers, used, out_filters, is_training, normal_or_reduction_cell)",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ],
                        [
                            "[self._enas_conv(x, curr_cell, prev_cell, 3, out_filters), self._enas_conv(x, curr_cell, prev_cell, 5, out_filters), avg_pool, max_pool, x]",
                            "List"
                        ],
                        [
                            "tf.stack(out, axis=0)",
                            "Call"
                        ],
                        [
                            "out[op_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "tf.stack(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(out, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 2, 3, 0, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, H, W, num_outs * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, [N, num_outs * out_filters, H, W])",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(out)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(out, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(out, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.reshape(out, tf.shape(prev_layers[0]))",
                            "Call"
                        ],
                        [
                            "x + y",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_429": {
                "name_or_scope": {
                    "value": "'cell_{}'.format(cell_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_533": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, avg_pool_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_534": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(avg_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(avg_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(avg_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_535": {
                "variable": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "avg_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(avg_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(avg_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(avg_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_549": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, max_pool_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_550": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(max_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(max_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(max_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_551": {
                "variable": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "max_pool",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [1, 1], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(max_pool)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(max_pool, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(max_pool, is_training=True, data_format=self.data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_558": {
                "name_or_scope": {
                    "value": "x_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_592": {
                "variable": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[filter_size, filter_size, inp_c, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_598": {
                "variable": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, inp_c, out_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "relu_613": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "separable_conv2d_614": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "depthwise_filter": {
                    "value": "w_depthwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_depth', [f_size, f_size, inp_c, 1])",
                            "Call"
                        ],
                        [
                            "create_weight('w_depth', [num_possible_inputs, filter_size * filter_size * inp_c])",
                            "Call"
                        ],
                        [
                            "w_depthwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_depthwise, [filter_size, filter_size, inp_c, 1])",
                            "Call"
                        ]
                    ]
                },
                "pointwise_filter": {
                    "value": "w_pointwise",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w_point', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w_point', [num_possible_inputs, inp_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w_pointwise[prev_cell, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w_pointwise, [1, 1, inp_c, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "fused_batch_norm_620": {
                "variable": {
                    "value": "(x, _, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('scale', [num_possible_inputs, out_filters], initializer=one_init)",
                            "Call"
                        ],
                        [
                            "scale[prev_cell]",
                            "Subscript"
                        ]
                    ]
                },
                "offset": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('offset', [num_possible_inputs, out_filters], initializer=zero_init)",
                            "Call"
                        ],
                        [
                            "offset[prev_cell]",
                            "Subscript"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "1e-05",
                    "type": "float",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                },
                "is_training": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_640": {
                "name_or_scope": {
                    "value": "'cell_{0}'.format(cell_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_646": {
                "variable": {
                    "value": "x_used",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "x_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc[4 * cell_id]",
                            "Subscript"
                        ],
                        [
                            "arc[4 * cell_id]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_653": {
                "variable": {
                    "value": "y_used",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "y_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arc[4 * cell_id + 2]",
                            "Subscript"
                        ],
                        [
                            "arc[4 * cell_id + 2]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_669": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_670": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_671": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_672": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "trainable_variables_722": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_797": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_219": {
                "name_or_scope": {
                    "value": "pool_x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "relu_225": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_226": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_232": {
                "name_or_scope": {
                    "value": "pool_y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_264": {
                "name_or_scope": {
                    "value": "'layer_{0}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_294": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "average_pooling2d_295": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[5, 5]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_435": {
                "name_or_scope": {
                    "value": "x_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_475": {
                "name_or_scope": {
                    "value": "y_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_529": {
                "name_or_scope": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_545": {
                "name_or_scope": {
                    "value": "conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_586": {
                "name_or_scope": {
                    "value": "'stack_{0}'.format(conv_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_601": {
                "variable": {
                    "value": "zero_init",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_602": {
                "variable": {
                    "value": "one_init",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_641": {
                "name_or_scope": {
                    "value": "x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_648": {
                "name_or_scope": {
                    "value": "y",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_676": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_677": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_678": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_679": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prev_layers[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "variable_scope_223": {
                "name_or_scope": {
                    "value": "pool_x",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_293": {
                "name_or_scope": {
                    "value": "aux_head",
                    "type": "str",
                    "possible_values": []
                }
            },
            "conv2d_301": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_305": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_311": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_315": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_322": {
                "variable": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "aux_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(aux_logits, [5, 5], [3, 3], 'VALID', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(aux_logits, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(aux_logits, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(aux_logits)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(aux_logits, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.matmul(aux_logits, w)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_600": {
                "name_or_scope": {
                    "value": "bn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_298": {
                "name_or_scope": {
                    "value": "proj",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_307": {
                "name_or_scope": {
                    "value": "avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_317": {
                "name_or_scope": {
                    "value": "fc",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_326": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_388": {
                "name_or_scope": {
                    "value": "'calibrate_{0}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "average_pooling2d_442": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[x_stride, x_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_446": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[x_stride, x_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_451": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_452": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_462": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_463": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "drop_path(x, drop_path_keep_prob)",
                            "Call"
                        ],
                        [
                            "layers[0]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(images, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "global_avg_pool(x, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(x, self.keep_prob)",
                            "Call"
                        ],
                        [
                            "tf.matmul(x, w)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.normal_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.normal_arc, out_filters, 1, is_training, normal_or_reduction_cell='normal')",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "self._enas_layer(layer_id, layers, self.reduce_arc, out_filters)",
                            "Call"
                        ],
                        [
                            "self._fixed_layer(layer_id, layers, self.reduce_arc, out_filters, 2, is_training, normal_or_reduction_cell='reduction')",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=strides, padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layer",
                            "variable"
                        ],
                        [
                            "self._factorized_reduction(layer, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[x_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(x, f_size, out_filters, x_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(x, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(x, [3, 3], [x_stride, x_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(x, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(x, w, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(x, is_training=True, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(x)",
                            "Call"
                        ],
                        [
                            "tf.nn.separable_conv2d(x, depthwise_filter=w_depthwise, pointwise_filter=w_pointwise, strides=[1, 1, 1, 1], padding='SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[x_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(x, cell_id, x_id, x_op, out_filters)",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "average_pooling2d_482": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[y_stride, y_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pooling2d_486": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "[3, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[y_stride, y_stride]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.actual_data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_491": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_492": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_502": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_503": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "layers[y_id]",
                            "Subscript"
                        ],
                        [
                            "self._fixed_conv(y, f_size, out_filters, y_stride, is_training)",
                            "Call"
                        ],
                        [
                            "self._apply_drop_path(y, layer_id)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(y, [3, 3], [y_stride, y_stride], 'SAME', data_format=self.actual_data_format)",
                            "Call"
                        ],
                        [
                            "self._factorized_reduction(y, out_filters, 2, is_training)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(y)",
                            "Call"
                        ],
                        [
                            "tf.nn.conv2d(y, w, [1, 1, 1, 1], 'SAME', data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm(y, is_training, data_format=self.data_format)",
                            "Call"
                        ],
                        [
                            "prev_layers[y_id, :, :, :, :]",
                            "Subscript"
                        ],
                        [
                            "self._enas_cell(y, cell_id, y_id, y_op, out_filters)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters // 2])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[0], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, c[1], out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [3, 3, 3, self.out_filters * 3])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, 128])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [hw, hw, inp_c, 768])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [inp_c, 10])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [1, 1, inp_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, avg_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, avg_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, max_pool_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, max_pool_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [num_possible_inputs, x_c * out_filters])",
                            "Call"
                        ],
                        [
                            "w[prev_cell]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(w, [1, 1, x_c, out_filters])",
                            "Call"
                        ],
                        [
                            "create_weight('w', [self.num_cells + 2, out_filters * out_filters])",
                            "Call"
                        ],
                        [
                            "tf.gather(w, indices, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(w, [1, 1, num_outs * out_filters, out_filters])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "self.data_format",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/micro_controller.py": {
        "tensorflow": {
            "placeholder_87": {
                "variable": {
                    "value": "self.normal_arc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * self.num_cells]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "placeholder_88": {
                "variable": {
                    "value": "self.reduce_arc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[4 * self.num_cells]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_91": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "TensorArray_128": {
                "variable": {
                    "value": "anchors",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clear_after_read": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorArray_130": {
                "variable": {
                    "value": "anchors_w_1",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "clear_after_read": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorArray_132": {
                "variable": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "self.num_cells * 4",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "while_loop_224": {
                "variable": {
                    "value": "loop_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "_condition",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "_body",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "loop_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.constant(2, dtype=tf.int32, name='layer_id'), inputs, prev_c, prev_h, anchors, anchors_w_1, arc_seq, tf.constant([0.0], dtype=tf.float32, name='entropy'), tf.constant([0.0], dtype=tf.float32, name='log_prob')]",
                            "List"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_228": {
                "variable": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorArray(tf.int32, size=self.num_cells * 4)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-3].stack()",
                            "Call"
                        ],
                        [
                            "tf.reshape(arc_seq, [-1])",
                            "Call"
                        ],
                        [
                            "arc_seq.write(start_id + 2 * i, index)",
                            "Call"
                        ],
                        [
                            "arc_seq.write(start_id + 2 * i + 1, op_id)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_229": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loop_outputs[-2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_230": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loop_outputs[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_sum_246": {
                "variable": {
                    "value": "self.sample_log_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.sample_log_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_247": {
                "variable": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_sub_248": {
                "variable": {
                    "value": "baseline_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "(1 - self.bl_dec) * (self.baseline - self.reward)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_255": {
                "variable": {
                    "value": "self.train_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "train_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_278": {
                "variable": {
                    "value": "self.skip_rate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_100": {
                "variable": {
                    "value": "self.g_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "g_emb",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_153": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_252": {
                "variable": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_92": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(minval=-0.1, maxval=0.1)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_102": {
                "variable": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_branches, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_104": {
                "variable": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.num_branches]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_107": {
                "variable": {
                    "value": "self.b_soft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.num_branches]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(b_init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_114": {
                "variable": {
                    "value": "self.b_soft_no_learn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "b_soft_no_learn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([0.25, 0.25] + [-0.25] * (self.num_branches - 2), dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "np.reshape(b_soft_no_learn, [1, self.num_branches])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_117": {
                "variable": {
                    "value": "self.w_attn_1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_118": {
                "variable": {
                    "value": "self.w_attn_2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_119": {
                "variable": {
                    "value": "self.v_attn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "v",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_149": {
                "x": {
                    "value": "layer_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(self.lstm_num_layers)",
                            "Call"
                        ],
                        [
                            [
                                0,
                                1
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "self.num_cells + 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_160": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchors_w_1.gather(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(query, [layer_id, self.lstm_size])",
                            "Call"
                        ],
                        [
                            "tf.tanh(query + tf.matmul(next_h[-1], self.w_attn_2))",
                            "Call"
                        ],
                        [
                            "tf.matmul(query, self.v_attn)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[layer_id, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_161": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "query + tf.matmul(next_h[-1], self.w_attn_2)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "matmul_162": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchors_w_1.gather(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(query, [layer_id, self.lstm_size])",
                            "Call"
                        ],
                        [
                            "tf.tanh(query + tf.matmul(next_h[-1], self.w_attn_2))",
                            "Call"
                        ],
                        [
                            "tf.matmul(query, self.v_attn)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.v_attn",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_163": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "anchors_w_1.gather(indices)",
                            "Call"
                        ],
                        [
                            "tf.reshape(query, [layer_id, self.lstm_size])",
                            "Call"
                        ],
                        [
                            "tf.tanh(query + tf.matmul(next_h[-1], self.w_attn_2))",
                            "Call"
                        ],
                        [
                            "tf.matmul(query, self.v_attn)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, layer_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multinomial_168": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_169": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_170": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(index, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_172": {
                "variable": {
                    "value": "curr_log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_175": {
                "variable": {
                    "value": "curr_ent",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.nn.softmax(logits))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multinomial_192": {
                "variable": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_193": {
                "variable": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(op_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(op_id, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_194": {
                "variable": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(op_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(op_id, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_196": {
                "variable": {
                    "value": "curr_log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(op_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(op_id, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_199": {
                "variable": {
                    "value": "curr_ent",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=tf.nn.softmax(logits))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "embedding_lookup_202": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "op_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(op_id)",
                            "Call"
                        ],
                        [
                            "tf.reshape(op_id, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_213": {
                "value": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "layer_id",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_220": {
                "value": {
                    "value": "[0.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "entropy",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_221": {
                "value": {
                    "value": "[0.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "log_prob",
                    "type": "str",
                    "possible_values": []
                }
            },
            "to_float_239": {
                "x": {
                    "value": "child_model.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_240": {
                "x": {
                    "value": "child_model.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_251": {
                "control_inputs": {
                    "value": "[baseline_update]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_93": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_101": {
                "name_or_scope": {
                    "value": "emb",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_103": {
                "name_or_scope": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_116": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_135": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_137": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_144": {
                "input": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_146": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_attn_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_206": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_attn_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_257": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_97": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self.lstm_size, 4 * self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_175": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.nn.softmax(logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_184": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_with_logits_199": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "tf.nn.softmax(logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_96": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_109": {
                "value": {
                    "value": "b_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([10.0, 10.0] + [0] * (self.num_branches - 2), dtype=np.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_161": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_attn_2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_167": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_178": {
                "input_tensor": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_189": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_176": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_200": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(query, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits + self.b_soft_no_learn",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft) + self.b_soft",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "op_tanh * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/cifar10/micro_evaluation.py": {
        "tensorflow": {
            "Graph_229": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_296": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_235": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "CheckpointSaverHook_236": {
                "variable": {
                    "value": "checkpoint_saver_hook",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_steps": {
                    "value": "child_ops['num_train_batches']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "{'child': child_model, 'global_step': child_model.global_step, 'loss': child_model.loss, 'train_op': child_model.train_op, 'lr': child_model.lr, 'grad_norm': child_model.grad_norm, 'train_acc': child_model.train_acc, 'optimizer': child_model.optimizer, 'num_train_batches': child_model.num_train_batches}",
                            "Dict"
                        ],
                        [
                            "self.ops['child']",
                            "Subscript"
                        ]
                    ]
                },
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(max_to_keep=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_249": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "SingularMonitoredSession_251": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "hooks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[checkpoint_saver_hook]",
                            "List"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/cifar10/models.py": {
        "tensorflow": {
            "sparse_softmax_cross_entropy_with_logits_193": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_195": {
                "variable": {
                    "value": "self.loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=self.y_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_197": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_198": {
                "variable": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_199": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_200": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_201": {
                "variable": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.train_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_210": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "argmax_243": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_244": {
                "variable": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_245": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_246": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_247": {
                "variable": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.test_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_283": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_284": {
                "variable": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_285": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "valid_shuffle_preds",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(valid_shuffle_preds)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "y_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_int32_286": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_287": {
                "variable": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_shuffle_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_76": {
                "variable": {
                    "value": "(x_train, y_train)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[images['train'], labels['train']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "50000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "map_fn_106": {
                "variable": {
                    "value": "self.x_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_train",
                    "type": "variable",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "batch_136": {
                "variable": {
                    "value": "(self.x_test, self.y_test)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[images['test'], labels['test']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "10000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "argmax_233": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._model(self.x_train, True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_valid, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(self.x_test, False, reuse=True)",
                            "Call"
                        ],
                        [
                            "self._model(x_valid_shuffle, False, reuse=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_234": {
                "variable": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "equal_235": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_preds",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_int32_236": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_237": {
                "variable": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.valid_acc",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_batch_258": {
                "variable": {
                    "value": "(x_valid_shuffle, y_valid_shuffle)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.images['valid_original'], self.labels['valid_original']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "25000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "min_after_dequeue": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "device_70": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_89": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_90": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_91": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_120": {
                "variable": {
                    "value": "(self.x_valid, self.y_valid)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[images['valid'], labels['valid']]",
                    "type": "List",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "self.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "5000",
                    "type": "int",
                    "possible_values": []
                },
                "enqueue_many": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "num_threads": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "allow_smaller_final_batch": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_131": {
                "variable": {
                    "value": "images[test]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "a": {
                    "value": "images['test']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "device_252": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pad_270": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[4, 4], [4, 4], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_crop_271": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[32, 32, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_flip_left_right_272": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "seed": {
                    "value": "self.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_279": {
                "variable": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_pre_process",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "x_valid_shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_pre_process, x_valid_shuffle, back_prop=False)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ones_93": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.cutout_size, self.cutout_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_95": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([self.cutout_size, self.cutout_size], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.pad(mask, [[self.cutout_size + start[0], 32 - start[0]], [self.cutout_size + start[1], 32 - start[1]]])",
                            "Call"
                        ],
                        [
                            "mask[self.cutout_size:self.cutout_size + 32, self.cutout_size:self.cutout_size + 32]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mask, [32, 32, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(mask, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[self.cutout_size + start[0], 32 - start[0]], [self.cutout_size + start[1], 32 - start[1]]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_99": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([self.cutout_size, self.cutout_size], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.pad(mask, [[self.cutout_size + start[0], 32 - start[0]], [self.cutout_size + start[1], 32 - start[1]]])",
                            "Call"
                        ],
                        [
                            "mask[self.cutout_size:self.cutout_size + 32, self.cutout_size:self.cutout_size + 32]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mask, [32, 32, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(mask, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[32, 32, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_100": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([self.cutout_size, self.cutout_size], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.pad(mask, [[self.cutout_size + start[0], 32 - start[0]], [self.cutout_size + start[1], 32 - start[1]]])",
                            "Call"
                        ],
                        [
                            "mask[self.cutout_size:self.cutout_size + 32, self.cutout_size:self.cutout_size + 32]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mask, [32, 32, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(mask, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_101": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.equal(mask, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_115": {
                "variable": {
                    "value": "images[valid]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "a": {
                    "value": "images['valid']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 3, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_204": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "transpose_274": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[2, 0, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_101": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones([self.cutout_size, self.cutout_size], dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.pad(mask, [[self.cutout_size + start[0], 32 - start[0]], [self.cutout_size + start[1], 32 - start[1]]])",
                            "Call"
                        ],
                        [
                            "mask[self.cutout_size:self.cutout_size + 32, self.cutout_size:self.cutout_size + 32]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(mask, [32, 32, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(mask, [1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_101": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.equal(mask, 0), x=x, y=tf.zeros_like(x))",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ],
                        [
                            "tf.pad(x, [[4, 4], [4, 4], [0, 0]])",
                            "Call"
                        ],
                        [
                            "tf.random_crop(x, [32, 32, 3], seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(x, seed=self.seed)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [2, 0, 1])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/common_ops.py": {
        "tensorflow": {
            "matmul_6": {
                "variable": {
                    "value": "ifog",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([x, prev_h], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_7": {
                "variable": {
                    "value": "(i, f, o, g)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "ifog",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.concat([x, prev_h], axis=1), w)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_8": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(i)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_9": {
                "variable": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "f",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(f)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_10": {
                "variable": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(o)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_11": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(g)",
                            "Call"
                        ]
                    ]
                }
            },
            "he_normal_29": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_30": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.keras.initializers.he_normal(seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "trainable",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "constant_initializer_35": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_36": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.keras.initializers.he_normal(seed=seed)",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_6": {
                "values": {
                    "value": "[x, prev_h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tanh_13": {
                "x": {
                    "value": "next_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "i * g + f * prev_c",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/controller.py": {
        "tensorflow": {}
    },
    "software/enas/src/ptb/data_utils.py": {
        "tensorflow": {
            "convert_to_tensor_16": {
                "variable": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(raw_data, name='raw_data', dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "raw_data",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "size_18": {
                "variable": {
                    "value": "data_len",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "raw_data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(raw_data, name='raw_data', dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_20": {
                "variable": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "raw_data[0:batch_size * batch_len]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, batch_len]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_25": {
                "variable": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ],
                        [
                            "tf.identity(epoch_size, name='epoch_size')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "epoch_size",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_24": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_30": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([1], minval=0, maxval=batch_len - num_steps, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(i)",
                            "Call"
                        ],
                        [
                            "tf.train.range_input_producer(epoch_size, shuffle=shuffle).dequeue()",
                            "Call"
                        ]
                    ]
                }
            },
            "strided_slice_31": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, i + num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "strided_slice_33": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, i + num_steps + 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_input_producer_36": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "limit": {
                    "value": "epoch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batch_len - 1) // num_steps",
                            "BinOp"
                        ],
                        [
                            "tf.identity(epoch_size, name='epoch_size')",
                            "Call"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "shuffle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "strided_slice_37": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i * num_steps]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, (i + 1) * num_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "strided_slice_39": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input_": {
                    "value": "data",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(raw_data[0:batch_size * batch_len], [batch_size, batch_len])",
                            "Call"
                        ]
                    ]
                },
                "begin": {
                    "value": "[0, i * num_steps + 1]",
                    "type": "List",
                    "possible_values": []
                },
                "end": {
                    "value": "[batch_size, (i + 1) * num_steps + 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/ptb/main.py": {
        "tensorflow": {
            "Graph_218": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CheckpointSaverHook_228": {
                "variable": {
                    "value": "checkpoint_saver_hook",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_steps": {
                    "value": "ops['num_train_batches']",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "{}",
                            "Dict"
                        ],
                        [
                            "{'child': child_ops, 'controller': controller_ops, 'num_train_batches': child_model.num_train_batches, 'eval_every': child_model.num_train_batches * FLAGS.eval_every_epochs, 'eval_func': child_model.eval_once}",
                            "Dict"
                        ],
                        [
                            "get_ops(x_train, x_valid, x_test)",
                            "Call"
                        ]
                    ]
                },
                "saver": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.Saver(max_to_keep=10)",
                            "Call"
                        ],
                        [
                            "child_ops['optimizer'].swapping_saver(max_to_keep=10)",
                            "Call"
                        ]
                    ]
                }
            },
            "run_392": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_225": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                }
            },
            "SingularMonitoredSession_240": {
                "hooks": {
                    "value": "hooks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[checkpoint_saver_hook]",
                            "List"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "FLAGS.output_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/ptb/ptb_enas_child.py": {
        "tensorflow": {
            "reshape_111": {
                "variable": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.y_train",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size * self.bptt_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_120": {
                "variable": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.y_valid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size * self.bptt_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_126": {
                "variable": {
                    "value": "self.y_valid_rl",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.y_valid_rl",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.batch_size * self.bptt_steps]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_132": {
                "variable": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.y_test",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_190": {
                "variable": {
                    "value": "self.train_ppl",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(log_probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_205": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_234": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_235": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(all_h, self.w_emb, transpose_b=True)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stop_gradient_244": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_246": {
                "variable": {
                    "value": "self.valid_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_log_probs(all_h, self.y_train, batch_size=self.batch_size, is_training=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid_rl)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_test)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_253": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_255": {
                "variable": {
                    "value": "self.rl_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_log_probs(all_h, self.y_train, batch_size=self.batch_size, is_training=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid_rl)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_test)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_256": {
                "variable": {
                    "value": "self.rl_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.rl_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stop_gradient_262": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_264": {
                "variable": {
                    "value": "self.test_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_log_probs(all_h, self.y_train, batch_size=self.batch_size, is_training=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid_rl)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_test)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_279": {
                "variable": {
                    "value": "(h, t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w)",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_291": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_347": {
                "variable": {
                    "value": "(h, t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w)",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "case_349": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "{tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}",
                    "type": "Dict",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : tf.constant(0.0, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sigmoid_357": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_393": {
                "variable": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.rhn_depth], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ],
                        [
                            "tf.equal(used, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_394": {
                "variable": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.rhn_depth], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ],
                        [
                            "tf.equal(used, 0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_397": {
                "variable": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "[prev_layer for (u, prev_layer) in zip(used, layers) if u == 0]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(layers) / np.sum(1.0 - used)",
                            "BinOp"
                        ],
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "tf.stack(layers)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(layers, used)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "batch_norm(layers, is_training)",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.rhn_depth], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ],
                        [
                            "tf.equal(used, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_398": {
                "variable": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "[prev_layer for (u, prev_layer) in zip(used, layers) if u == 0]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(layers) / np.sum(1.0 - used)",
                            "BinOp"
                        ],
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "tf.stack(layers)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(layers, used)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "batch_norm(layers, is_training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TensorArray_414": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "size": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ],
                        [
                            "self.bptt_steps",
                            "Attribute"
                        ]
                    ]
                },
                "infer_shape": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "embedding_lookup_415": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "while_loop_486": {
                "variable": {
                    "value": "loop_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "condition",
                    "type": "variable",
                    "possible_values": []
                },
                "body": {
                    "value": "body",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "loop_vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.constant(0, dtype=tf.int32), start_h, all_h]",
                            "List"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_490": {
                "variable": {
                    "value": "self.all_h_diff",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_h_diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(all_h[1:, :, :] - all_h[:-1, :, :]) ** 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_491": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_492": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * num_steps, self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_513": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-init_range",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "init_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "float"
                        ],
                        [
                            "0.05",
                            "float"
                        ],
                        [
                            "0.04",
                            "float"
                        ]
                    ]
                }
            },
            "matmul_274": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([x * x_mask, prev_s * s_mask], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w_prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w_prev', [2 * self.num_funcs * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w_prev', [2 * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_276": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([x, prev_s], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w_prev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w_prev', [2 * self.num_funcs * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w_prev', [2 * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_282": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_340": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([x * x_mask, prev_s * s_mask], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w_prev[start_idx:end_idx, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_343": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.concat([x, prev_s], axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "w_prev[start_idx:end_idx, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stack_396": {
                "variable": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "[prev_layer for (u, prev_layer) in zip(used, layers) if u == 0]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(layers) / np.sum(1.0 - used)",
                            "BinOp"
                        ],
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "tf.stack(layers)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(layers, used)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "batch_norm(layers, is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_426": {
                "variable": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_gen_mask([batch_size, num_steps], self.lstm_e_keep)",
                            "Call"
                        ],
                        [
                            "tf.where(r, tf.zeros_like(e_mask), e_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(e_mask, [batch_size, num_steps, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_427": {
                "variable": {
                    "value": "ones",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_gen_mask([batch_size, num_steps], self.lstm_e_keep)",
                            "Call"
                        ],
                        [
                            "tf.where(r, tf.zeros_like(e_mask), e_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(e_mask, [batch_size, num_steps, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_435": {
                "variable": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.constant([[False]] * batch_size, dtype=tf.bool)]",
                            "List"
                        ],
                        [
                            "tf.concat(r, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_436": {
                "variable": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "r",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.constant([[False]] * batch_size, dtype=tf.bool)]",
                            "List"
                        ],
                        [
                            "tf.concat(r, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "tf.zeros_like(e_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_gen_mask([batch_size, num_steps], self.lstm_e_keep)",
                            "Call"
                        ],
                        [
                            "tf.where(r, tf.zeros_like(e_mask), e_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(e_mask, [batch_size, num_steps, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_437": {
                "variable": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_gen_mask([batch_size, num_steps], self.lstm_e_keep)",
                            "Call"
                        ],
                        [
                            "tf.where(r, tf.zeros_like(e_mask), e_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(e_mask, [batch_size, num_steps, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_steps, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_189": {
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_log_probs(all_h, self.y_train, batch_size=self.batch_size, is_training=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid_rl)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_test)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_189": {
                "x": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_190": {
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_log_probs(all_h, self.y_train, batch_size=self.batch_size, is_training=True)",
                            "Call"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_valid_rl)",
                            "Call"
                        ],
                        [
                            "self._get_log_probs(all_h, self.y_test)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_284": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_308": {
                "variable": {
                    "value": "(h, t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w)",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sigmoid_321": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_327": {
                "inputs": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "[prev_layer for (u, prev_layer) in zip(used, layers) if u == 0]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(layers) / np.sum(1.0 - used)",
                            "BinOp"
                        ],
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "tf.stack(layers)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(layers, used)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "batch_norm(layers, is_training)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_345": {
                "name_or_scope": {
                    "value": "rhn_layer_0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_367": {
                "variable": {
                    "value": "curr_used",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "prev_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.rhn_depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_372": {
                "variable": {
                    "value": "prev_s",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "[prev_layer for (u, prev_layer) in zip(used, layers) if u == 0]",
                            "ListComp"
                        ],
                        [
                            "tf.add_n(layers) / np.sum(1.0 - used)",
                            "BinOp"
                        ],
                        [
                            "[s]",
                            "List"
                        ],
                        [
                            "tf.stack(layers)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(layers, used)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "batch_norm(layers, is_training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_379": {
                "variable": {
                    "value": "(h, t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w_skip[rhn_layer_id])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x, prev_s], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.concat([x * x_mask, prev_s * s_mask], axis=1), w_prev[start_idx:end_idx, :])",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s * s_mask, w)",
                            "Call"
                        ],
                        [
                            "tf.matmul(prev_s, w)",
                            "Call"
                        ],
                        [
                            "batch_norm(ht, is_training)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "case_380": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "pred_fn_pairs": {
                    "value": "{tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}",
                    "type": "Dict",
                    "possible_values": []
                },
                "default": {
                    "value": "lambda : tf.constant(0.0, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "exclusive": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sigmoid_388": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(t)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_395": {
                "control_inputs": {
                    "value": "[tf.Assert(tf.reduce_any(used), [used])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "logical_and_430": {
                "variable": {
                    "value": "should_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.equal(x[:, :step], x[:, step:step + 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.equal(e_mask[:, :step], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_any_433": {
                "variable": {
                    "value": "should_zero",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "should_zero",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.equal(x[:, :step], x[:, step:step + 1]), tf.equal(e_mask[:, :step], 0))",
                            "Call"
                        ],
                        [
                            "tf.reduce_any(should_zero, axis=1, keep_dims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "less_451": {
                "x": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(1, num_steps)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "int"
                        ],
                        [
                            "self.bptt_steps",
                            "Attribute"
                        ]
                    ]
                }
            },
            "constant_485": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_502": {
                "variable": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "all_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(all_h)",
                            "Call"
                        ],
                        [
                            "tf.TensorArray(tf.float32, size=num_steps, infer_shape=True)",
                            "Call"
                        ],
                        [
                            "loop_outputs[-1].stack()",
                            "Call"
                        ],
                        [
                            "tf.transpose(all_h, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(all_h, [batch_size * num_steps, self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.identity(all_h)",
                            "Call"
                        ],
                        [
                            "all_h.write(step, out_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_515": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(minval=-init_range, maxval=init_range)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_551": {
                "variable": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.vocab_size, self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_193": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_201": {
                "x": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "to_float_204": {
                "x": {
                    "value": "self.batch_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_274": {
                "values": {
                    "value": "[x * x_mask, prev_s * s_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_276": {
                "values": {
                    "value": "[x, prev_s]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "identity_286": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_298": {
                "name_or_scope": {
                    "value": "'rhn_layer_{}'.format(rhn_layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_304": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "prev_s * s_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "b": {
                    "value": "w_skip[rhn_layer_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_306": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "prev_s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[prev_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "prev_s[prev_idx * batch_size:(prev_idx + 1) * batch_size, :]",
                            "Subscript"
                        ]
                    ]
                },
                "b": {
                    "value": "w_skip[rhn_layer_id]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "tanh_311": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_340": {
                "values": {
                    "value": "[x * x_mask, prev_s * s_mask]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_343": {
                "values": {
                    "value": "[x, prev_s]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_351": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_352": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_353": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_354": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_364": {
                "name_or_scope": {
                    "value": "'rhn_layer_{}'.format(rhn_layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_375": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "prev_s * s_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w_skip[rhn_layer_id][w_start:w_end, :]",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable('w', [self.num_funcs * rhn_layer_id * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', [self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_377": {
                "variable": {
                    "value": "ht",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "prev_s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layers[prev_idx]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(layers, axis=0)",
                            "Call"
                        ],
                        [
                            "prev_s[prev_idx * batch_size:(prev_idx + 1) * batch_size, :]",
                            "Subscript"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "w_skip[rhn_layer_id][w_start:w_end, :]",
                            "Subscript"
                        ],
                        [
                            "tf.get_variable('w', [self.num_funcs * rhn_layer_id * self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', [self.lstm_hidden_size, 2 * self.lstm_hidden_size])",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_428": {
                "value": {
                    "value": "[[False]] * batch_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_436": {
                "input": {
                    "value": "e_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_gen_mask([batch_size, num_steps], self.lstm_e_keep)",
                            "Call"
                        ],
                        [
                            "tf.where(r, tf.zeros_like(e_mask), e_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(e_mask, [batch_size, num_steps, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_454": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_497": {
                "ref": {
                    "value": "s_h",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.zeros_like(s_h)",
                    "type": "Call",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_498": {
                "ref": {
                    "value": "s_h",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.stop_gradient(n_h)",
                    "type": "Call",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "control_dependencies_501": {
                "control_inputs": {
                    "value": "carry_states",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "variable_scope_550": {
                "name_or_scope": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_554": {
                "name_or_scope": {
                    "value": "starting_states",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_200": {
                "input_tensor": {
                    "value": "all_h ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_288": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_313": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_351": {
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_352": {
                "features": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_353": {
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_354": {
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_356": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Assert_395": {
                "condition": {
                    "value": "tf.reduce_any(used)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "[used]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floor_420": {
                "x": {
                    "value": "_mask + keep_prob",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_431": {
                "x": {
                    "value": "x[:, :step]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "x[:, step:step + 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "equal_432": {
                "x": {
                    "value": "e_mask[:, :step]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_497": {
                "input": {
                    "value": "s_h",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stop_gradient_498": {
                "input": {
                    "value": "n_h",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_517": {
                "name_or_scope": {
                    "value": "rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_535": {
                "name_or_scope": {
                    "value": "rnn",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_315": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_382": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_383": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_384": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "equal_385": {
                "x": {
                    "value": "func_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[0]",
                            "Subscript"
                        ],
                        [
                            "self.sample_arc[start_idx + 1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_395": {
                "input_tensor": {
                    "value": "used",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([self.rhn_depth], dtype=np.int32)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.add_n(used)",
                            "Call"
                        ],
                        [
                            "tf.equal(used, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_457": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_521": {
                "variable": {
                    "value": "w_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w_prev",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self.num_funcs * self.lstm_hidden_size, 2 * self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_539": {
                "variable": {
                    "value": "w_prev",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w_prev",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self.lstm_hidden_size, 2 * self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_562": {
                "initial_value": {
                    "value": "zeros",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(e_mask)",
                            "Call"
                        ],
                        [
                            "np.zeros([self.batch_size, self.lstm_hidden_size], dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_563": {
                "initial_value": {
                    "value": "zeros_one_instance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros([1, self.lstm_hidden_size], dtype=np.float32)",
                            "Call"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sigmoid_317": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "tanh_382": {
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_383": {
                "features": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_384": {
                "input": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_385": {
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.tanh(h)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(h)",
                            "Call"
                        ],
                        [
                            "tf.identity(h)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(h)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ],
                        [
                            "tf.case({tf.equal(func_idx, 0): lambda : tf.tanh(h), tf.equal(func_idx, 1): lambda : tf.nn.relu(h), tf.equal(func_idx, 2): lambda : tf.identity(h), tf.equal(func_idx, 3): lambda : tf.sigmoid(h)}, default=lambda : tf.constant(0.0, dtype=tf.float32), exclusive=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_387": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_520": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_538": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_528": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_funcs * rhn_layer_id * self.lstm_hidden_size, 2 * self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_544": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_hidden_size, 2 * self.lstm_hidden_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_527": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(rhn_layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_543": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(rhn_layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/ptb/ptb_enas_controller.py": {
        "tensorflow": {
            "random_uniform_initializer_70": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_165": {
                "variable": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "arc_seq",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(arc_seq, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_168": {
                "variable": {
                    "value": "self.sample_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "sample_log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_169": {
                "variable": {
                    "value": "self.ppl",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(self.sample_log_probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_171": {
                "variable": {
                    "value": "sample_entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "sample_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(sample_entropy, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_172": {
                "variable": {
                    "value": "self.sample_entropy",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sample_entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(sample_entropy, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_178": {
                "variable": {
                    "value": "self.valid_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "child_model.rl_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stop_gradient_179": {
                "variable": {
                    "value": "self.valid_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.valid_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_180": {
                "variable": {
                    "value": "self.valid_ppl",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.valid_loss",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_187": {
                "variable": {
                    "value": "self.sample_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.sample_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_188": {
                "variable": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_sub_189": {
                "variable": {
                    "value": "baseline_update",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.baseline",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "(1 - self.bl_dec) * (self.baseline - self.reward)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Variable_196": {
                "variable": {
                    "value": "self.train_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "train_step",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_149": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multinomial_154": {
                "variable": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_155": {
                "variable": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(func)",
                            "Call"
                        ],
                        [
                            "tf.reshape(func, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_156": {
                "variable": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(func)",
                            "Call"
                        ],
                        [
                            "tf.reshape(func, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_158": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(func)",
                            "Call"
                        ],
                        [
                            "tf.reshape(func, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "embedding_lookup_163": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "func",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(func)",
                            "Call"
                        ],
                        [
                            "tf.reshape(func, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_193": {
                "variable": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "self.reward",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "self.name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(minval=-0.1, maxval=0.1)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_81": {
                "variable": {
                    "value": "self.g_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "g_emb",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_82": {
                "variable": {
                    "value": "self.w_emb",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_funcs, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_85": {
                "variable": {
                    "value": "self.w_soft",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, num_funcs]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_88": {
                "variable": {
                    "value": "self.attn_w_1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_89": {
                "variable": {
                    "value": "self.attn_w_2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "w_2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_90": {
                "variable": {
                    "value": "self.attn_v",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "v",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.lstm_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_116": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.attn_w_2",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_118": {
                "variable": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.attn_w_2)",
                            "Call"
                        ],
                        [
                            "query + tf.concat(all_h_w[:-1], axis=0)",
                            "BinOp"
                        ],
                        [
                            "tf.tanh(query)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_119": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "query",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(next_h[-1], self.attn_w_2)",
                            "Call"
                        ],
                        [
                            "query + tf.concat(all_h_w[:-1], axis=0)",
                            "BinOp"
                        ],
                        [
                            "tf.tanh(query)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "self.attn_v",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_120": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, layer_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "multinomial_129": {
                "variable": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_int32_130": {
                "variable": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip_index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip_index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_131": {
                "variable": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip_index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip_index, [1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_134": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip_index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip_index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "embedding_lookup_141": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "tf.concat(all_h[:-1], axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "ids": {
                    "value": "skip_index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multinomial(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.to_int32(skip_index)",
                            "Call"
                        ],
                        [
                            "tf.reshape(skip_index, [1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_169": {
                "input_tensor": {
                    "value": "self.sample_log_probs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_192": {
                "control_inputs": {
                    "value": "[baseline_update]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_72": {
                "name_or_scope": {
                    "value": "lstm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_80": {
                "name_or_scope": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_84": {
                "name_or_scope": {
                    "value": "softmax",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_87": {
                "name_or_scope": {
                    "value": "attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_105": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_106": {
                "shape": {
                    "value": "[1, self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_113": {
                "a": {
                    "value": "next_h[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.attn_w_1",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_161": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stop_gradient_162": {
                "input": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_prob * tf.exp(-log_prob)",
                            "BinOp"
                        ],
                        [
                            "log_prob * tf.exp(-log_prob)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "trainable_variables_199": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_76": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[2 * self.lstm_size, 4 * self.lstm_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_117": {
                "values": {
                    "value": "all_h_w[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_126": {
                "x": {
                    "value": "layer_id - tf.range(0, layer_id)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_127": {
                "tensor": {
                    "value": "diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(layer_id - tf.range(0, layer_id)) ** 2",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, layer_id]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_138": {
                "x": {
                    "value": "-log_prob",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stop_gradient_139": {
                "input": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_prob * tf.exp(-log_prob)",
                            "BinOp"
                        ],
                        [
                            "log_prob * tf.exp(-log_prob)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_142": {
                "values": {
                    "value": "all_h[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "to_float_143": {
                "x": {
                    "value": "layer_id - skip_index",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_153": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_75": {
                "name_or_scope": {
                    "value": "'layer_{}'.format(layer_id)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_125": {
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(query, self.attn_v)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [1, layer_id])",
                            "Call"
                        ],
                        [
                            "logits / self.temperature",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(next_h[-1], self.w_soft)",
                            "Call"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ],
                        [
                            "self.tanh_constant * tf.tanh(logits)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "software/enas/src/ptb/ptb_ops.py": {
        "tensorflow": {
            "get_variable_16": {
                "variable": {
                    "value": "offset",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "offset",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_19": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "scale",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_22": {
                "variable": {
                    "value": "moving_mean",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_mean",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_25": {
                "variable": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "moving_variance",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.get_shape()[1]",
                            "Subscript"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_15": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'layer_norm'",
                            "Method Argument"
                        ],
                        [
                            "'batch_norm'",
                            "Method Argument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "None if is_training else True",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "moments_30": {
                "variable": {
                    "value": "(mean, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.layers.layer_norm(x, scope=name, reuse=None if is_training else True)",
                            "Call"
                        ],
                        [
                            "scale * (x - moving_mean) / tf.sqrt(epsilon + moving_variance) + offset",
                            "BinOp"
                        ],
                        [
                            "scale * (x - mean) / tf.sqrt(epsilon + variance) + offset",
                            "BinOp"
                        ]
                    ]
                },
                "axes": {
                    "value": "[0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_initializer_18": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_21": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_24": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_27": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "control_dependencies_36": {
                "control_inputs": {
                    "value": "[update_mean, update_variance]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sqrt_39": {
                "x": {
                    "value": "epsilon + moving_variance",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_37": {
                "x": {
                    "value": "epsilon + variance",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "software/enas/src/utils.py": {
        "tensorflow": {
            "gradients_128": {
                "variable": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": []
                },
                "ys": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss + l2_reg * l2_loss",
                            "BinOp"
                        ]
                    ]
                },
                "xs": {
                    "value": "tf_variables",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "global_norm_129": {
                "variable": {
                    "value": "grad_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss, tf_variables)",
                            "Call"
                        ],
                        [
                            "clipped",
                            "variable"
                        ]
                    ]
                }
            },
            "DEFINE_string_14": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "default": {
                    "value": "default_value",
                    "type": "variable",
                    "possible_values": []
                },
                "help": {
                    "value": "doc_string",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "DEFINE_integer_20": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "default": {
                    "value": "default_value",
                    "type": "variable",
                    "possible_values": []
                },
                "help": {
                    "value": "doc_string",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "DEFINE_float_26": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "default": {
                    "value": "default_value",
                    "type": "variable",
                    "possible_values": []
                },
                "help": {
                    "value": "doc_string",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_n_125": {
                "variable": {
                    "value": "l2_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "Variable_167": {
                "variable": {
                    "value": "last_reset",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "last_reset",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_169": {
                "variable": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "lr_T_0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "T_i",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_185": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.greater_equal(T_curr, T_i)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_update",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_no_update",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "exponential_decay_188": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "lr_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "Method Argument"
                        ]
                    ]
                },
                "global_step": {
                    "value": "tf.maximum(train_step - lr_dec_start, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "lr_dec_every",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10000",
                            "Method Argument"
                        ]
                    ]
                },
                "decay_rate": {
                    "value": "lr_dec_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "Method Argument"
                        ]
                    ]
                },
                "staircase": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cond_195": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(train_step, lr_warmup_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : lr_warmup_val",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : learning_rate",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_216": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(lr_init, tf.maximum(train_step - lr_dec_start, 0), lr_dec_every, lr_dec_rate, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, lr_dec_min)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(train_step, lr_warmup_steps), lambda : lr_warmup_val, lambda : learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater_equal(T_curr, T_i), _update, _no_update)",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "0.9",
                    "type": "float",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "use_nesterov": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "SyncReplicasOptimizer_230": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.MomentumOptimizer(learning_rate, 0.9, use_locking=True, use_nesterov=True)",
                            "Call"
                        ],
                        [
                            "tf.train.GradientDescentOptimizer(learning_rate, use_locking=True)",
                            "Call"
                        ],
                        [
                            "tf.train.AdamOptimizer(learning_rate, beta1=0.0, epsilon=0.001, use_locking=True)",
                            "Call"
                        ],
                        [
                            "tf.contrib.opt.MovingAverageOptimizer(opt, average_decay=moving_average)",
                            "Call"
                        ],
                        [
                            "tf.train.SyncReplicasOptimizer(opt, replicas_to_aggregate=num_aggregate, total_num_replicas=num_replicas, use_locking=True)",
                            "Call"
                        ]
                    ]
                },
                "replicas_to_aggregate": {
                    "value": "num_aggregate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "total_num_replicas": {
                    "value": "num_replicas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_136": {
                "variable": {
                    "value": "grad_norms[v.name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(g.values ** 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_138": {
                "variable": {
                    "value": "grad_norms[v.name]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(g ** 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_global_norm_143": {
                "variable": {
                    "value": "(grads, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "t_list": {
                    "value": "grads",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gradients(loss, tf_variables)",
                            "Call"
                        ],
                        [
                            "clipped",
                            "variable"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "grad_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "assign_173": {
                "variable": {
                    "value": "update_last_reset",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "last_reset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(0, dtype=tf.int32, trainable=False, name='last_reset')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "curr_epoch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "train_step // num_train_batches",
                            "BinOp"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "assign_174": {
                "variable": {
                    "value": "update_T_i",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(lr_T_0, dtype=tf.int32, trainable=False, name='T_i')",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "T_i * lr_T_mul",
                    "type": "BinOp",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "maximum_192": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(lr_init, tf.maximum(train_step - lr_dec_start, 0), lr_dec_every, lr_dec_rate, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, lr_dec_min)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(train_step, lr_warmup_steps), lambda : lr_warmup_val, lambda : learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater_equal(T_curr, T_i), _update, _no_update)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "lr_dec_min",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GradientDescentOptimizer_219": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(lr_init, tf.maximum(train_step - lr_dec_start, 0), lr_dec_every, lr_dec_rate, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, lr_dec_min)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(train_step, lr_warmup_steps), lambda : lr_warmup_val, lambda : learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater_equal(T_curr, T_i), _update, _no_update)",
                            "Call"
                        ]
                    ]
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "greater_equal_186": {
                "x": {
                    "value": "T_curr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "curr_epoch - last_reset",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(lr_T_0, dtype=tf.int32, trainable=False, name='T_i')",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_189": {
                "x": {
                    "value": "train_step - lr_dec_start",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_195": {
                "x": {
                    "value": "train_step",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "lr_warmup_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "AdamOptimizer_221": {
                "variable": {
                    "value": "opt",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.exponential_decay(lr_init, tf.maximum(train_step - lr_dec_start, 0), lr_dec_every, lr_dec_rate, staircase=True)",
                            "Call"
                        ],
                        [
                            "tf.maximum(learning_rate, lr_dec_min)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(train_step, lr_warmup_steps), lambda : lr_warmup_val, lambda : learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.greater_equal(T_curr, T_i), _update, _no_update)",
                            "Call"
                        ]
                    ]
                },
                "beta1": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                },
                "use_locking": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_124": {
                "input_tensor": {
                    "value": "var ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_136": {
                "input_tensor": {
                    "value": "g.values ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_138": {
                "input_tensor": {
                    "value": "g ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "control_dependencies_175": {
                "control_inputs": {
                    "value": "[update_last_reset, update_T_i]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_norm_148": {
                "variable": {
                    "value": "c_g",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "g.values",
                    "type": "Attribute",
                    "possible_values": []
                },
                "clip_norm": {
                    "value": "grad_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "IndexedSlices_149": {
                "variable": {
                    "value": "c_g",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "g.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "c_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.clip_by_norm(g.values, grad_bound)",
                            "Call"
                        ],
                        [
                            "tf.IndexedSlices(g.indices, c_g)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_norm(g, grad_bound)",
                            "Call"
                        ]
                    ]
                }
            },
            "clip_by_norm_151": {
                "variable": {
                    "value": "c_g",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grads",
                            "variable"
                        ]
                    ]
                },
                "clip_norm": {
                    "value": "grad_bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_181": {
                "x": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(lr_T_0, dtype=tf.int32, trainable=False, name='T_i')",
                            "Call"
                        ]
                    ]
                }
            },
            "to_float_176": {
                "x": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(lr_T_0, dtype=tf.int32, trainable=False, name='T_i')",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_182": {
                "x": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(T_curr) / tf.to_float(T_i) * 3.1415926",
                            "BinOp"
                        ],
                        [
                            "tf.to_float(T_curr) / tf.to_float(T_i) * 3.1415926",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cos_177": {
                "x": {
                    "value": "rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(T_curr) / tf.to_float(T_i) * 3.1415926",
                            "BinOp"
                        ],
                        [
                            "tf.to_float(T_curr) / tf.to_float(T_i) * 3.1415926",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "bayesian_optimization/summarize.py": {
        "torch": {}
    },
    "models.py": {
        "torch": {
            "GRU_34": {
                "variable": {
                    "value": "self.grue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.xs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_35": {
                "variable": {
                    "value": "self.fc1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_36": {
                "variable": {
                    "value": "self.fc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GRU_39": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_40": {
                "variable": {
                    "value": "self.fc3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sequential_41": {
                "variable": {
                    "value": "self.add_vertex",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_46": {
                "variable": {
                    "value": "self.add_edges",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ReLU_62": {
                "variable": {
                    "value": "self.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sigmoid_63": {
                "variable": {
                    "value": "self.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Tanh_64": {
                "variable": {
                    "value": "self.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "max_143": {
                "variable": {
                    "value": "(_, true_types)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "G_true[:, :, :self.nvt]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "randn_199": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "self.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_210": {
                "variable": {
                    "value": "self.encoder_nn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear((max_n - 1) * self.xs, 2 * (max_n - 1) * self.xs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_215": {
                "variable": {
                    "value": "self.decoder_nn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs, 2 * hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "GRU_245": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.xs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "self.num_layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRU_246": {
                "variable": {
                    "value": "self.grud_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "self.num_layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_248": {
                "variable": {
                    "value": "self.add_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_290": {
                "variable": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_291": {
                "variable": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_305": {
                "variable": {
                    "value": "Input_graph_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_zeros(len(z), self.xs).unsqueeze(1), Input_graph_level]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_317": {
                "variable": {
                    "value": "Input_edge_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_zeros(len(z), self.max_n - 1).unsqueeze(2), Input_edge_level]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_326": {
                "variable": {
                    "value": "(_, true_types)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "G_true[:, :, :self.nvt]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "GRU_345": {
                "variable": {
                    "value": "self.grue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.xs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRU_346": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.xs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "self.num_layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRU_347": {
                "variable": {
                    "value": "self.grud_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "num_layers": {
                    "value": "self.num_layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "self.bidir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_349": {
                "variable": {
                    "value": "self.add_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_378": {
                "variable": {
                    "value": "pad",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_380": {
                "variable": {
                    "value": "input_features",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[pad, G[:, :self.nvt]]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_381": {
                "variable": {
                    "value": "pad2",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "self.max_n - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_382": {
                "variable": {
                    "value": "adj",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[pad2, G[:, self.nvt:].permute(1, 0)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_383": {
                "variable": {
                    "value": "pad3",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "self.max_n",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_384": {
                "variable": {
                    "value": "adj",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[adj, pad3]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_450": {
                "variable": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_451": {
                "variable": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_466": {
                "variable": {
                    "value": "Input_graph_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_zeros(len(z), self.xs).unsqueeze(1), Input_graph_level]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_478": {
                "variable": {
                    "value": "Input_edge_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_zeros(len(z), self.max_n).unsqueeze(2), Input_edge_level]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "max_487": {
                "variable": {
                    "value": "(_, true_types)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "G_true[:, :, :self.nvt]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "GRUCell_556": {
                "variable": {
                    "value": "self.grue_forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GRUCell_557": {
                "variable": {
                    "value": "self.grue_backward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_558": {
                "variable": {
                    "value": "self.fc1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_559": {
                "variable": {
                    "value": "self.fc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GRUCell_562": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_size": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_563": {
                "variable": {
                    "value": "self.fc3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sequential_564": {
                "variable": {
                    "value": "self.add_vertex",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs, hs * 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_569": {
                "variable": {
                    "value": "self.add_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs * 2, hs * 4)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_576": {
                "variable": {
                    "value": "self.gate_forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_580": {
                "variable": {
                    "value": "self.gate_backward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_584": {
                "variable": {
                    "value": "self.mapper_forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, hs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_587": {
                "variable": {
                    "value": "self.mapper_backward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, hs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ReLU_601": {
                "variable": {
                    "value": "self.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sigmoid_602": {
                "variable": {
                    "value": "self.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Tanh_603": {
                "variable": {
                    "value": "self.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LogSoftmax_604": {
                "variable": {
                    "value": "self.logsoftmax1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_701": {
                "variable": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "propagator(X, H)",
                            "Call"
                        ],
                        [
                            "self._propagate_to(G, v, propagator, H0, reverse=reverse)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hv, 0)",
                            "Call"
                        ],
                        [
                            "self.gconv[lv](H_nei.sum(1))",
                            "Call"
                        ],
                        [
                            "propagator(X, H)",
                            "Call"
                        ],
                        [
                            "self.finit(torch.cat([X, Hg], -1))",
                            "Call"
                        ],
                        [
                            "self._get_vertex_state(G, v)",
                            "Call"
                        ],
                        [
                            "propagator[t](Av, Hv)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hv, 0)",
                            "Call"
                        ],
                        [
                            "torch.cat([self._get_vertex_state(G_tmp, v).unsqueeze(1) for v in range(idx)], 1)",
                            "Call"
                        ],
                        [
                            "torch.cat([self._get_vertex_state(G, v).unsqueeze(1) for v in range(v_true)], 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_715": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hn.view(Hn.shape[1], -1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self.relu(self.encoder_nn(G.view(len(G), -1)))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, 0, 1, init=True)",
                            "Call"
                        ],
                        [
                            "H",
                            "variable"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate, self.mapper).sum(1)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate_init, self.mapper_init).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G_tmp)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_873": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "self.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_887": {
                "variable": {
                    "value": "self.gconv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_929": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hn.view(Hn.shape[1], -1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self.relu(self.encoder_nn(G.view(len(G), -1)))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, 0, 1, init=True)",
                            "Call"
                        ],
                        [
                            "H",
                            "variable"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate, self.mapper).sum(1)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate_init, self.mapper_init).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G_tmp)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_929": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_951": {
                "variable": {
                    "value": "H_nei",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "H_nei",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[self._get_feature(g, v, lv) / (g.degree(v) + 1)] + [self._get_feature(g, x, lv) / math.sqrt((g.degree(x) + 1) * (g.degree(v) + 1)) for x in g.neighbors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[self._get_feature(g, v, lv) / (g.indegree(v) + 1)] + [self._get_feature(g, x, lv) / math.sqrt((g.outdegree(x) + 1) * (g.indegree(v) + 1)) for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_nei + [self._get_zeros(max_n_nei - len(h_nei), h_nei[0].shape[1])], 0).unsqueeze(0) for h_nei in H_nei]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_nei, 0)",
                            "Call"
                        ],
                        [
                            "[[g.vs[x]['H_forward'] for x in g.predecessors(v)] + [g.vs[x]['H_forward'] for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[g.vs[x]['H_forward'] for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_nei + [self._get_zeros(max_n_nei - len(h_nei), self.hs)], 0).unsqueeze(0) for h_nei in H_nei]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_nei, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_982": {
                "variable": {
                    "value": "self.mapper_forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.nvt, hs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_985": {
                "variable": {
                    "value": "self.mapper_backward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.nvt, hs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_988": {
                "variable": {
                    "value": "self.gate_forward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.nvt, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_992": {
                "variable": {
                    "value": "self.gate_backward",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.nvt, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_996": {
                "variable": {
                    "value": "self.add_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs * 3, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_1024": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hn.view(Hn.shape[1], -1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self.relu(self.encoder_nn(G.view(len(G), -1)))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, 0, 1, init=True)",
                            "Call"
                        ],
                        [
                            "H",
                            "variable"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate, self.mapper).sum(1)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate_init, self.mapper_init).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G_tmp)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_1024": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "GRU_1095": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Sequential_1096": {
                "variable": {
                    "value": "self.add_vertex",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1101": {
                "variable": {
                    "value": "self.add_edges",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ModuleList_1196": {
                "variable": {
                    "value": "self.grue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1199": {
                "variable": {
                    "value": "self.fe",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hs * 2 + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_1200": {
                "variable": {
                    "value": "self.fc1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_1201": {
                "variable": {
                    "value": "self.fc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_1204": {
                "variable": {
                    "value": "self.finit",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "nvt + self.gs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ModuleList_1207": {
                "variable": {
                    "value": "self.grud",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1210": {
                "variable": {
                    "value": "self.fc3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "nz",
                    "type": "variable",
                    "possible_values": [
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "112",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ],
                        [
                            "56",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_1211": {
                "variable": {
                    "value": "self.add_vertex",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.gs, nvt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1214": {
                "variable": {
                    "value": "self.add_edge",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.gs + hs, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1217": {
                "variable": {
                    "value": "self.select_node",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs * 2, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1222": {
                "variable": {
                    "value": "self.gate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, self.gs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1226": {
                "variable": {
                    "value": "self.mapper",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, self.gs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1229": {
                "variable": {
                    "value": "self.gate_init",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, self.gs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_1233": {
                "variable": {
                    "value": "self.mapper_init",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.vs, self.gs, bias=False)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ReLU_1238": {
                "variable": {
                    "value": "self.relu",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sigmoid_1239": {
                "variable": {
                    "value": "self.sigmoid",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Tanh_1240": {
                "variable": {
                    "value": "self.tanh",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "LogSoftmax_1241": {
                "variable": {
                    "value": "self.logsoftmax1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_1309": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "len(G)",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "max_n_nei",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max([len(x) for x in H_nei])",
                            "Call"
                        ],
                        [
                            "max([len(x) for x in H_nei])",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_1315": {
                "variable": {
                    "value": "H_nei",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "H_nei",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[self._get_feature(g, v, lv) / (g.degree(v) + 1)] + [self._get_feature(g, x, lv) / math.sqrt((g.degree(x) + 1) * (g.degree(v) + 1)) for x in g.neighbors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[self._get_feature(g, v, lv) / (g.indegree(v) + 1)] + [self._get_feature(g, x, lv) / math.sqrt((g.outdegree(x) + 1) * (g.indegree(v) + 1)) for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_nei + [self._get_zeros(max_n_nei - len(h_nei), h_nei[0].shape[1])], 0).unsqueeze(0) for h_nei in H_nei]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_nei, 0)",
                            "Call"
                        ],
                        [
                            "[[g.vs[x]['H_forward'] for x in g.predecessors(v)] + [g.vs[x]['H_forward'] for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[g.vs[x]['H_forward'] for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_nei + [self._get_zeros(max_n_nei - len(h_nei), self.hs)], 0).unsqueeze(0) for h_nei in H_nei]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_nei, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1318": {
                "variable": {
                    "value": "E_nei",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "E_nei",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[1 for x in g.predecessors(v)] + [0 for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[1 for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.FloatTensor(e_nei + [0] * (max_n_nei - len(e_nei))).unsqueeze(0).unsqueeze(2).to(self.get_device()) for e_nei in E_nei]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(E_nei, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1369": {
                "variable": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "propagator(X, H)",
                            "Call"
                        ],
                        [
                            "self._propagate_to(G, v, propagator, H0, reverse=reverse)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hv, 0)",
                            "Call"
                        ],
                        [
                            "self.gconv[lv](H_nei.sum(1))",
                            "Call"
                        ],
                        [
                            "propagator(X, H)",
                            "Call"
                        ],
                        [
                            "self.finit(torch.cat([X, Hg], -1))",
                            "Call"
                        ],
                        [
                            "self._get_vertex_state(G, v)",
                            "Call"
                        ],
                        [
                            "propagator[t](Av, Hv)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hv, 0)",
                            "Call"
                        ],
                        [
                            "torch.cat([self._get_vertex_state(G_tmp, v).unsqueeze(1) for v in range(idx)], 1)",
                            "Call"
                        ],
                        [
                            "torch.cat([self._get_vertex_state(G, v).unsqueeze(1) for v in range(v_true)], 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1386": {
                "variable": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Hg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Hn.view(Hn.shape[1], -1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self.relu(self.encoder_nn(G.view(len(G), -1)))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, decode=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0).sum(1)",
                            "Call"
                        ],
                        [
                            "self.hg_unify(Hg)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, start=1, end_offset=1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G, 0, 1, init=True)",
                            "Call"
                        ],
                        [
                            "H",
                            "variable"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Hg, 0)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate, self.mapper).sum(1)",
                            "Call"
                        ],
                        [
                            "self._gated(Hg, self.gate_init, self.mapper_init).sum(1)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G_tmp)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ],
                        [
                            "self._get_graph_state(G)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_1552": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "self.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_54": {
                "variable": {
                    "value": "self.hg_unify",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs * 2, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_57": {
                "variable": {
                    "value": "self.hv_unify",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.hs * 2, self.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_72": {
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsqueeze_81": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "t_81": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_82": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(idx), length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "unsqueeze_84": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_85": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(1, length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cat_106": {
                "tensors": {
                    "value": "G_new",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cross_entropy_144": {
                "input": {
                    "value": "type_scores.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "true_types",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ],
                        [
                            "torch.LongTensor([[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for v_true in range(1, self.max_n)] for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_146": {
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "target": {
                    "value": "true_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.FloatTensor([np.pad(np.array(g_true.get_adjacency().data).transpose()[1:, :-1], ((0, self.max_n - g_true.vcount()), (0, self.max_n - g_true.vcount())), mode='constant', constant_values=(0, 0)) for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_156": {
                "variable": {
                    "value": "type_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_266": {
                "variable": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(output_graph_level)",
                            "Call"
                        ],
                        [
                            "self._one_hot(new_type.reshape(-1).tolist(), self.nvt).unsqueeze(1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(output_graph_level)",
                            "Call"
                        ],
                        [
                            "self._one_hot(new_type.reshape(-1).tolist(), self.nvt).unsqueeze(1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_266": {
                "variable": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_267": {
                "variable": {
                    "value": "new_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(type_score, 2).squeeze(1)",
                            "Call"
                        ],
                        [
                            "F.softmax(type_score, 2).squeeze(1)",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_286": {
                "variable": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_288": {
                "variable": {
                    "value": "input_graph_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[type_score, edge_score]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cross_entropy_327": {
                "input": {
                    "value": "type_scores.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "true_types",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ],
                        [
                            "torch.LongTensor([[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for v_true in range(1, self.max_n)] for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_329": {
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "target": {
                    "value": "true_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.FloatTensor([np.pad(np.array(g_true.get_adjacency().data).transpose()[1:, :-1], ((0, self.max_n - g_true.vcount()), (0, self.max_n - g_true.vcount())), mode='constant', constant_values=(0, 0)) for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cat_390": {
                "tensors": {
                    "value": "[feat, adj]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_390": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_412": {
                "tensors": {
                    "value": "G_new",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_426": {
                "variable": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(output_graph_level)",
                            "Call"
                        ],
                        [
                            "self._one_hot(new_type.reshape(-1).tolist(), self.nvt).unsqueeze(1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(output_graph_level)",
                            "Call"
                        ],
                        [
                            "self._one_hot(new_type.reshape(-1).tolist(), self.nvt).unsqueeze(1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_426": {
                "variable": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "multinomial_427": {
                "variable": {
                    "value": "new_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(type_score, 2).squeeze(1)",
                            "Call"
                        ],
                        [
                            "F.softmax(type_score, 2).squeeze(1)",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_446": {
                "variable": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_448": {
                "variable": {
                    "value": "input_graph_level",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[type_score, edge_score]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cross_entropy_488": {
                "input": {
                    "value": "type_scores.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "true_types",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ],
                        [
                            "torch.LongTensor([[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for v_true in range(1, self.max_n)] for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_490": {
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "target": {
                    "value": "true_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.FloatTensor([np.pad(np.array(g_true.get_adjacency().data).transpose()[1:, :-1], ((0, self.max_n - g_true.vcount()), (0, self.max_n - g_true.vcount())), mode='constant', constant_values=(0, 0)) for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_500": {
                "variable": {
                    "value": "type_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_593": {
                "variable": {
                    "value": "self.hv_unify",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(hs * 2, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_596": {
                "variable": {
                    "value": "self.hg_unify",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(self.gs * 2, self.gs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_612": {
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsqueeze_621": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "t_621": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_622": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(idx), length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "unsqueeze_624": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_625": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(1, length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cat_847": {
                "variable": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "edge_scores[::-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_849": {
                "variable": {
                    "value": "ground_truth",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "zeros_913": {
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_921": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g.vs[i]['H_forward'] for i in range(start, g.vcount() - end_offset)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_921": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1012": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g.vs[i]['H_forward'] for i in range(start, g.vcount() - end_offset)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_1012": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cross_entropy_1123": {
                "input": {
                    "value": "type_scores.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "true_types",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ],
                        [
                            "torch.LongTensor([[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for v_true in range(1, self.max_n)] for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[g_true.vs[v_true]['type'] if v_true < g_true.vcount() else self.START_TYPE for g_true in G_true]",
                            "ListComp"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_1128": {
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "target": {
                    "value": "true_edges",
                    "type": "variable",
                    "possible_values": [
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "G_true[:, :, self.nvt:]",
                            "Subscript"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.FloatTensor([np.pad(np.array(g_true.get_adjacency().data).transpose()[1:, :-1], ((0, self.max_n - g_true.vcount()), (0, self.max_n - g_true.vcount())), mode='constant', constant_values=(0, 0)) for g_true in G_true]).to(self.get_device())",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_1140": {
                "variable": {
                    "value": "type_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_1249": {
                "*size": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(adj)",
                            "Call"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ],
                        [
                            "1",
                            "Method Argument"
                        ]
                    ]
                },
                "out": {
                    "value": "length",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_1259": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(len(idx), length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "unsqueeze_1261": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_1262": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(1, length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cat_1378": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.vs[g.vcount() - 1]['H_forward']",
                            "Subscript"
                        ],
                        [
                            "torch.cat([hg, hg_b], 1)",
                            "Call"
                        ],
                        [
                            "torch.cat([g.vs[i]['H_forward'] for i in range(start, g.vcount() - end_offset)], 0).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "torch.cat([hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())], 1)",
                            "Call"
                        ],
                        [
                            "torch.cat([g.vs[i]['H_forward'] for i in range(start, g.vcount() - end_offset)], 0).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "torch.cat([hg, hg_b], 2)",
                            "Call"
                        ],
                        [
                            "torch.cat([hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())], 1)",
                            "Call"
                        ],
                        [
                            "[g.vs[i]['H_forward'] for i in range(start, g.vcount() - end_offset)]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(hg, 0)",
                            "Call"
                        ],
                        [
                            "hg.unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "torch.cat([hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())], 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_42": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_43": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_44": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_47": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_49": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.max_n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_97": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "self.max_n - 1 - g.shape[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "g.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_100": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_102": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "g.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.xs - g.shape[2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_103": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_147": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_211": {
                "in_features": {
                    "value": "(max_n - 1) * self.xs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2 * (max_n - 1) * self.xs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ReLU_212": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_213": {
                "in_features": {
                    "value": "2 * (max_n - 1) * self.xs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_216": {
                "in_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "2 * hs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ReLU_217": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_218": {
                "in_features": {
                    "value": "2 * hs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "(max_n - 1) * self.xs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_249": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_251": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_330": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_350": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_351": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_352": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_404": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "self.max_n - g.shape[1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "g.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_406": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_408": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "g.shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.xs - g.shape[2]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_409": {
                "variable": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_491": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_565": {
                "in_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ReLU_566": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_567": {
                "in_features": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Linear_570": {
                "in_features": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs * 4",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ReLU_571": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_572": {
                "in_features": {
                    "value": "hs * 4",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_577": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sigmoid_578": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_581": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sigmoid_582": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_585": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_588": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_668": {
                "variable": {
                    "value": "H_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "H_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[g.vs[x][H_name] for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[g.vs[x][H_name] for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[torch.cat([x[i], y[i:i + 1]], 1) for i in range(len(x))] for (x, y) in zip(H_pred, vids)]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_pred + [self._get_zeros(max_n_pred - len(h_pred), self.vs)], 0).unsqueeze(0) for h_pred in H_pred]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_pred, 0)",
                            "Call"
                        ],
                        [
                            "[[self._one_hot(g.vs[x]['type'], self.nvt) for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[self._one_hot(g.vs[x]['type'], self.nvt) for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_pred + [self._get_zero_x(max_n_pred - len(h_pred))], 0).unsqueeze(0) for h_pred in H_pred]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_pred, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_713": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[hg, hg_b]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_859": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Sequential_889": {
                "*args": {
                    "value": "nn.Linear(nvt, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_924": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_949": {
                "tensors": {
                    "value": "h_nei + [self._get_zeros(max_n_nei - len(h_nei), h_nei[0].shape[1])]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_949": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_983": {
                "in_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_986": {
                "in_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_989": {
                "in_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sigmoid_990": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_993": {
                "in_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Sigmoid_994": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_997": {
                "in_features": {
                    "value": "hs * 3",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_998": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_999": {
                "in_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1015": {
                "variable": {
                    "value": "hg_b",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[g.vs[i]['H_backward'] for i in range(start, g.vcount() - end_offset)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_1015": {
                "variable": {
                    "value": "hg_b",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1017": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[hg, hg_b]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1019": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1061": {
                "variable": {
                    "value": "H_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "H_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[[g.vs[x][H_name] for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[g.vs[x][H_name] for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[torch.cat([x[i], y[i:i + 1]], 1) for i in range(len(x))] for (x, y) in zip(H_pred, vids)]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_pred + [self._get_zeros(max_n_pred - len(h_pred), self.vs)], 0).unsqueeze(0) for h_pred in H_pred]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_pred, 0)",
                            "Call"
                        ],
                        [
                            "[[self._one_hot(g.vs[x]['type'], self.nvt) for x in g.successors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[[self._one_hot(g.vs[x]['type'], self.nvt) for x in g.predecessors(v)] for g in G]",
                            "ListComp"
                        ],
                        [
                            "[torch.cat(h_pred + [self._get_zero_x(max_n_pred - len(h_pred))], 0).unsqueeze(0) for h_pred in H_pred]",
                            "ListComp"
                        ],
                        [
                            "torch.cat(H_pred, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_1097": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_1098": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1099": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.nvt",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_1102": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReLU_1103": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1104": {
                "in_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.max_n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sum_1129": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_1212": {
                "in_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Linear_1215": {
                "in_features": {
                    "value": "self.gs + hs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_1218": {
                "in_features": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_1223": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sigmoid_1224": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1227": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Linear_1230": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sigmoid_1231": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_1234": {
                "in_features": {
                    "value": "self.vs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cat_1284": {
                "tensors": {
                    "value": "[X, Hg]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_1313": {
                "tensors": {
                    "value": "h_nei + [self._get_zeros(max_n_nei - len(h_nei), self.hs)]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_1313": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_1316": {
                "input": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1320": {
                "tensors": {
                    "value": "[H_nei, E_nei, Hv_expand]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_1381": {
                "variable": {
                    "value": "hg",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[hg, torch.zeros(1, max_n_nodes - g.vcount(), hg.shape[2]).to(self.get_device())]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1453": {
                "variable": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_vertex_state(G_tmp, v).unsqueeze(1) for v in range(idx)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensor_1519": {
                "variable": {
                    "value": "add_truth",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "add_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1.0 if true_edges[i] else 0.0 for i in graph_idx]",
                            "ListComp"
                        ],
                        [
                            "torch.tensor(add_truth).to(self.get_device())",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_1522": {
                "variable": {
                    "value": "Hv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self._get_vertex_state(G, v).unsqueeze(1) for v in range(v_true)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sum_1538": {
                "input": {
                    "value": "1 + logvar - mu.pow(2) - logvar.exp()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Linear_55": {
                "in_features": {
                    "value": "self.hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_58": {
                "in_features": {
                    "value": "self.hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "randn_like_121": {
                "input": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_509": {
                "variable": {
                    "value": "new_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores[gi][vj]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "Linear_594": {
                "in_features": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Linear_597": {
                "in_features": {
                    "value": "self.gs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "randn_like_737": {
                "input": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_745": {
                "tensors": {
                    "value": "[Hvi, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_765": {
                "variable": {
                    "value": "type_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_769": {
                "variable": {
                    "value": "new_types",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                }
            },
            "rand_like_783": {
                "variable": {
                    "value": "random_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ei_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._get_edge_score(Hvi, H, H0)",
                            "Call"
                        ],
                        [
                            "self._get_edge_score(Hvi, H, H0)",
                            "Call"
                        ]
                    ]
                }
            },
            "binary_cross_entropy_855": {
                "input": {
                    "value": "edge_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edges(H_out))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(scores[:, :, self.nvt:])",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n - 1, self.max_n - 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(edge_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(Output_edge_level))",
                            "Call"
                        ],
                        [
                            "edge_scores.reshape(-1, self.max_n, self.max_n)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_scores[::-1], 1)",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edges(h_out))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "target": {
                    "value": "ground_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.zeros_like(edge_scores)",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Linear_890": {
                "in_features": {
                    "value": "nvt",
                    "type": "variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_891": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_896": {
                "*args": {
                    "value": "nn.Linear(hs, hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_1085": {
                "tensors": {
                    "value": "[Hvi, H, H0]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "GRUCell_1198": {
                "input_size": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GRUCell_1209": {
                "input_size": {
                    "value": "hs * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_1354": {
                "*size": {
                    "value": "len(G)",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "self.gs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "randn_like_1398": {
                "input": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ],
                        [
                            "logvar.mul(0.5).exp_()",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_1422": {
                "variable": {
                    "value": "type_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_1426": {
                "variable": {
                    "value": "new_types",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.add_vertex(H_out)",
                            "Call"
                        ],
                        [
                            "scores[:, :, :self.nvt]",
                            "Subscript"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "torch.cat(type_scores, 1)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Output_graph_level)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(h_out)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ],
                        [
                            "self.add_vertex(Hg)",
                            "Call"
                        ]
                    ]
                }
            },
            "rand_like_1445": {
                "variable": {
                    "value": "random_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "add_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sigmoid(self.add_edge(torch.cat([Hg, H], 1)))",
                            "Call"
                        ],
                        [
                            "self.sigmoid(self.add_edge(torch.cat([Hg, H], 1)))[graph_idx]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "softmax_1457": {
                "variable": {
                    "value": "edge_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_1461": {
                "variable": {
                    "value": "new_edge",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "edge_score",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(edge_score, 2)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ],
                        [
                            "self.select_node(torch.cat([Hv, H], -1)).squeeze(-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_168": {
                "variable": {
                    "value": "new_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores[gi][vj - 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_658": {
                "tensors": {
                    "value": "[x[i], y[i:i + 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_665": {
                "tensors": {
                    "value": "h_pred + [self._get_zeros(max_n_pred - len(h_pred), self.vs)]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_665": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_897": {
                "in_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "hs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "1002",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ],
                        [
                            "501",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_898": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_1058": {
                "tensors": {
                    "value": "h_pred + [self._get_zero_x(max_n_pred - len(h_pred))]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_1058": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_1152": {
                "variable": {
                    "value": "new_type",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "type_scores[gi][vi - 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "binary_cross_entropy_1520": {
                "input": {
                    "value": "add_score.squeeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "add_truth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1.0 if true_edges[i] else 0.0 for i in graph_idx]",
                            "ListComp"
                        ],
                        [
                            "torch.tensor(add_truth).to(self.get_device())",
                            "Call"
                        ]
                    ]
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_925": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "max_n_nodes - g.vcount()",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "hg.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_1020": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "max_n_nodes - g.vcount()",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "hg.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_1382": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "max_n_nodes - g.vcount()",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "hg.shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cat_1443": {
                "tensors": {
                    "value": "[Hg, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1455": {
                "tensors": {
                    "value": "[Hv, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_1517": {
                "tensors": {
                    "value": "[Hg, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_1524": {
                "tensors": {
                    "value": "[Hv, H]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "train.py": {
        "torch": {
            "Adam_174": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "args.lr",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ReduceLROnPlateau_175": {
                "variable": {
                    "value": "scheduler",
                    "type": "variable",
                    "possible_values": []
                },
                "optimizer": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optim.Adam(model.parameters(), lr=args.lr)",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "min",
                    "type": "str",
                    "possible_values": []
                },
                "factor": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "patience": {
                    "value": "10",
                    "type": "int",
                    "possible_values": []
                },
                "verbose": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "manual_seed_85": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_88": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "device_90": {
                "variable": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Sequential_166": {
                "variable": {
                    "value": "predictor",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(args.nz, args.hs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "MSELoss_172": {
                "variable": {
                    "value": "model.mseloss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "sum",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cat_519": {
                "variable": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_557": {
                "variable": {
                    "value": "norm0",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z0",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_like_558": {
                "variable": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z0",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "acos_568": {
                "variable": {
                    "value": "omega",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.dot(z0.flatten(), z1.flatten())",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_575": {
                "variable": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_631": {
                "variable": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_available_84": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "manual_seed_87": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_453": {
                "variable": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "Z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(Z, 0)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Linear_167": {
                "in_features": {
                    "value": "args.nz",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "args.hs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tanh_168": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_169": {
                "in_features": {
                    "value": "args.hs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "randn_354": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "cnt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "int"
                        ],
                        [
                            "cnt + 1",
                            "BinOp"
                        ],
                        [
                            "0",
                            "int"
                        ],
                        [
                            "0",
                            "int"
                        ]
                    ]
                },
                "out": {
                    "value": "model.nz",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dot_568": {
                "input": {
                    "value": "z0.flatten()",
                    "type": "Call",
                    "possible_values": []
                },
                "other": {
                    "value": "z1.flatten()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "save_710": {
                "obj": {
                    "value": "model.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "model_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.res_dir, 'model_checkpoint{}.pth'.format(epoch))",
                            "Call"
                        ]
                    ]
                }
            },
            "save_711": {
                "obj": {
                    "value": "optimizer.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "optimizer_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.res_dir, 'optimizer_checkpoint{}.pth'.format(epoch))",
                            "Call"
                        ]
                    ]
                }
            },
            "save_712": {
                "obj": {
                    "value": "scheduler.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "scheduler_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(args.res_dir, 'scheduler_checkpoint{}.pth'.format(epoch))",
                            "Call"
                        ]
                    ]
                }
            },
            "unsqueeze_306": {
                "variable": {
                    "value": "y_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_513": {
                "input": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.ones_like(z0)",
                            "Call"
                        ],
                        [
                            "z1 / torch.norm(z1) * norm0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "norm_514": {
                "input": {
                    "value": "z0 - z1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "norm_564": {
                "input": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.ones_like(z0)",
                            "Call"
                        ],
                        [
                            "z1 / torch.norm(z1) * norm0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "norm_566": {
                "input": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.ones_like(z0)",
                            "Call"
                        ],
                        [
                            "z1 / torch.norm(z1) * norm0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "norm_567": {
                "input": {
                    "value": "z0 - z1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "device_count_180": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "unsqueeze_235": {
                "variable": {
                    "value": "y_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_447": {
                "input": {
                    "value": "z1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.ones_like(z0)",
                            "Call"
                        ],
                        [
                            "z1 / torch.norm(z1) * norm0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "norm_448": {
                "input": {
                    "value": "z0 - z1",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "util.py": {
        "torch": {
            "load_39": {
                "variable": {
                    "value": "pretrained_dict",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "state_name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unsqueeze_97": {
                "variable": {
                    "value": "idx",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_98": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "(1, length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_122": {
                "variable": {
                    "value": "edge_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "n + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_247": {
                "variable": {
                    "value": "edge_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "n + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_235": {
                "variable": {
                    "value": "edge_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "n + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_113": {
                "variable": {
                    "value": "edge_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "n + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_115": {
                "variable": {
                    "value": "edge_feature",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[torch.FloatTensor(node[1:]).unsqueeze(0), torch.zeros(1, n + 1 - i)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_124": {
                "tensors": {
                    "value": "[type_feature, edge_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_125": {
                "tensors": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "igraph.Graph(directed=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "igraph.Graph(directed=True)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_125": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_251": {
                "tensors": {
                    "value": "[type_feature, edge_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_252": {
                "tensors": {
                    "value": "g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "igraph.Graph(directed=True)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "igraph.Graph(directed=True)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_252": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_118": {
                "tensors": {
                    "value": "[type_feature, edge_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cat_243": {
                "tensors": {
                    "value": "[type_feature, edge_feature]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "unsqueeze_115": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_116": {
                "*size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "out": {
                    "value": "n + 1 - i",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    }
}