{
    "src/mauve_metrics.py": {
        "sklearn": {
            "PCA_121": {
                "variable": {
                    "value": "pca",
                    "type": "variable",
                    "possible_values": []
                },
                "n_components": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "whiten": {
                    "value": "whiten",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "random_state": {
                    "value": "seed + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "normalize_120": {
                "variable": {
                    "value": "data1",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "data1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.vstack([q, p])",
                            "Call"
                        ],
                        [
                            "normalize(data1, norm=norm, axis=1)",
                            "Call"
                        ],
                        [
                            "pca.transform(data1)[:, :idx + 1]",
                            "Subscript"
                        ],
                        [
                            "data1.astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "norm": {
                    "value": "norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'none'",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "src/metrics.py": {
        "sklearn": {
            "LinearRegression_193": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        },
        "torch": {
            "zeros_like_39": {
                "variable": {
                    "value": "p_true",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "torch.exp(logp)",
                            "Call"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_49": {
                "variable": {
                    "value": "logp",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "torch.exp(logp)",
                            "Call"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "arange_52": {
                "variable": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "from_numpy_112": {
                "variable": {
                    "value": "eppl_eps_lst",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.asarray(eppl_eps_lst)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_121": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.log(p)",
                            "Call"
                        ],
                        [
                            "src.model_utils.get_tokenwise_log_probs_seq(model, sen, temperature=temperature, top_k=top_k, top_p=top_p)",
                            "Call"
                        ],
                        [
                            "src.model_utils.get_log_probs_of_ds(model, ds_tokens)",
                            "Call"
                        ],
                        [
                            "logp",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "exp_170": {
                "input": {
                    "value": "-logp.sum() / num_tokens",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "where_55": {
                "condition": {
                    "value": "p_true > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "p_true * (logp_true - torch.log1p(p_true))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "torch.zeros_like(p_true)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log1p_59": {
                "input": {
                    "value": "p[idxs, labels]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "arange_40": {
                "start": {
                    "value": "n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_57": {
                "input": {
                    "value": "p_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.zeros_like(p)",
                            "Call"
                        ],
                        [
                            "p[idxs, labels]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "arange_67": {
                "start": {
                    "value": "n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_68": {
                "input": {
                    "value": "gold_probs + eps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "arange_72": {
                "start": {
                    "value": "n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "arange_22": {
                "start": {
                    "value": "n - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_31": {
                "input": {
                    "value": "p[idxs] / q[idxs]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_73": {
                "input": {
                    "value": "gold_probs[None, :] + eps_lst[:, None]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_74": {
                "input": {
                    "value": "1 + eps_lst[:, None] * vocab_size",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "norm_22": {
                "input": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "p[0, :-1, :]",
                            "Subscript"
                        ],
                        [
                            "torch.exp(logp)",
                            "Call"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ],
                        [
                            "p",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log1p_56": {
                "input": {
                    "value": "p_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.zeros_like(p)",
                            "Call"
                        ],
                        [
                            "p[idxs, labels]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "library/DRMM.py": {
        "tensorflow": {
            "reshape_94": {
                "variable": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "self.interleavePatches.inputs[0].tensor.shape[2].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reduce_sum_100": {
                "variable": {
                    "value": "averaged",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_113": {
                "variable": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "self.interleavePatches.inputs[0].tensor.shape[2].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "softmax_114": {
                "variable": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_127": {
                "variable": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "self.interleavePatches.inputs[0].tensor.shape[2].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "log_softmax_128": {
                "variable": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_133": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_136": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "placeholder_213": {
                "variable": {
                    "value": "inputTensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_data",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_214": {
                "variable": {
                    "value": "maskTensor",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_mask",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_671": {
                "variable": {
                    "value": "A_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "A * A",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_672": {
                "variable": {
                    "value": "B_d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.reduce_sum(B * B, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, tf.shape(B)[0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_678": {
                "variable": {
                    "value": "sqMask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(samples)",
                            "Call"
                        ],
                        [
                            "mask / sd",
                            "BinOp"
                        ],
                        [
                            "inputs[inputIdx].mask",
                            "Attribute"
                        ],
                        [
                            "stopGradient(mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, [-1, shape1, shape2, stream.mask.shape[1].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_680": {
                "variable": {
                    "value": "A_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mA * mA",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_681": {
                "variable": {
                    "value": "B_d",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "sqMask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.square(mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "B * B",
                    "type": "BinOp",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_like_1329": {
                "variable": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_like_1337": {
                "variable": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "set_verbosity_33": {
                "level": {
                    "value": "tf.compat.v1.logging.ERROR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_69": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_80": {
                "x": {
                    "value": "discretePdfSmooth(x, nCategories, c)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_96": {
                "tensor": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_115": {
                "tensor": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_129": {
                "tensor": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_138": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_230": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_prior_mean",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_231": {
                "variable": {
                    "value": "sd",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_prior_sd",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_232": {
                "variable": {
                    "value": "weight",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "in_prior_weight",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_237": {
                "variable": {
                    "value": "minValues",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_minValues",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_238": {
                "variable": {
                    "value": "maxValues",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_maxValues",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_239": {
                "variable": {
                    "value": "minValueWeights",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_minValueWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_240": {
                "variable": {
                    "value": "maxValueWeights",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_maxValueWeights",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_403": {
                "input_tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "log_416": {
                "x": {
                    "value": "truncated + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_423": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_425": {
                "logits": {
                    "value": "tf.log(pdf + epsilon) / temperature",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_431": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_433": {
                "logits": {
                    "value": "tf.log(pdf + epsilon) / temperature",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_673": {
                "features": {
                    "value": "A_d - 2 * tf.matmul(A, B, transpose_b=True) + B_d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_682": {
                "features": {
                    "value": "A_d - 2 * tf.matmul(sqMask * A, B, transpose_b=True) + B_d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_694": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[0] * self.numInputs",
                            "BinOp"
                        ],
                        [
                            "[0] * self.numInputs",
                            "BinOp"
                        ],
                        [
                            "addTensors(samples, layer.xHat_bwd[:self.numInputs])",
                            "Call"
                        ],
                        [
                            "addTensors(samples, layer.xHat[:self.numInputs])",
                            "Call"
                        ],
                        [
                            "self.sess.run(self.samples, feed_dict)",
                            "Call"
                        ],
                        [
                            "self.sess.run(self.samples, feed_dict)",
                            "Call"
                        ],
                        [
                            "self.sess.run([self.samples, self.p], feed_dict)",
                            "Call"
                        ],
                        [
                            "samples[0]",
                            "Subscript"
                        ],
                        [
                            "self.sess.run(self.samples, feed_dict)",
                            "Call"
                        ],
                        [
                            "self.sess.run(self.samples, feed_dict)",
                            "Call"
                        ],
                        [
                            "samples[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_700": {
                "tensor": {
                    "value": "arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arr",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, arr.shape[-1].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_703": {
                "tensor": {
                    "value": "arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "arr",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, width, height, arr.shape[-1].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_750": {
                "variable": {
                    "value": "self.marginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_751": {
                "variable": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_752": {
                "variable": {
                    "value": "self.bwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_753": {
                "variable": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_816": {
                "variable": {
                    "value": "self.nonLatentLogMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "membershipShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batchSize, N]",
                            "List"
                        ]
                    ]
                }
            },
            "zeros_817": {
                "variable": {
                    "value": "self.latentLogMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "membershipShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batchSize, N]",
                            "List"
                        ]
                    ]
                }
            },
            "zeros_819": {
                "variable": {
                    "value": "self.inputInfoSum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batchSize, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_993": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(logM - tf.reduce_max(logM))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_995": {
                "variable": {
                    "value": "self.p",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(logM - tf.reduce_max(logM)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.exp(logM - tf.reduce_max(logM)), axis=-1)",
                            "Call"
                        ],
                        [
                            "(tf.tensordot(c.a, centroids, [-1, -1]) + c.b) / tf.sqrt(tf.reduce_mean(centroidVar))",
                            "BinOp"
                        ],
                        [
                            "(expandedValues - expandedCentroids) / centroidSd",
                            "BinOp"
                        ],
                        [
                            "(expandedCentroids - expandedValues) / centroidSd",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_996": {
                "variable": {
                    "value": "self.logp",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.p",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_1001": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(logM - tf.reduce_max(logM))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_1002": {
                "variable": {
                    "value": "self.nonLatentP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(logM - tf.reduce_max(logM)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.exp(logM - tf.reduce_max(logM)), axis=-1)",
                            "Call"
                        ],
                        [
                            "(tf.tensordot(c.a, centroids, [-1, -1]) + c.b) / tf.sqrt(tf.reduce_mean(centroidVar))",
                            "BinOp"
                        ],
                        [
                            "(expandedValues - expandedCentroids) / centroidSd",
                            "BinOp"
                        ],
                        [
                            "(expandedCentroids - expandedValues) / centroidSd",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_1003": {
                "variable": {
                    "value": "self.nonLatentLogP",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.nonLatentP",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_1031": {
                "variable": {
                    "value": "self.memberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "self.logMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_1042": {
                "variable": {
                    "value": "self.memberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.memberships.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_1053": {
                "variable": {
                    "value": "outputMask",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "membershipShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[batchSize, N]",
                            "List"
                        ]
                    ]
                }
            },
            "extract_image_patches_1319": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "ksizes": {
                    "value": "patchSize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "patchSize",
                            "Method Argument"
                        ],
                        [
                            "patchSize",
                            "Method Argument"
                        ],
                        [
                            "patchSize",
                            "Method Argument"
                        ],
                        [
                            "patchSize",
                            "Method Argument"
                        ]
                    ]
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, b['stride'], 1, 1] if sequential else [1, b['stride'][0], b['stride'][1], 1]",
                            "IfExp"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "stride",
                            "Method Argument"
                        ],
                        [
                            "[1",
                            "Method Argument"
                        ]
                    ]
                },
                "rates": {
                    "value": "(1, 1, 1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_1541": {
                "variable": {
                    "value": "meanMask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs[0].mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sign_1544": {
                "variable": {
                    "value": "meanMask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "meanMask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs[0].mask, axis=-1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "meanMask + tf.reduce_mean(inputs[i].mask, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "tf.sign(meanMask)",
                            "Call"
                        ]
                    ]
                }
            },
            "placeholder_with_default_1640": {
                "variable": {
                    "value": "self.temperature",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.constant(1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exp_1709": {
                "variable": {
                    "value": "self.p",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.logp",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_random_seed_1929": {
                "seed": {
                    "value": "seed + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_1933": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_1935": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(device_count={'GPU': 0})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_initializer_1955": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "run_1955": {
                "session": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Session()",
                            "Call"
                        ],
                        [
                            "tf.Session(config=tf.ConfigProto(device_count={'GPU': 0}))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "sess",
                            "Method Argument"
                        ],
                        [
                            "sess",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stop_gradient_61": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_67": {
                "logits": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_70": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "x.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_72": {
                "logits": {
                    "value": "x / temperature",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_95": {
                "input_tensor": {
                    "value": "deinterleaved",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(pdf, shape2)",
                            "Call"
                        ],
                        [
                            "deinterleaved / (tf.reduce_sum(deinterleaved, axis=-1, keepdims=True) + epsilon)",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(deinterleaved)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, shape2)",
                            "Call"
                        ],
                        [
                            "tf.nn.log_softmax(deinterleaved)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "softmax_108": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_softmax_122": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.log(discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories))",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "placeholder_221": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdf.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "logits.shape.as_list()",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "list(data.shape)",
                            "Call"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ],
                        [
                            "shape",
                            "Method Argument"
                        ]
                    ]
                },
                "name": {
                    "value": "in_ieq_a",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_222": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "scalarShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape.copy()",
                            "Call"
                        ],
                        [
                            "sampleShape.copy()",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "in_ieq_b",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_223": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "in_ieq_w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_like_380": {
                "variable": {
                    "value": "averaged",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_387": {
                "variable": {
                    "value": "averaged",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "weighted",
                    "type": "variable",
                    "possible_values": [
                        [
                            "t if sampleWeights is None else sampleWeights * t",
                            "IfExp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_401": {
                "input_tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "relu_402": {
                "features": {
                    "value": "tf.sign(pdf - threshold)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_409": {
                "input_tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "log_409": {
                "x": {
                    "value": "truncation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "truncation",
                            "Method Argument"
                        ],
                        [
                            "truncation",
                            "Method Argument"
                        ],
                        [
                            "truncation",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_415": {
                "logits": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_424": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "pdf.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_432": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "logits.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_672": {
                "input_tensor": {
                    "value": "B * B",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Variable_735": {
                "variable": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.zeros([1, self.inputWidth, self.inputHeight, self.nCategories])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "logMarginalMemberships",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_737": {
                "variable": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.zeros([1, self.inputWidth, self.inputHeight, self.nCategories])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "logBwdMarginalMemberships",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_743": {
                "variable": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.zeros([1, self.nCategories])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "logMarginalMemberships",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_744": {
                "variable": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.zeros([1, self.nCategories])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "logBwdMarginalMemberships",
                    "type": "str",
                    "possible_values": []
                }
            },
            "range_811": {
                "variable": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "broadcast_to_973": {
                "variable": {
                    "value": "logMarginalMemberships",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.logMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[arrayBatchSize, self.inputWidth, self.inputHeight, self.nCategories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_974": {
                "variable": {
                    "value": "logMarginalMemberships",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logMarginalMemberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.broadcast_to(self.logMarginalMemberships, [arrayBatchSize, self.inputWidth, self.inputHeight, self.nCategories])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logMarginalMemberships, [-1, self.nCategories])",
                            "Call"
                        ],
                        [
                            "self.logMarginalMemberships",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.nCategories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "argmax_1008": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.eStepLogMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_1009": {
                "variable": {
                    "value": "self.eStepMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.eStepLogMemberships.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_1018": {
                "variable": {
                    "value": "EMLoss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "lossWeights * EMLosses",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_1037": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.memberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Categorical_1040": {
                "variable": {
                    "value": "distr",
                    "type": "variable",
                    "possible_values": []
                },
                "probs": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.fwd(inputs, mode, return_memberships=True)",
                            "Call"
                        ],
                        [
                            "self.memberships",
                            "Attribute"
                        ],
                        [
                            "softmaxWithTemperature(logBwdMemberships, self.bwdSamplingTemperature)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_1072": {
                "x": {
                    "value": "result / nContinuous",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_1079": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logBwdMemberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "logPdfTruncate(logBwdMemberships, bwdTruncation)",
                            "Call"
                        ],
                        [
                            "tf.sign(self.bwdSamplingTemperature) * logBwdMarginalMemberships + stopGradient(logBwdMemberships)",
                            "BinOp"
                        ],
                        [
                            "(1.0 - skipWeight) * logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ],
                        [
                            "logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Categorical_1125": {
                "variable": {
                    "value": "distr",
                    "type": "variable",
                    "possible_values": []
                },
                "probs": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer.fwd(inputs, mode, return_memberships=True)",
                            "Call"
                        ],
                        [
                            "self.memberships",
                            "Attribute"
                        ],
                        [
                            "softmaxWithTemperature(logBwdMemberships, self.bwdSamplingTemperature)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_1160": {
                "variable": {
                    "value": "reconstructed",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "centroids[inputIdx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "indices": {
                    "value": "membershipIndices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "membershipIndices",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Variable_1229": {
                "variable": {
                    "value": "self.trainingPhase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "clip_by_value_1232": {
                "variable": {
                    "value": "decayingPhase",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "tf.square(2.0 - 2.0 * self.trainingPhase)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_1240": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learningRate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gradients_1331": {
                "ys": {
                    "value": "_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ],
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "gradients_1339": {
                "ys": {
                    "value": "_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ],
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ]
                    ]
                },
                "grad_ys": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "Method Argument"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_1360": {
                "variable": {
                    "value": "batchShape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_1445": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, inputTensor.shape[1].value, inputTensor.shape[2].value, inputTensor.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1461": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, shape1, shape2, stream.tensor.shape[1].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1462": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, shape1, shape2, stream.mask.shape[1].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1471": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, stream.tensor.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1487": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_1488": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_1499": {
                "variable": {
                    "value": "origShape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.inputs[streamIdx].tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_1500": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "extract_patches_inverse_mean(tensor, self.inputs[streamIdx].tensor, self.patchSize, self.stride)",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, inputTensor.shape[1].value, inputTensor.shape[2].value, inputTensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, shape1, shape2, stream.tensor.shape[1].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, origShape)",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, [-1, w, h, tensor.shape[1].value // (w * h)])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(self.inputs[i].tensor)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "origShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(self.inputs[streamIdx].tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_1511": {
                "variable": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1512": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1525": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "extract_patches_inverse_mean(tensor, self.inputs[streamIdx].tensor, self.patchSize, self.stride)",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, inputTensor.shape[1].value, inputTensor.shape[2].value, inputTensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, shape1, shape2, stream.tensor.shape[1].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, origShape)",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, [-1, w, h, tensor.shape[1].value // (w * h)])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(self.inputs[i].tensor)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, w, h, tensor.shape[1].value // (w * h)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_like_1556": {
                "variable": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.inputs[i].tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_1607": {
                "variable": {
                    "value": "outputs[-1].tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "streamSoftmax(stream.tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "time.time() - t1",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(stream.tensor, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "outputs[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "outputs[-1].mask",
                            "Attribute"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, t.shape[1].value, t.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_1658": {
                "variable": {
                    "value": "self.trainingPhase",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "clip_by_value_1661": {
                "variable": {
                    "value": "decayingPhase",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "tf.square(2.0 - 2.0 * self.trainingPhase)",
                    "type": "Call",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "AdamOptimizer_1758": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learningRate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stop_gradient_62": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "(1.0 - hardness) * x + hardness * tf.one_hot(indices=indices, depth=x.shape[-1].value)",
                            "BinOp"
                        ],
                        [
                            "x / tf.reduce_sum(x, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "self.residual_inverse(xHat, stopStreamGradients(data[:-1]))",
                            "Call"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "xHat[inputIdx].tensor + rt",
                            "BinOp"
                        ],
                        [
                            "streamLogSoftmax(x, nCategories=xHat[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "one_hot_137": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(pdf, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.eStepLogMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.argmax(self.memberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "tf.argmax(logBwdMemberships, axis=-1)",
                            "Call"
                        ],
                        [
                            "distr.sample()",
                            "Call"
                        ],
                        [
                            "np.argsort(-probabilities)",
                            "Call"
                        ],
                        [
                            "np.argsort(-logProbabilities)",
                            "Call"
                        ],
                        [
                            "np.round((self.nLevels - 1) * scaled)",
                            "Call"
                        ],
                        [
                            "np.clip(indices, 0, self.nLevels - 1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "x.shape[-1].value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_383": {
                "variable": {
                    "value": "averagedMask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_390": {
                "input": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sign_402": {
                "x": {
                    "value": "pdf - threshold",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_410": {
                "features": {
                    "value": "tf.sign(pdf - threshold)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_425": {
                "x": {
                    "value": "pdf + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_433": {
                "x": {
                    "value": "pdf + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_528": {
                "variable": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_543": {
                "variable": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "stream.tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_563": {
                "variable": {
                    "value": "encoded[i].tensor",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "encoded[i].tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_762": {
                "variable": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "initialValue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.uniform(-1, 1, varSize)",
                            "Call"
                        ],
                        [
                            "np.random.uniform(0, initialSpread, size=varSize)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'centroids_{}'.format(inputIdx)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_803": {
                "input": {
                    "value": "inputs[0].tensor",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_879": {
                "variable": {
                    "value": "centroidSd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.5 * centroidLogVar",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_880": {
                "variable": {
                    "value": "centroidVar",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "centroidLogVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=np.log(initialSdScale / np.power(N, 1.0 / M)), dtype=tf.float32, trainable=True, name='logvar_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=np.log(initialSdScale / np.power(N, 1.0 / M)) * np.ones([1, M]), dtype=tf.float32, trainable=True, name='logvar_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "self.centroidLogVars[inputIdx]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "exp_993": {
                "x": {
                    "value": "logM - tf.reduce_max(logM)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_1001": {
                "x": {
                    "value": "logM - tf.reduce_max(logM)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_1012": {
                "variable": {
                    "value": "lossMean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "EMLosses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_sum(tf.stop_gradient(self.eStepMemberships) * self.mStepLogMemberships, axis=-1)",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "sqrt_1013": {
                "variable": {
                    "value": "lossSd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(tf.square(EMLosses - lossMean))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stop_gradient_1015": {
                "variable": {
                    "value": "lossWeights",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.exp(-0.5 * tf.square(normalizedLosses))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_1143": {
                "variable": {
                    "value": "reconstructed",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "memberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.get_memberships_for_data_batch(0.99, batch)['memberships']",
                            "Subscript"
                        ],
                        [
                            "[m.argmax(axis=1) for m in memberships]",
                            "ListComp"
                        ],
                        [
                            "np.stack(memberships).T",
                            "Attribute"
                        ],
                        [
                            "[tuple(r) for r in memberships]",
                            "ListComp"
                        ],
                        [
                            "self.sess.run([self.loss, self.membership_lst], feed_dict)",
                            "Call"
                        ],
                        [
                            "memberships",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "centroids[inputIdx]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_1147": {
                "variable": {
                    "value": "reconstructed",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "memberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model.get_memberships_for_data_batch(0.99, batch)['memberships']",
                            "Subscript"
                        ],
                        [
                            "[m.argmax(axis=1) for m in memberships]",
                            "ListComp"
                        ],
                        [
                            "np.stack(memberships).T",
                            "Attribute"
                        ],
                        [
                            "[tuple(r) for r in memberships]",
                            "ListComp"
                        ],
                        [
                            "self.sess.run([self.loss, self.membership_lst], feed_dict)",
                            "Call"
                        ],
                        [
                            "memberships",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "streamSoftmax(centroids[inputIdx], self.inputs[inputIdx].nCategories)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gradients_1334": {
                "ys": {
                    "value": "_y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ],
                        [
                            "extract_patches(_x, patchSize, stride)",
                            "Call"
                        ]
                    ]
                },
                "xs": {
                    "value": "_x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(x)",
                            "Call"
                        ]
                    ]
                },
                "grad_ys": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "Method Argument"
                        ],
                        [
                            "y",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_1543": {
                "input_tensor": {
                    "value": "inputs[i].mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_1610": {
                "variable": {
                    "value": "outputs[-1].mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "streamSoftmax(stream.tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "time.time() - t1",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(stream.tensor, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "outputs[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "outputs[-1].mask",
                            "Attribute"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, t.shape[1].value, t.shape[3].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_1640": {
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_1708": {
                "tensor": {
                    "value": "tf.reduce_sum(patchLogProbabilities, axis=[1, 2, 3])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_87": {
                "input_tensor": {
                    "value": "pdf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(tf.sign(pdf - threshold)) * pdf",
                            "BinOp"
                        ],
                        [
                            "pdf / tf.reduce_sum(pdf, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "pdf - 10000000000.0 * tf.nn.relu(tf.sign(pdf - threshold))",
                            "BinOp"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ],
                        [
                            "pdf",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sign_410": {
                "x": {
                    "value": "pdf - threshold",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_672": {
                "input": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "B",
                            "Method Argument"
                        ],
                        [
                            "B",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "Variable_767": {
                "variable": {
                    "value": "centroidLogVar",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.log(initialSdScale / np.power(N, 1.0 / M))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "'logvar_{}'.format(inputIdx)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_782": {
                "variable": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "initialValue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.uniform(-1, 1, varSize)",
                            "Call"
                        ],
                        [
                            "np.random.uniform(0, initialSpread, size=varSize)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "'centroids_{}'.format(inputIdx)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_830": {
                "input_tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(samples)",
                            "Call"
                        ],
                        [
                            "mask / sd",
                            "BinOp"
                        ],
                        [
                            "inputs[inputIdx].mask",
                            "Attribute"
                        ],
                        [
                            "stopGradient(mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, [-1, shape1, shape2, stream.mask.shape[1].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.mask, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_846": {
                "variable": {
                    "value": "inputMean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputToGatherFrom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_847": {
                "variable": {
                    "value": "inputVar",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(inputToGatherFrom - inputMean)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_848": {
                "variable": {
                    "value": "inputSd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.square(inputToGatherFrom - inputMean), axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputVar)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_863": {
                "variable": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(centroids, inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "self.centroids[inputIdx]",
                            "Subscript"
                        ],
                        [
                            "tf.assign(centroids, initCentroids)",
                            "Call"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "value": {
                    "value": "initCentroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(inputToGatherFrom, ridxs)",
                            "Call"
                        ],
                        [
                            "initCentroids + tf.truncated_normal(shape=[N, M], mean=tf.zeros(M), stddev=0.1 * inputSd)",
                            "BinOp"
                        ],
                        [
                            "tf.truncated_normal(shape=[N, M], mean=inputMean[0], stddev=inputSd[0])",
                            "Call"
                        ],
                        [
                            "tf.random_uniform(shape=[N, M], minval=inputMin, maxval=inputMax)",
                            "Call"
                        ]
                    ]
                }
            },
            "assign_876": {
                "variable": {
                    "value": "centroidLogvar",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "centroidLogVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=np.log(initialSdScale / np.power(N, 1.0 / M)), dtype=tf.float32, trainable=True, name='logvar_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=np.log(initialSdScale / np.power(N, 1.0 / M)) * np.ones([1, M]), dtype=tf.float32, trainable=True, name='logvar_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "self.centroidLogVars[inputIdx]",
                            "Subscript"
                        ]
                    ]
                },
                "value": {
                    "value": "tf.log(tf.square(initSd))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_957": {
                "variable": {
                    "value": "streamLogMemberships",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "masked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask * input",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(centroids, inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "self.centroids[inputIdx]",
                            "Subscript"
                        ],
                        [
                            "tf.assign(centroids, initCentroids)",
                            "Call"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_1010": {
                "input_tensor": {
                    "value": "tf.stop_gradient(self.eStepMemberships) * self.mStepLogMemberships",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_1024": {
                "input_tensor": {
                    "value": "tf.reduce_max(self.nonLatentLogMemberships, axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_1069": {
                "x": {
                    "value": "self.centroidLogVars[inputIdx]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_1076": {
                "input": {
                    "value": "logBwdMemberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "logPdfTruncate(logBwdMemberships, bwdTruncation)",
                            "Call"
                        ],
                        [
                            "tf.sign(self.bwdSamplingTemperature) * logBwdMarginalMemberships + stopGradient(logBwdMemberships)",
                            "BinOp"
                        ],
                        [
                            "(1.0 - skipWeight) * logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ],
                        [
                            "logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "broadcast_to_1108": {
                "variable": {
                    "value": "logBwdMarginalMemberships",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.logBwdMarginalMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[arrayBatchSize, self.inputWidth, self.inputHeight, self.nCategories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1109": {
                "variable": {
                    "value": "logBwdMarginalMemberships",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logBwdMarginalMemberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.broadcast_to(self.logBwdMarginalMemberships, [arrayBatchSize, self.inputWidth, self.inputHeight, self.nCategories])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logBwdMarginalMemberships, [-1, self.nCategories])",
                            "Call"
                        ],
                        [
                            "self.logBwdMarginalMemberships",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, self.nCategories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stop_gradient_1116": {
                "variable": {
                    "value": "targets",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "discretePdfBatchAverage(self.eStepMemberships, self.nCategories)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_1117": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "discretePdfBatchAverage(tf.nn.softmax(logBwdMemberships), nCategories=self.nCategories)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_1148": {
                "input_tensor": {
                    "value": "reconstructed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(memberships, centroids[inputIdx])",
                            "Call"
                        ],
                        [
                            "tf.matmul(memberships, streamSoftmax(centroids[inputIdx], self.inputs[inputIdx].nCategories))",
                            "Call"
                        ],
                        [
                            "reconstructed / tf.reduce_sum(reconstructed, axis=-1, keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "discretePdfLog(reconstructed, self.inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "tf.gather(centroids[inputIdx], membershipIndices)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "square_1232": {
                "x": {
                    "value": "2.0 - 2.0 * self.trainingPhase",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "broadcast_to_1366": {
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "extract_patches_inverse_mean(tensor, self.inputs[streamIdx].tensor, self.patchSize, self.stride)",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, inputTensor.shape[1].value, inputTensor.shape[2].value, inputTensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, shape1, shape2, stream.tensor.shape[1].value])",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, origShape)",
                            "Call"
                        ],
                        [
                            "stream.tensor",
                            "Attribute"
                        ],
                        [
                            "tf.reshape(tensor, [-1, w, h, tensor.shape[1].value // (w * h)])",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(self.inputs[i].tensor)",
                            "Call"
                        ],
                        [
                            "tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "batchShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(stream.tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_1414": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "streamSoftmax(stream.tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "time.time() - t1",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(stream.tensor, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "outputs[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "outputs[-1].mask",
                            "Attribute"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, t.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1577": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "streamSoftmax(stream.tensor, stream.nCategories)",
                            "Call"
                        ],
                        [
                            "time.time() - t1",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(stream.tensor, self.shape)",
                            "Call"
                        ],
                        [
                            "tf.reshape(stream.tensor, [-1, stream.tensor.shape[1].value * stream.tensor.shape[2].value * stream.tensor.shape[3].value])",
                            "Call"
                        ],
                        [
                            "outputs[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "outputs[-1].mask",
                            "Attribute"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, t.shape[1].value, 1, t.shape[2].value]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "square_1661": {
                "x": {
                    "value": "2.0 - 2.0 * self.trainingPhase",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_1708": {
                "input_tensor": {
                    "value": "patchLogProbabilities",
                    "type": "variable",
                    "possible_values": [
                        [
                            "deinterleaveArray(block.lastRMM.nonLatentLogP, block.lastRMM.inputWidth, block.lastRMM.inputHeight)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ConfigProto_1935": {
                "device_count": {
                    "value": "{'GPU': 0}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "reduce_mean_393": {
                "input_tensor": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ones_like_393": {
                "input": {
                    "value": "stream.mask",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_574": {
                "variable": {
                    "value": "residualSd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.exp(layer.centroidLogVars[0])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_673": {
                "a": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "A",
                            "Method Argument"
                        ],
                        [
                            "A",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "B",
                            "Method Argument"
                        ],
                        [
                            "B",
                            "Method Argument"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_682": {
                "a": {
                    "value": "sqMask * A",
                    "type": "BinOp",
                    "possible_values": []
                },
                "b": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "B",
                            "Method Argument"
                        ],
                        [
                            "B",
                            "Method Argument"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Variable_769": {
                "variable": {
                    "value": "centroidLogVar",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.log(initialSdScale / np.power(N, 1.0 / M)) * np.ones([1, M])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "'logvar_{}'.format(inputIdx)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_836": {
                "input_tensor": {
                    "value": "inputs[inputIdx].boxConstraint.minValueWeights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_837": {
                "input_tensor": {
                    "value": "inputs[inputIdx].boxConstraint.maxValueWeights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "gather_852": {
                "variable": {
                    "value": "initCentroids",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "inputToGatherFrom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ]
                    ]
                },
                "indices": {
                    "value": "ridxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(idxs)[:N]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_mean_869": {
                "variable": {
                    "value": "inputVar",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.square(inputToGatherFrom - inputMean), axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputVar)",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_870": {
                "variable": {
                    "value": "inputSd",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.square(inputToGatherFrom - inputMean), axis=0, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputVar)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_915": {
                "variable": {
                    "value": "expandedValues",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bc.maxValues",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_916": {
                "variable": {
                    "value": "expandedCentroids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(centroids, inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "self.centroids[inputIdx]",
                            "Subscript"
                        ],
                        [
                            "tf.assign(centroids, initCentroids)",
                            "Call"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, N, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_924": {
                "variable": {
                    "value": "expandedValues",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bc.minValues",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_925": {
                "variable": {
                    "value": "expandedCentroids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(centroids, inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "self.centroids[inputIdx]",
                            "Subscript"
                        ],
                        [
                            "tf.assign(centroids, initCentroids)",
                            "Call"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, N, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_993": {
                "input_tensor": {
                    "value": "logM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mStepLogMemberships",
                            "Attribute"
                        ],
                        [
                            "self.nonLatentLogMemberships",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reduce_max_1001": {
                "input_tensor": {
                    "value": "logM",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mStepLogMemberships",
                            "Attribute"
                        ],
                        [
                            "self.nonLatentLogMemberships",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reduce_mean_1013": {
                "input_tensor": {
                    "value": "tf.square(EMLosses - lossMean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_1014": {
                "features": {
                    "value": "EMLosses - lossMean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_1015": {
                "x": {
                    "value": "-0.5 * tf.square(normalizedLosses)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_max_1024": {
                "input_tensor": {
                    "value": "self.nonLatentLogMemberships",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sign_1083": {
                "x": {
                    "value": "self.inputInfoSum",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_1092": {
                "shape": {
                    "value": "[arrayBatchSize, self.inputWidth, self.inputHeight, self.nCategories]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_1184": {
                "variable": {
                    "value": "aTxHat",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "c.a * xHat[inputIdx].tensor",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "tanh_1230": {
                "x": {
                    "value": "20.0 * (self.trainingPhase - 1.0 / 2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tanh_1659": {
                "x": {
                    "value": "20.0 * (self.trainingPhase - 1.0 / 2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_847": {
                "x": {
                    "value": "inputToGatherFrom - inputMean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_853": {
                "shape": {
                    "value": "[N, M]",
                    "type": "List",
                    "possible_values": []
                },
                "mean": {
                    "value": "tf.zeros(M)",
                    "type": "Call",
                    "possible_values": []
                },
                "stddev": {
                    "value": "0.1 * inputSd",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_856": {
                "variable": {
                    "value": "initCentroids",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N, M]",
                    "type": "List",
                    "possible_values": []
                },
                "mean": {
                    "value": "inputMean[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputToGatherFrom, axis=0, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "stddev": {
                    "value": "inputSd[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.sqrt(inputVar)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(inputVar)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_876": {
                "x": {
                    "value": "tf.square(initSd)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_884": {
                "input_tensor": {
                    "value": "mask * centroidLogVar",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_921": {
                "input_tensor": {
                    "value": "tf.reshape(bc.maxValueWeights, [-1, 1, M]) * tf.log(cdf + epsilon)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_928": {
                "input_tensor": {
                    "value": "tf.reshape(bc.minValueWeights, [-1, 1, M]) * tf.log(cdf + epsilon)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stop_gradient_1010": {
                "input": {
                    "value": "self.eStepMemberships",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_1013": {
                "x": {
                    "value": "EMLosses - lossMean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sign_1113": {
                "x": {
                    "value": "self.bwdSamplingTemperature",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_1118": {
                "input_tensor": {
                    "value": "tf.reduce_sum(targets * logits, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_574": {
                "x": {
                    "value": "layer.centroidLogVars[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_575": {
                "input": {
                    "value": "noisySamples[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_min_858": {
                "variable": {
                    "value": "inputMin",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputToGatherFrom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_859": {
                "variable": {
                    "value": "inputMax",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputToGatherFrom",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input",
                            "variable"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "square_876": {
                "x": {
                    "value": "initSd",
                    "type": "variable",
                    "possible_values": [
                        [
                            "initialSdScale * inputSd / np.power(N, 1.0 / M)",
                            "BinOp"
                        ],
                        [
                            "initialSdScale * inputSd",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_901": {
                "x": {
                    "value": "tf.reduce_mean(centroidVar)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_903": {
                "x": {
                    "value": "cdf + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_946": {
                "x": {
                    "value": "prior.sd",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "square_1015": {
                "x": {
                    "value": "normalizedLosses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.relu(EMLosses - lossMean) / (lossSd * outlierLossThreshold)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "softmax_1117": {
                "logits": {
                    "value": "logBwdMemberships",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data[-1].tensor",
                            "Attribute"
                        ],
                        [
                            "logPdfTruncate(logBwdMemberships, bwdTruncation)",
                            "Call"
                        ],
                        [
                            "tf.sign(self.bwdSamplingTemperature) * logBwdMarginalMemberships + stopGradient(logBwdMemberships)",
                            "BinOp"
                        ],
                        [
                            "(1.0 - skipWeight) * logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ],
                        [
                            "logBwdMemberships + skipWeight * discretePdfLog(skipMemberships, self.nCategories)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_1118": {
                "input_tensor": {
                    "value": "targets * logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_853": {
                "shape": {
                    "value": "M",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input.shape[-1].value",
                            "Attribute"
                        ],
                        [
                            "input.shape[-1].value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "tensordot_901": {
                "a": {
                    "value": "c.a",
                    "type": "Attribute",
                    "possible_values": []
                },
                "b": {
                    "value": "centroids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "tf.Variable(initial_value=initialValue, dtype=tf.float32, name='centroids_{}'.format(inputIdx))",
                            "Call"
                        ],
                        [
                            "streamLogSoftmax(centroids, inputs[inputIdx].nCategories)",
                            "Call"
                        ],
                        [
                            "self.centroids[inputIdx]",
                            "Subscript"
                        ],
                        [
                            "tf.assign(centroids, initCentroids)",
                            "Call"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "self.centroids",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axes": {
                    "value": "[-1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_901": {
                "input_tensor": {
                    "value": "centroidVar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(centroidLogVar)",
                            "Call"
                        ]
                    ]
                }
            },
            "erf_902": {
                "x": {
                    "value": "p / tf.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "erf_919": {
                "x": {
                    "value": "p / tf.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_921": {
                "tensor": {
                    "value": "bc.maxValueWeights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_921": {
                "x": {
                    "value": "cdf + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "erf_927": {
                "x": {
                    "value": "p / tf.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_928": {
                "tensor": {
                    "value": "bc.minValueWeights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, M]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_928": {
                "x": {
                    "value": "cdf + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_949": {
                "x": {
                    "value": "varSum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "centroidVar + tf.square(prior.sd)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sqrt_902": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sqrt_919": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "sqrt_927": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "compute_all_L_metrics.py": {
        "torch": {}
    },
    "compute_mauve_metrics.py": {
        "torch": {
            "load_33": {
                "variable": {
                    "value": "p_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f'{save_directory}/generations/ref/feats{feats_suffix}_{args.datasplit}.pt'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "load_51": {
                "variable": {
                    "value": "q_feats",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "f'{save_directory}/generations/{folder}/feats{feats_suffix}_{filename}.pt'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "manual_seed_13": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "compute_ref_metrics.py": {
        "torch": {}
    },
    "generate_basic.py": {
        "torch": {
            "manual_seed_14": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_102": {
                "obj": {
                    "value": "feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src.model_utils.featurize_sequential(model, samples_2)",
                            "Call"
                        ],
                        [
                            "src.model_utils.featurize_sequential(model, samples_3)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "f'{folder_name}/feats_{name}.pt'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "save_99": {
                "obj": {
                    "value": "feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src.model_utils.featurize_sequential(model, samples_2)",
                            "Call"
                        ],
                        [
                            "src.model_utils.featurize_sequential(model, samples_3)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "feats_out_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f'{folder_name}/feats{feats_prefix}_{name}.pt'",
                            "JoinedStr"
                        ]
                    ]
                }
            }
        }
    },
    "generate_ref.py": {
        "torch": {
            "manual_seed_12": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "save_57": {
                "obj": {
                    "value": "feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src.model_utils.featurize_sequential(model, ds_tokens)",
                            "Call"
                        ],
                        [
                            "src.model_utils.featurize_sequential(model, samples_3)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "f'{folder_name}/feats_{name}.pt'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "save_51": {
                "obj": {
                    "value": "feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src.model_utils.featurize_sequential(model, ds_tokens)",
                            "Call"
                        ],
                        [
                            "src.model_utils.featurize_sequential(model, samples_3)",
                            "Call"
                        ]
                    ]
                },
                "f": {
                    "value": "feats_out_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "f'{folder_name}/feats{feats_prefix}_{name}.pt'",
                            "JoinedStr"
                        ]
                    ]
                }
            }
        }
    },
    "library/spreadingvectors/eval.py": {
        "torch": {
            "load_46": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.ckpt_path",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Sequential_55": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(in_features=dim, out_features=dint, bias=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Sequential_87": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_available_41": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_56": {
                "in_features": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xb.shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_57": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                }
            },
            "ReLU_58": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_59": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_60": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                }
            },
            "ReLU_61": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_62": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dout",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "library/spreadingvectors/train.py": {
        "torch": {
            "mm_32": {
                "variable": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "mat2": {
                    "value": "x.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_35": {
                "variable": {
                    "value": "(_, I)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mm(x, x.t())",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_62": {
                "variable": {
                    "value": "xt_var",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "xt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_dataset(args.database, args.device, size=args.size_base, test=False)",
                            "Call"
                        ],
                        [
                            "sanitize(xt[:args.num_learn])",
                            "Call"
                        ],
                        [
                            "xt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "SGD_65": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "net.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "lr_schedule[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "momentum": {
                    "value": "args.momentum",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "PairwiseDistance_66": {
                "variable": {
                    "value": "pdist",
                    "type": "variable",
                    "possible_values": []
                },
                "p": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_282": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(in_features=dim, out_features=dint, bias=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_306": {
                "variable": {
                    "value": "xt_torch",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "xt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "load_dataset(args.database, args.device, size=args.size_base, test=False)",
                            "Call"
                        ],
                        [
                            "sanitize(xt[:args.num_learn])",
                            "Call"
                        ],
                        [
                            "xt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "manual_seed_247": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "load_295": {
                "variable": {
                    "value": "ckpt",
                    "type": "variable",
                    "possible_values": []
                },
                "f": {
                    "value": "args.init_name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_117": {
                "variable": {
                    "value": "per_point_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "per_point_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdist(ins, pos) - pdist(ins, neg)",
                            "BinOp"
                        ],
                        [
                            "F.relu(per_point_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_283": {
                "in_features": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xb.shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_284": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                }
            },
            "ReLU_285": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_286": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_287": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                }
            },
            "ReLU_288": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_289": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dint",
                            "Attribute"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dout",
                            "Attribute"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "no_grad_307": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sum_119": {
                "input": {
                    "value": "per_point_loss.data > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "is_available_244": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_124": {
                "input": {
                    "value": "n * distances",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "library/spreadingvectors/train_spv.py": {
        "torch": {
            "mm_32": {
                "variable": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "data_lst",
                            "variable"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "mat2": {
                    "value": "x.t()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_35": {
                "variable": {
                    "value": "(_, I)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.mm(x, x.t())",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_62": {
                "variable": {
                    "value": "xt_var",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "xt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate(x_lst)",
                            "Call"
                        ],
                        [
                            "process_torch_feats(device, [p_feats, q_feats])",
                            "Call"
                        ],
                        [
                            "sanitize(xt[:args.num_learn])",
                            "Call"
                        ],
                        [
                            "xt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "SGD_65": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "net.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "lr_schedule[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "momentum": {
                    "value": "args.momentum",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "PairwiseDistance_66": {
                "variable": {
                    "value": "pdist",
                    "type": "variable",
                    "possible_values": []
                },
                "p": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Sequential_247": {
                "variable": {
                    "value": "net",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(in_features=dim, out_features=dint, bias=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "from_numpy_265": {
                "variable": {
                    "value": "xt_torch",
                    "type": "variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "xt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.concatenate(x_lst)",
                            "Call"
                        ],
                        [
                            "process_torch_feats(device, [p_feats, q_feats])",
                            "Call"
                        ],
                        [
                            "sanitize(xt[:args.num_learn])",
                            "Call"
                        ],
                        [
                            "xt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "device_205": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "manual_seed_217": {
                "seed": {
                    "value": "args.seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_117": {
                "variable": {
                    "value": "per_point_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "per_point_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "pdist(ins, pos) - pdist(ins, neg)",
                            "BinOp"
                        ],
                        [
                            "F.relu(per_point_loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_248": {
                "in_features": {
                    "value": "dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xb.shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_249": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_251": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "BatchNorm1d_252": {
                "num_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ReLU_253": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_254": {
                "in_features": {
                    "value": "dint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "768",
                            "Method Argument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "dout",
                    "type": "variable",
                    "possible_values": [
                        [
                            "4",
                            "Method Argument"
                        ]
                    ]
                },
                "bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "no_grad_266": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sum_119": {
                "input": {
                    "value": "per_point_loss.data > 0",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "device_207": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_124": {
                "input": {
                    "value": "n * distances",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "mean_124": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "src/generation_utils.py": {
        "torch": {
            "no_grad_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_417": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "full_132": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "(batch_size, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fill_value": {
                    "value": "bos_token_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bos_token_id if bos_token_id is not None else model.config.bos_token_id",
                            "IfExp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "next(model.parameters()).device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "full_230": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "size": {
                    "value": "(effective_batch_size * num_beams, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "fill_value": {
                    "value": "decoder_start_token_id",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder_start_token_id if decoder_start_token_id is not None else model.config.decoder_start_token_id",
                            "IfExp"
                        ],
                        [
                            "bos_token_id",
                            "variable"
                        ],
                        [
                            "model.config.decoder.bos_token_id",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "next(model.parameters()).device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_244": {
                "variable": {
                    "value": "expanded_batch_idxs",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_ids.shape[0]",
                            "Subscript"
                        ],
                        [
                            "1",
                            "int"
                        ],
                        [
                            "batch_size",
                            "Method Argument"
                        ],
                        [
                            "20",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cat_347": {
                "variable": {
                    "value": "input_ids",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[input_ids, tokens_to_add.unsqueeze(-1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_422": {
                "variable": {
                    "value": "prompt",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[sen[:, :prompt_size] for sen in b]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "softmax_333": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "next_token_logscores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "src.model_utils.my_top_k_top_p_filtering(scores, top_k=top_k, top_p=top_p)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "multinomial_334": {
                "variable": {
                    "value": "next_token",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "F.softmax(next_token_logscores, dim=-1)",
                            "Call"
                        ]
                    ]
                },
                "num_samples": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_334": {
                "variable": {
                    "value": "next_token",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_337": {
                "variable": {
                    "value": "next_token",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "next_token_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "outputs.logits[:, -1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_364": {
                "variable": {
                    "value": "attention_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[attention_mask, attention_mask.new_ones((attention_mask.shape[0], 1))]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "device_392": {
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_device_properties_395": {
                "device": {
                    "value": "device",
                    "type": "variable",
                    "possible_values": [
                        [
                            "next(model.parameters()).device",
                            "Attribute"
                        ],
                        [
                            "device",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "src/model_utils.py": {
        "torch": {
            "no_grad_15": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_softmax_82": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "no_grad_70": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_softmax_92": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outs.logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "no_grad_86": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_softmax_102": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "arange_104": {
                "variable": {
                    "value": "permutation",
                    "type": "variable",
                    "possible_values": []
                },
                "start": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "end": {
                    "value": "seq_len",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ger_107": {
                "variable": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.arange(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "vec2": {
                    "value": "torch.ones(seq_len - 1, dtype=torch.long)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ger_108": {
                "variable": {
                    "value": "j",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.ones(batch_size, dtype=torch.long)",
                    "type": "Call",
                    "possible_values": []
                },
                "vec2": {
                    "value": "torch.arange(seq_len - 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_97": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_112": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_128": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_144": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sort_36": {
                "variable": {
                    "value": "(sorted_logits, sorted_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "descending": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cumsum_37": {
                "variable": {
                    "value": "cumulative_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "softmax(sorted_logits, dim=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_157": {
                "tensors": {
                    "value": "feats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "arange_107": {
                "start": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_107": {
                "*size": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_108": {
                "*size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_108": {
                "start": {
                    "value": "seq_len - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_141": {
                "tensors": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "log_softmax(logits, dim=2)",
                            "Call"
                        ],
                        [
                            "log_softmax(outs.logits, dim=2)",
                            "Call"
                        ],
                        [
                            "log_softmax(logits, dim=2)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "softmax_37": {
                "input": {
                    "value": "sorted_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "torch.sort(logits, descending=True)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "topk_32": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "reshape_logit_scores(outs.logits, temperature, top_k, top_p)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "top_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "min(max(top_k, min_tokens_to_keep), logits.size(-1))",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "src/transformers_utils.py": {
        "torch": {
            "ones_138": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "len(banned_mask)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "src/utils.py": {
        "torch": {
            "device_13": {
                "variable": {
                    "value": "CPU_DEVICE",
                    "type": "variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cpu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "is_available_127": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "device_129": {
                "type": {
                    "value": "f'cuda:{device_id}'",
                    "type": "JoinedStr",
                    "possible_values": []
                }
            },
            "device_count_128": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "unsqueeze_211": {
                "input": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}