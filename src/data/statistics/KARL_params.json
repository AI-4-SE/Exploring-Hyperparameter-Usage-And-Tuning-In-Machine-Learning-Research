{
    "bert/modeling.py": {
        "tensorflow": {
            "list_variables_66": {
                "variable": {
                    "value": "init_vars",
                    "type": "Variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "tf_path",
                    "type": "Name",
                    "possible_values": [
                        [
                            "os.path.abspath(tf_checkpoint_path)",
                            "Call"
                        ]
                    ]
                }
            },
            "load_variable_71": {
                "variable": {
                    "value": "array",
                    "type": "Variable",
                    "possible_values": []
                },
                "ckpt_dir_or_file": {
                    "value": "tf_path",
                    "type": "Name",
                    "possible_values": [
                        [
                            "os.path.abspath(tf_checkpoint_path)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "Name",
                    "possible_values": [
                        [
                            "name.split('/')",
                            "Call"
                        ]
                    ]
                }
            }
        },
        "torch": {
            "from_numpy_115": {
                "variable": {
                    "value": "pointer.data",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "array",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.train.load_variable(tf_path, name)",
                            "Call"
                        ],
                        [
                            "np.transpose(array)",
                            "Call"
                        ]
                    ]
                }
            },
            "Embedding_255": {
                "variable": {
                    "value": "self.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "config.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Embedding_256": {
                "variable": {
                    "value": "self.position_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "config.max_position_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_257": {
                "variable": {
                    "value": "self.token_type_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "config.type_vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_262": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "arange_266": {
                "variable": {
                    "value": "position_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "start": {
                    "value": "seq_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_ids.size(1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "input_ids.device",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_292": {
                "variable": {
                    "value": "self.query",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.all_head_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_293": {
                "variable": {
                    "value": "self.key",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.all_head_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_294": {
                "variable": {
                    "value": "self.value",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.all_head_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_296": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.attention_probs_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_313": {
                "variable": {
                    "value": "attention_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "query_layer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.transpose_for_scores(mixed_query_layer)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "key_layer.transpose(-1, -2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_325": {
                "variable": {
                    "value": "context_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attention_probs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "nn.Softmax(dim=-1)(attention_scores)",
                            "Call"
                        ],
                        [
                            "self.dropout(attention_probs)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "value_layer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.transpose_for_scores(mixed_value_layer)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_335": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_337": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_361": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "config.intermediate_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_376": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.intermediate_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_378": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_405": {
                "variable": {
                    "value": "self.layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[copy.deepcopy(layer) for _ in range(config.num_hidden_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Linear_422": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tanh_423": {
                "variable": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_437": {
                "variable": {
                    "value": "self.dense",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_458": {
                "variable": {
                    "value": "self.decoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "bert_model_embedding_weights.size(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "out_features": {
                    "value": "bert_model_embedding_weights.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Parameter_462": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(bert_model_embedding_weights.size(0))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Linear_483": {
                "variable": {
                    "value": "self.seq_relationship",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_494": {
                "variable": {
                    "value": "self.seq_relationship",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Dropout_990": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_991": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ],
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Dropout_1055": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_1056": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Dropout_1125": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_1126": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ],
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Linear_1201": {
                "variable": {
                    "value": "self.qa_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_129": {
                "input": {
                    "value": "x",
                    "type": "Name",
                    "possible_values": [
                        [
                            "(x - u) / torch.sqrt(s + self.variance_epsilon)",
                            "BinOp"
                        ],
                        [
                            "x.view(*new_x_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_269": {
                "variable": {
                    "value": "token_type_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "load_608": {
                "variable": {
                    "value": "state_dict",
                    "type": "Variable",
                    "possible_values": []
                },
                "f": {
                    "value": "weights_path",
                    "type": "Call",
                    "possible_values": [
                        [
                            "os.path.join(serialization_dir, WEIGHTS_NAME)",
                            "Call"
                        ],
                        [
                            "os.path.join(serialization_dir, TF_WEIGHTS_NAME)",
                            "Call"
                        ]
                    ]
                },
                "map_location": {
                    "value": "cpu",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_like_717": {
                "variable": {
                    "value": "attention_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_like_719": {
                "variable": {
                    "value": "token_type_ids",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_ids",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_809": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_872": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_934": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_1000": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_1069": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_1135": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_1222": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "ignored_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "start_logits.size(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "erf_125": {
                "input": {
                    "value": "x / math.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Parameter_240": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.ones(hidden_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_241": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(hidden_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Softmax_319": {
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_462": {
                "*size": {
                    "value": "bert_model_embedding_weights.size(0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_240": {
                "*size": {
                    "value": "hidden_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "768",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "zeros_241": {
                "*size": {
                    "value": "hidden_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "768",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "sqrt_247": {
                "input": {
                    "value": "s + self.variance_epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "bert/file_utils.py": {
        "torch": {}
    },
    "fairseq/binarizer.py": {
        "torch": {}
    },
    "fairseq/bleu.py": {
        "torch": {}
    },
    "fairseq/checkpoint_utils.py": {
        "torch": {
            "load_141": {
                "variable": {
                    "value": "state",
                    "type": "Variable",
                    "possible_values": []
                },
                "f": {
                    "value": "path",
                    "type": "Variable",
                    "possible_values": []
                },
                "map_location": {
                    "value": "lambda s, l: default_restore_location(s, 'cpu')",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "save_208": {
                "obj": {
                    "value": "*args",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "is_tensor_222": {
                "obj": {
                    "value": "state_dict",
                    "type": "Name",
                    "possible_values": [
                        [
                            "{'args': args, 'model': model_state_dict if model_state_dict else {}, 'optimizer_history': optim_history + [{'criterion_name': criterion.__class__.__name__, 'optimizer_name': optimizer.__class__.__name__, 'lr_scheduler_state': lr_scheduler.state_dict(), 'num_updates': num_updates}], 'last_optimizer_state': convert_state_dict_type(optimizer.state_dict()), 'extra_state': extra_state}",
                            "Dict"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/criterions/adaptive_loss.py": {
        "torch": {
            "cross_entropy_60": {
                "input": {
                    "value": "logits[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "target": {
                    "value": "target[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "self.padding_idx",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "sum if reduce else none",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/criterions/composite_loss.py": {
        "torch": {}
    },
    "fairseq/criterions/cross_entropy.py": {
        "torch": {
            "nll_loss_48": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lprobs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "model.get_normalized_probs(net_output, log_probs=True)",
                            "Call"
                        ],
                        [
                            "lprobs.view(-1, lprobs.size(-1))",
                            "Call"
                        ]
                    ]
                },
                "target": {
                    "value": "target",
                    "type": "Name",
                    "possible_values": [
                        [
                            "model.get_targets(sample, net_output).view(-1)",
                            "Call"
                        ]
                    ]
                },
                "ignore_index": {
                    "value": "self.padding_idx",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reduction": {
                    "value": "sum if reduce else none",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/criterions/fairseq_criterion.py": {
        "torch": {}
    },
    "fairseq/criterions/masked_lm_loss.py": {
        "torch": {
            "nll_loss_26": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.log_softmax(logits, -1, dtype=torch.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "target": {
                    "value": "targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "reduction": {
                    "value": "sum",
                    "type": "Constant",
                    "possible_values": []
                },
                "ignore_index": {
                    "value": "ignore_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "-100",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "log_softmax_27": {
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/backtranslation_dataset.py": {
        "torch": {
            "is_available_94": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/block_pair_dataset.py": {
        "torch": {
            "cat_287": {
                "variable": {
                    "value": "buffer",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.dataset[idx] for idx in range(start_ds_idx, end_ds_idx + 1)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/dictionary.py": {
        "torch": {
            "Tensor_220": {
                "variable": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "is_tensor_56": {
                "obj": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/fairseq_dataset.py": {
        "torch": {}
    },
    "fairseq/data/indexed_dataset.py": {
        "torch": {
            "from_numpy_129": {
                "variable": {
                    "value": "item",
                    "type": "Variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "a",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.empty(n, dtype=np.int64)",
                            "Call"
                        ],
                        [
                            "np.empty(tensor_size, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "self.cache[ptx:ptx + size]",
                            "Subscript"
                        ],
                        [
                            "np.empty(tensor_size, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_195": {
                "variable": {
                    "value": "item",
                    "type": "Variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "a",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.empty(n, dtype=np.int64)",
                            "Call"
                        ],
                        [
                            "np.empty(tensor_size, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "self.cache[ptx:ptx + size]",
                            "Subscript"
                        ],
                        [
                            "np.empty(tensor_size, dtype=self.dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_432": {
                "variable": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "np.frombuffer(self._bin_buffer, dtype=self._index.dtype, count=size, offset=ptr)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/iterators.py": {
        "torch": {
            "DataLoader_191": {
                "dataset": {
                    "value": "self.dataset",
                    "type": "Attribute",
                    "possible_values": []
                },
                "collate_fn": {
                    "value": "self.collate_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_sampler": {
                    "value": "batches[offset:]",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.frozen_batches",
                            "Attribute"
                        ],
                        [
                            "shuffle_batches(list(batches), self.seed + epoch)",
                            "Call"
                        ],
                        [
                            "list(ShardedIterator(batches, self.num_shards, self.shard_id, fill_value=[]))",
                            "Call"
                        ],
                        [
                            "shuffle_batches(list(self.frozen_batches), self.seed + epoch)",
                            "Call"
                        ],
                        [
                            "self.frozen_batches",
                            "Attribute"
                        ],
                        [
                            "shuffle_batches(batches, self.seed + epoch + self.shard_id)",
                            "Call"
                        ],
                        [
                            "list(ShardedIterator(batches, self.num_shards, self.shard_id, fill_value=[]))",
                            "Call"
                        ]
                    ]
                },
                "num_workers": {
                    "value": "self.num_workers",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/language_pair_dataset.py": {
        "torch": {
            "cat_143": {
                "variable": {
                    "value": "tgt_item",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.tgt[index], torch.LongTensor([eos])]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/lm_context_window_dataset.py": {
        "torch": {
            "from_numpy_59": {
                "variable": {
                    "value": "sample[net_input][src_tokens]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "new_toks",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.empty([bsz, tsz + self.context_window], dtype=np.int64)",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_60": {
                "variable": {
                    "value": "sample[target]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "ndarray": {
                    "value": "new_tgt",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.full([bsz, tsz + self.context_window], pad, dtype=np.int64)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/data/masked_lm_dataset.py": {
        "torch": {}
    },
    "fairseq/data/monolingual_dataset.py": {
        "torch": {
            "cat_136": {
                "variable": {
                    "value": "source",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[source.new([self.vocab.bos()]), source]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_108": {
                "variable": {
                    "value": "source",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[source, source.new([self.vocab.eos()])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_138": {
                "variable": {
                    "value": "target",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[target.new([self.tgt_vocab.bos()]), target]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_111": {
                "variable": {
                    "value": "future_target",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[future_target, future_target.new([self.vocab.pad()])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_115": {
                "variable": {
                    "value": "past_target",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[past_target.new([self.vocab.pad()]), past_target[1:], source[-2, None]]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/data/noising.py": {
        "torch": {
            "t_65": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.t(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "t_295": {
                "variable": {
                    "value": "src_tokens_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "src_tokens",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.src_dataset[index]",
                            "Subscript"
                        ],
                        [
                            "src_tokens.unsqueeze(0)",
                            "Call"
                        ]
                    ]
                }
            },
            "t_302": {
                "variable": {
                    "value": "noisy_src_tokens",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "noisy_src_tokens",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.noiser.noising(src_tokens_t, src_lengths)",
                            "Call"
                        ],
                        [
                            "torch.t(noisy_src_tokens)",
                            "Call"
                        ]
                    ]
                }
            },
            "from_numpy_184": {
                "ndarray": {
                    "value": "permutation",
                    "type": "Name",
                    "possible_values": [
                        [
                            "scores.argsort()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/data/token_block_dataset.py": {
        "torch": {
            "cat_119": {
                "variable": {
                    "value": "buffer",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[self.dataset[idx] for idx in range(start_ds_idx, end_ds_idx + 1)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "cat_132": {
                "variable": {
                    "value": "source",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[item.new([self.eos]), buffer[0:e - 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_133": {
                "variable": {
                    "value": "past_target",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[item.new([self.pad, self.eos]), buffer[0:e - 2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cumsum_73": {
                "variable": {
                    "value": "cumsum",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sizes",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.array(sizes, dtype=int)",
                            "Call"
                        ],
                        [
                            "torch.tensor(sizes)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_137": {
                "variable": {
                    "value": "past_target",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[item.new([self.eos]), buffer[0:e - 2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_72": {
                "variable": {
                    "value": "sizes",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "sizes",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.array(sizes, dtype=int)",
                            "Call"
                        ],
                        [
                            "torch.tensor(sizes)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_71": {
                "obj": {
                    "value": "sizes",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.array(sizes, dtype=int)",
                            "Call"
                        ],
                        [
                            "torch.tensor(sizes)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/data/transform_eos_dataset.py": {
        "torch": {
            "cat_84": {
                "variable": {
                    "value": "item[source]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[item['source'], self.eos]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_90": {
                "variable": {
                    "value": "item[target]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[item['target'], self.eos]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/distributed_utils.py": {
        "torch": {
            "is_initialized_70": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rand_85": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/file_utils.py": {
        "torch": {}
    },
    "fairseq/legacy_distributed_data_parallel.py": {
        "torch": {
            "zeros_like_144": {
                "variable": {
                    "value": "param.grad",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "param",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.module.parameters()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_111": {
                "variable": {
                    "value": "buffer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "p",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.module.parameters()",
                            "Call"
                        ],
                        [
                            "params[0]",
                            "Subscript"
                        ],
                        [
                            "params",
                            "Name"
                        ],
                        [
                            "params",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/models/distributed_fairseq_model.py": {
        "torch": {}
    },
    "fairseq/models/fairseq_decoder.py": {
        "torch": {}
    },
    "fairseq/models/fairseq_encoder.py": {
        "torch": {}
    },
    "fairseq/models/fairseq_model.py": {
        "torch": {
            "ModuleDict_302": {
                "variable": {
                    "value": "self.models",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "{key: FairseqModel(encoders[key], decoders[key]) for key in self.keys}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "is_tensor_456": {
                "obj": {
                    "value": "encoder_out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.encoder(src_tokens, src_lengths=src_lengths, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.encoder(src_tokens, src_lengths=src_lengths, **kwargs)",
                            "Call"
                        ],
                        [
                            "self.models[key].encoder(src_tokens, src_lengths, **kwargs)",
                            "Call"
                        ],
                        [
                            "net_output['encoder_out']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "is_tensor_48": {
                "obj": {
                    "value": "net_output",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "remove_weight_norm_110": {
                "module": {
                    "value": "module",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "log_softmax_459": {
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "net_output.float()",
                            "Call"
                        ],
                        [
                            "encoder_out.float()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_461": {
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "net_output.float()",
                            "Call"
                        ],
                        [
                            "encoder_out.float()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_softmax_51": {
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "net_output.float()",
                            "Call"
                        ],
                        [
                            "encoder_out.float()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_53": {
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "net_output.float()",
                            "Call"
                        ],
                        [
                            "encoder_out.float()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/models/fconv.py": {
        "torch": {
            "Embedding_556": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "dictionary.pad()",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_571": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ModuleList_157": {
                "variable": {
                    "value": "self.projections",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_158": {
                "variable": {
                    "value": "self.convolutions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_202": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_306": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x.view(sz[0] * sz[1], sz[2])",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ModuleList_368": {
                "variable": {
                    "value": "self.projections",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_369": {
                "variable": {
                    "value": "self.convolutions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_370": {
                "variable": {
                    "value": "self.attention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_428": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "weight_norm_574": {
                "module": {
                    "value": "m",
                    "type": "Call",
                    "possible_values": [
                        [
                            "nn.Embedding(num_embeddings, embedding_dim, padding_idx=padding_idx)",
                            "Call"
                        ],
                        [
                            "LearnedPositionalEmbedding(num_embeddings, embedding_dim, padding_idx)",
                            "Call"
                        ],
                        [
                            "nn.Linear(in_features, out_features)",
                            "Call"
                        ],
                        [
                            "LinearizedConvolution(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ],
                        [
                            "ConvTBC(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ]
                    ]
                }
            },
            "weight_norm_583": {
                "module": {
                    "value": "m",
                    "type": "Call",
                    "possible_values": [
                        [
                            "nn.Embedding(num_embeddings, embedding_dim, padding_idx=padding_idx)",
                            "Call"
                        ],
                        [
                            "LearnedPositionalEmbedding(num_embeddings, embedding_dim, padding_idx)",
                            "Call"
                        ],
                        [
                            "nn.Linear(in_features, out_features)",
                            "Call"
                        ],
                        [
                            "LinearizedConvolution(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ],
                        [
                            "ConvTBC(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "weight_norm_593": {
                "module": {
                    "value": "m",
                    "type": "Call",
                    "possible_values": [
                        [
                            "nn.Embedding(num_embeddings, embedding_dim, padding_idx=padding_idx)",
                            "Call"
                        ],
                        [
                            "LearnedPositionalEmbedding(num_embeddings, embedding_dim, padding_idx)",
                            "Call"
                        ],
                        [
                            "nn.Linear(in_features, out_features)",
                            "Call"
                        ],
                        [
                            "LinearizedConvolution(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ],
                        [
                            "ConvTBC(in_channels, out_channels, kernel_size, **kwargs)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_228": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glu_237": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_449": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glu_451": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_479": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_235": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "(self.in_projection(x) + target_embedding) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.bmm(x, encoder_out[0])",
                            "Call"
                        ],
                        [
                            "x.float().masked_fill(encoder_padding_mask.unsqueeze(1), float('-inf')).type_as(x)",
                            "Call"
                        ],
                        [
                            "F.softmax(x.view(sz[0] * sz[1], sz[2]), dim=1)",
                            "Call"
                        ],
                        [
                            "x.view(sz)",
                            "Call"
                        ],
                        [
                            "self.bmm(x, encoder_out[1])",
                            "Call"
                        ],
                        [
                            "x * (s * math.sqrt(1.0 / s))",
                            "BinOp"
                        ],
                        [
                            "x * (s * s.rsqrt())",
                            "BinOp"
                        ],
                        [
                            "(self.out_projection(x) + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self._embed_tokens(prev_output_tokens, incremental_state)",
                            "Call"
                        ],
                        [
                            "x + pos_embed",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "self._transpose_if_training(x, incremental_state)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, 0, padding_l, padding_r)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Linear_404": {
                "variable": {
                    "value": "self.fc3",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "out_embed_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "256",
                            "MethodArgument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "num_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                }
            },
            "weight_norm_501": {
                "variable": {
                    "value": "self.convolutions[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "module": {
                    "value": "conv",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "remove_weight_norm_500": {
                "module": {
                    "value": "conv",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Tensor_496": {}
        }
    },
    "fairseq/models/fconv_self_att.py": {
        "torch": {
            "Embedding_485": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "dictionary.pad()",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_498": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "ModuleList_172": {
                "variable": {
                    "value": "self.projections",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_173": {
                "variable": {
                    "value": "self.convolutions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_174": {
                "variable": {
                    "value": "self.attention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_175": {
                "variable": {
                    "value": "self.attproj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_194": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_308": {
                "variable": {
                    "value": "self.projections",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_309": {
                "variable": {
                    "value": "self.convolutions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_310": {
                "variable": {
                    "value": "self.attention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_311": {
                "variable": {
                    "value": "self.selfattention",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_312": {
                "variable": {
                    "value": "self.attproj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_385": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_426": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_214": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pad_217": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, 0, padding_l, padding_r)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "glu_219": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Sequential_349": {
                "variable": {
                    "value": "self.gate1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "Linear(out_embed_dim * 2, out_embed_dim)",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_350": {
                "variable": {
                    "value": "self.gate2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "Linear(out_embed_dim * 2, out_embed_dim)",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_352": {
                "variable": {
                    "value": "self.joining",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "Linear(out_embed_dim * 2, out_embed_dim * 2)",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_401": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "glu_403": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens) + self.embed_positions(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, padding_r))",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.unsqueeze(-1), 0)",
                            "Call"
                        ],
                        [
                            "GradMultiply.apply(x, 1.0 / (2.0 * self.num_attention_layers))",
                            "Call"
                        ],
                        [
                            "attention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens) + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc1(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "conv(x)",
                            "Call"
                        ],
                        [
                            "F.glu(x, dim=2)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x + r",
                            "BinOp"
                        ],
                        [
                            "self.fc3(x)",
                            "Call"
                        ],
                        [
                            "selfattention(x)",
                            "Call"
                        ],
                        [
                            "(x + residual) * math.sqrt(0.5)",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_433": {
                "variable": {
                    "value": "y",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[x, self.pretrained_outputs['out']]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cat_438": {
                "variable": {
                    "value": "fusion",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[gated_x1, gated_x2]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Sigmoid_349": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sigmoid_350": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GLU_355": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GLU_358": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/models/lightconv.py": {
        "torch": {
            "Embedding_653": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "Name",
                    "possible_values": [
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "dictionary.pad()",
                            "Call"
                        ],
                        [
                            "embed_tokens.padding_idx",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Linear_660": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "Name",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ModuleList_205": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_232": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_315": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_380": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_471": {
                "variable": {
                    "value": "self.layer_norms",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[LayerNorm(self.embed_dim) for _ in range(2)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "dropout_485": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.input_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_493": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_499": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.fc1(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_500": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.relu_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_502": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_594": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.input_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_600": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_629": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.fc1(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_630": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.relu_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_632": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "triu_425": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(tensor.new(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "triu_427": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(self._future_mask.resize_(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "GLU_447": {
                "variable": {
                    "value": "self.act",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GLU_535": {
                "variable": {
                    "value": "self.act",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_623": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_337": {
                "variable": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(len(dictionary), output_embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_410": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.embed_tokens.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_412": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_out)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "x.masked_fill(encoder_padding_mask.transpose(0, 1).unsqueeze(2), 0)",
                            "Call"
                        ],
                        [
                            "self.conv(x)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(0, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(1, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.input_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.linear1(x)",
                            "Call"
                        ],
                        [
                            "self.act(x)",
                            "Call"
                        ],
                        [
                            "self.conv(x, incremental_state=incremental_state)",
                            "Call"
                        ],
                        [
                            "self.linear2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.conv_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.relu(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.relu_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/models/lstm.py": {
        "torch": {
            "Embedding_473": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "len(task.source_dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "dictionary.pad()",
                            "Call"
                        ],
                        [
                            "dictionary.pad()",
                            "Call"
                        ]
                    ]
                }
            },
            "LSTM_480": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "input_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "LSTMCell_488": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_size": {
                    "value": "input_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "hidden_size": {
                    "value": "hidden_size",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "512",
                            "MethodArgument"
                        ],
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Linear_497": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dropout_223": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout_in",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pack_padded_sequence_229": {
                "variable": {
                    "value": "packed_x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "lengths": {
                    "value": "src_lengths.data.tolist()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pad_packed_sequence_241": {
                "variable": {
                    "value": "(x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "sequence": {
                    "value": "packed_outs",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "self.padding_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_242": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_300": {
                "variable": {
                    "value": "attn_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_scores",
                    "type": "Call",
                    "possible_values": [
                        [
                            "(source_hids * x.unsqueeze(0)).sum(dim=2)",
                            "Call"
                        ],
                        [
                            "attn_scores.float().masked_fill_(encoder_padding_mask, float('-inf')).type_as(attn_scores)",
                            "Call"
                        ],
                        [
                            "F.softmax(attn_scores, dim=0)",
                            "Call"
                        ],
                        [
                            "x.new_zeros(srclen, seqlen, bsz)",
                            "Call"
                        ],
                        [
                            "attn_scores.transpose(0, 2)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tanh_305": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.output_proj(torch.cat((x, input), dim=1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ModuleList_338": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[LSTMCell(input_size=hidden_size + embed_dim if layer == 0 else hidden_size, hidden_size=hidden_size) for layer in range(num_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "dropout_373": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout_in",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_428": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "outs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_395": {
                "variable": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(x[j, :, :], input_feed)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_413": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out",
                    "type": "Name",
                    "possible_values": [
                        [
                            "outs.view(self.num_layers, 2, bsz, -1).transpose(1, 2).contiguous()",
                            "Call"
                        ],
                        [
                            "hidden",
                            "Name"
                        ],
                        [
                            "F.dropout(out, p=self.dropout_out, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_402": {
                "variable": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "hidden",
                    "type": "Variable",
                    "possible_values": []
                },
                "p": {
                    "value": "self.dropout_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_443": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_445": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(src_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.input_proj(input)",
                            "Call"
                        ],
                        [
                            "(attn_scores.unsqueeze(2) * source_hids).sum(dim=0)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.output_proj(torch.cat((x, input), dim=1)))",
                            "Call"
                        ],
                        [
                            "self.embed_tokens(prev_output_tokens)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_in, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "torch.cat(outs, dim=0).view(seqlen, bsz, self.hidden_size)",
                            "Call"
                        ],
                        [
                            "x.transpose(1, 0)",
                            "Call"
                        ],
                        [
                            "self.additional_fc(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout_out, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.fc_out(x)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.embed_tokens.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cat_305": {
                "tensors": {
                    "value": "(x, input)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/models/masked_lm.py": {
        "torch": {
            "Linear_168": {
                "variable": {
                    "value": "self.masked_lm_pooler",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_173": {
                "variable": {
                    "value": "self.lm_head_transform_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_179": {
                "variable": {
                    "value": "self.lm_output_learned_bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.zeros(self.vocab_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_229": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inner_states[-1].transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(self.activation_fn(self.lm_head_transform_weight(x)))",
                            "Call"
                        ],
                        [
                            "F.linear(x, self.sentence_encoder.embed_tokens.weight)",
                            "Call"
                        ],
                        [
                            "self.embed_out(x)",
                            "Call"
                        ],
                        [
                            "x + self.lm_output_learned_bias",
                            "BinOp"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.sentence_encoder.embed_tokens.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_182": {
                "variable": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_189": {
                "variable": {
                    "value": "self.sentence_projection_layer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "args.encoder_embed_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.sentence_out_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_179": {
                "*size": {
                    "value": "self.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/models/transformer.py": {
        "torch": {
            "Embedding_1938": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "num_embeddings",
                    "type": "Call",
                    "possible_values": [
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ],
                        [
                            "len(dictionary)",
                            "Call"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "dictionary.pad()",
                            "Call"
                        ],
                        [
                            "dictionary.pad()",
                            "Call"
                        ],
                        [
                            "dictionary.pad()",
                            "Call"
                        ],
                        [
                            "embed_tokens.padding_idx",
                            "Attribute"
                        ],
                        [
                            "embed_tokens.padding_idx",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Linear_1945": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "Name",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ModuleList_522": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_552": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_657": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_687": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_802": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_887": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_1012": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_1090": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1246": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1253": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1255": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1354": {
                "variable": {
                    "value": "x1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1355": {
                "variable": {
                    "value": "x2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x2, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x2, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1363": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1365": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1513": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1553": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1555": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1706": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1746": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1748": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1873": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1916": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1918": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "triu_939": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(tensor.new(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "triu_941": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(self._future_mask.resize_(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "triu_1142": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(tensor.new(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "triu_1144": {
                "variable": {
                    "value": "self._future_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "utils.fill_with_neg_inf(self._future_mask.resize_(dim, dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_1544": {
                "variable": {
                    "value": "x1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1545": {
                "variable": {
                    "value": "x2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x2, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x2, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_1737": {
                "variable": {
                    "value": "x1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "F.dropout(x1, p=self.dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_831": {
                "variable": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(len(dictionary), self.output_embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_1034": {
                "variable": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(len(dictionary), self.output_embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_1897": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "x + positions",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(src_tokens)",
                            "BinOp"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "layer(x, encoder_padding_mask, bert_encoder_out['bert_encoder_out'], bert_encoder_out['bert_encoder_padding_mask'])",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.output_layer(x)",
                            "Call"
                        ],
                        [
                            "self.embed_scale * self.embed_tokens(prev_output_tokens)",
                            "BinOp"
                        ],
                        [
                            "self.project_in_dim(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.layer_norm(x)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "self.project_out_dim(x)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + ratios[0] * x1 + ratios[1] * x2",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "residual + x1",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.encoder_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.self_attn_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(self.final_layer_norm, x, after=True)",
                            "Call"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, before=True)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.maybe_layer_norm(layer_norm, x, after=True)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_924": {
                "input": {
                    "value": "features",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.embed_tokens.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_926": {
                "input": {
                    "value": "features",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_1127": {
                "input": {
                    "value": "features",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.embed_tokens.weight",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_1129": {
                "input": {
                    "value": "features",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.embed_out",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Tensor_617": {},
            "Tensor_752": {},
            "Tensor_967": {},
            "Tensor_1170": {}
        }
    },
    "fairseq/modules/adaptive_input.py": {
        "torch": {
            "ModuleList_38": {
                "variable": {
                    "value": "self.embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_43": {
                "variable": {
                    "value": "seq",
                    "type": "Variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Embedding(size, dim, padding_idx)",
                    "type": null,
                    "possible_values": []
                }
            },
            "Embedding_44": {
                "num_embeddings": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.cutoff[i] - prev",
                            "BinOp"
                        ]
                    ]
                },
                "embedding_dim": {
                    "value": "dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(initial_dim // factor ** i)",
                            "Call"
                        ]
                    ]
                },
                "padding_idx": {
                    "value": "padding_idx",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Linear_45": {
                "in_features": {
                    "value": "dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(initial_dim // factor ** i)",
                            "Call"
                        ]
                    ]
                },
                "out_features": {
                    "value": "output_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/adaptive_softmax.py": {
        "torch": {
            "Linear_39": {
                "variable": {
                    "value": "self.class_proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "input_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_classes",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LogSoftmax_76": {
                "variable": {
                    "value": "self.lsm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ModuleList_94": {
                "variable": {
                    "value": "self.tail",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "dropout_159": {
                "variable": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "input.contiguous().view(-1, input.size(-1))",
                            "Call"
                        ],
                        [
                            "F.dropout(input, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "input.contiguous().view(-1, dim)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "linear_23": {
                "input": {
                    "value": "input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "input.contiguous().view(-1, input.size(-1))",
                            "Call"
                        ],
                        [
                            "F.dropout(input, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "input.contiguous().view(-1, dim)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "self.weight.t() if self.transpose else self.weight",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Sequential_34": {
                "variable": {
                    "value": "self.word_proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "nn.Linear(input_dim, emb_dim, bias=False)",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_81": {
                "variable": {
                    "value": "self.head",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "input_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "cutoff[0] + len(cutoff) - 1",
                            "BinOp"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Sequential_109": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "proj",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_107": {
                "variable": {
                    "value": "proj",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.input_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.input_dim // self.factor ** (i + 1))",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_35": {
                "in_features": {
                    "value": "input_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "emb_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_105": {
                "variable": {
                    "value": "proj",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "tied_proj.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "out_features": {
                    "value": "tied_proj.size(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Dropout_111": {
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_112": {
                "in_features": {
                    "value": "dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.input_dim // self.factor ** (i + 1))",
                            "Call"
                        ]
                    ]
                },
                "out_features": {
                    "value": "self.cutoff[i + 1] - self.cutoff[i]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/beamable_mm.py": {
        "torch": {
            "mm_41": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input1[0, :, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mat2": {
                    "value": "input2[0, :, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/character_token_embedder.py": {
        "torch": {
            "Embedding_38": {
                "variable": {
                    "value": "self.char_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "257",
                    "type": "Constant",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "char_embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Parameter_39": {
                "variable": {
                    "value": "self.symbol_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.FloatTensor(2, word_embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ModuleList_43": {
                "variable": {
                    "value": "self.convolutions",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_53": {
                "variable": {
                    "value": "self.projection",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "last_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sum((f[1] for f in filters))",
                            "Call"
                        ]
                    ]
                },
                "out_features": {
                    "value": "word_embed_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "cat_154": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "conv_result",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "max_150": {
                "variable": {
                    "value": "(x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "conv(char_embs)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "torch.cat(conv_result, dim=-1)",
                            "Call"
                        ],
                        [
                            "self.highway(x)",
                            "Call"
                        ],
                        [
                            "self.projection(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_151": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "conv(char_embs)",
                            "Call"
                        ],
                        [
                            "F.relu(x)",
                            "Call"
                        ],
                        [
                            "torch.cat(conv_result, dim=-1)",
                            "Call"
                        ],
                        [
                            "self.highway(x)",
                            "Call"
                        ],
                        [
                            "self.projection(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_124": {
                "variable": {
                    "value": "word_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "pads.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "word_embs.new_zeros(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "word_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._convolve(chars)",
                            "Call"
                        ],
                        [
                            "torch.where(pads.unsqueeze(1), word_embs.new_zeros(1), word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(eos.unsqueeze(1), self.symbol_embeddings[self.eos_idx], word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(unk.unsqueeze(1), self.symbol_embeddings[self.unk_idx], word_embs)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_126": {
                "variable": {
                    "value": "word_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "eos.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.symbol_embeddings[self.eos_idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "word_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._convolve(chars)",
                            "Call"
                        ],
                        [
                            "torch.where(pads.unsqueeze(1), word_embs.new_zeros(1), word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(eos.unsqueeze(1), self.symbol_embeddings[self.eos_idx], word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(unk.unsqueeze(1), self.symbol_embeddings[self.unk_idx], word_embs)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_128": {
                "variable": {
                    "value": "word_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "unk.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.symbol_embeddings[self.unk_idx]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "word_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._convolve(chars)",
                            "Call"
                        ],
                        [
                            "torch.where(pads.unsqueeze(1), word_embs.new_zeros(1), word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(eos.unsqueeze(1), self.symbol_embeddings[self.eos_idx], word_embs)",
                            "Call"
                        ],
                        [
                            "torch.where(unk.unsqueeze(1), self.symbol_embeddings[self.unk_idx], word_embs)",
                            "Call"
                        ]
                    ]
                }
            },
            "Conv1d_46": {
                "in_channels": {
                    "value": "char_embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_channels": {
                    "value": "out_c",
                    "type": "Variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "width",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "where_109": {
                "variable": {
                    "value": "chars",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "eos.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "chars.new_zeros(1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "chars",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vocab[i].encode()",
                            "Call"
                        ],
                        [
                            "input.view(-1, self.max_char_len)",
                            "Call"
                        ],
                        [
                            "self.word_to_char[flat_words.type_as(self.word_to_char)].type_as(input)",
                            "Call"
                        ],
                        [
                            "torch.where(eos.unsqueeze(1), chars.new_zeros(1), chars)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/modules/conv_tbc.py": {
        "torch": {
            "Parameter_25": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(self.kernel_size[0], in_channels, out_channels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_27": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(out_channels)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/downsampled_multihead_attention.py": {
        "torch": {
            "Linear_244": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Sequential_54": {
                "variable": {
                    "value": "self.in_proj_k",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*k_layers",
                    "type": null,
                    "possible_values": []
                }
            },
            "Sequential_55": {
                "variable": {
                    "value": "self.in_proj_v",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "*v_layers",
                    "type": null,
                    "possible_values": []
                }
            },
            "bmm_108": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "q",
                    "type": "Call",
                    "possible_values": [
                        [
                            "query",
                            "Name"
                        ],
                        [
                            "self.in_proj_q(q)",
                            "Call"
                        ],
                        [
                            "q * self.scaling",
                            "BinOp"
                        ],
                        [
                            "q.view(tgt_len, size, self.head_dim)",
                            "Call"
                        ],
                        [
                            "q.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "k.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_138": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + torch.triu(attn_weights.data.new([-math.inf]).expand(tgt_len, tgt_len).clone(), diagonal=0)[:, ::self.head_index + 1 if self.downsample else 1].unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "scalar_bias(attn_weights, 2)",
                            "Call"
                        ],
                        [
                            "F.softmax(attn_weights, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, 1, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), -math.inf)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "dropout_139": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + torch.triu(attn_weights.data.new([-math.inf]).expand(tgt_len, tgt_len).clone(), diagonal=0)[:, ::self.head_index + 1 if self.downsample else 1].unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "scalar_bias(attn_weights, 2)",
                            "Call"
                        ],
                        [
                            "F.softmax(attn_weights, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, 1, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), -math.inf)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bmm_141": {
                "variable": {
                    "value": "attn",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + torch.triu(attn_weights.data.new([-math.inf]).expand(tgt_len, tgt_len).clone(), diagonal=0)[:, ::self.head_index + 1 if self.downsample else 1].unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "scalar_bias(attn_weights, 2)",
                            "Call"
                        ],
                        [
                            "F.softmax(attn_weights, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, 1, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), -math.inf)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "mat2": {
                    "value": "v",
                    "type": "Call",
                    "possible_values": [
                        [
                            "value",
                            "Name"
                        ],
                        [
                            "self.in_proj_v(v)",
                            "Call"
                        ],
                        [
                            "v.view(src_len, size, self.head_dim)",
                            "Call"
                        ],
                        [
                            "v.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "scalar_bias(v, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "weight_norm_247": {
                "module": {
                    "value": "m",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nn.Linear(in_features, out_features, bias=bias)",
                            "Call"
                        ]
                    ]
                }
            },
            "Sequential_252": {
                "*args": {
                    "value": "Linear(in_features, out_features * 4, dropout, bias)",
                    "type": null,
                    "possible_values": []
                }
            },
            "cat_214": {
                "variable": {
                    "value": "full_attn",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "attn",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(attn_weights, v)",
                            "Call"
                        ],
                        [
                            "attn.transpose(0, 1).contiguous().view(tgt_len, bsz, self.head_dim)",
                            "Call"
                        ],
                        [
                            "attn.transpose(0, 1).contiguous().view(tgt_len, bsz, self.embed_dim)",
                            "Call"
                        ],
                        [
                            "self.out_proj(attn)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_223": {
                "variable": {
                    "value": "full_attn",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "attn",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(attn_weights, v)",
                            "Call"
                        ],
                        [
                            "attn.transpose(0, 1).contiguous().view(tgt_len, bsz, self.head_dim)",
                            "Call"
                        ],
                        [
                            "attn.transpose(0, 1).contiguous().view(tgt_len, bsz, self.embed_dim)",
                            "Call"
                        ],
                        [
                            "self.out_proj(attn)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_224": {
                "variable": {
                    "value": "full_attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + torch.triu(attn_weights.data.new([-math.inf]).expand(tgt_len, tgt_len).clone(), diagonal=0)[:, ::self.head_index + 1 if self.downsample else 1].unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "scalar_bias(attn_weights, 2)",
                            "Call"
                        ],
                        [
                            "F.softmax(attn_weights, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, 1, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), -math.inf)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(size, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "GLU_254": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GLU_256": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "unsqueeze_112": {
                "input": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "unsqueeze_116": {
                "input": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tril_112": {
                "input": {
                    "value": "attn_weights.data.new([1]).expand(tgt_len, tgt_len).clone()",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "triu_116": {
                "input": {
                    "value": "attn_weights.data.new([-math.inf]).expand(tgt_len, tgt_len).clone()",
                    "type": "Call",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/dynamic_convolution.py": {
        "torch": {
            "Linear_17": {
                "variable": {
                    "value": "m",
                    "type": "Variable",
                    "possible_values": []
                },
                "in_features": {
                    "value": "in_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "out_features",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "dropout_151": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, K - T, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bmm_153": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_unfold",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.cat([input_buffer, x.unsqueeze(3)], dim=3)",
                            "Call"
                        ],
                        [
                            "unfold1d(x, K, padding_l, 0)",
                            "Call"
                        ],
                        [
                            "x_unfold.view(T * B * H, R, K)",
                            "Call"
                        ],
                        [
                            "x_unfold.view(T * B * H, R, -1)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "weight.unsqueeze(2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "bmm_200": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight_expanded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "weight.new(B * H, T, T + K - 1).fill_(float('-inf'))",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, self.padding_l, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight_expanded, dim=2)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight_expanded, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.new_zeros(B * H, T, T + K - 1, requires_grad=False)",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, P, T)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, 0, self.input_size).contiguous()",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, 0, self.input_size).contiguous()",
                            "Call"
                        ],
                        [
                            "x.view(T, B * H, R).transpose(0, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Parameter_67": {
                "variable": {
                    "value": "self.conv_bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(input_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_127": {
                "variable": {
                    "value": "x_unfold",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[input_buffer, x.unsqueeze(3)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_141": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, K - T, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_149": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, K - T, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_176": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, K - T, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_187": {
                "variable": {
                    "value": "weight_expanded",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight_expanded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "weight.new(B * H, T, T + K - 1).fill_(float('-inf'))",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, self.padding_l, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight_expanded, dim=2)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight_expanded, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.new_zeros(B * H, T, T + K - 1, requires_grad=False)",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, P, T)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dropout_188": {
                "variable": {
                    "value": "weight_expanded",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight_expanded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "weight.new(B * H, T, T + K - 1).fill_(float('-inf'))",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, self.padding_l, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight_expanded, dim=2)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight_expanded, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.new_zeros(B * H, T, T + K - 1, requires_grad=False)",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, P, T)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inplace": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_175": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, K - T, T)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "proj.narrow(2, self.input_size, H * K).contiguous().view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "self.weight_linear(query).view(T * B * H, -1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(1, 0, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "F.softmax(weight, dim=1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training, inplace=False)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/gelu.py": {
        "torch": {
            "tanh_20": {
                "input": {
                    "value": "gelu_accurate._a * (x + 0.044715 * torch.pow(x, 3))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "erf_24": {
                "input": {
                    "value": "x / math.sqrt(2.0)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pow_20": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "exponent": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/grad_multiply.py": {
        "torch": {}
    },
    "fairseq/modules/highway.py": {
        "torch": {
            "ModuleList_26": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[nn.Linear(input_dim, input_dim * 2) for _ in range(num_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ReLU_28": {
                "variable": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_52": {
                "variable": {
                    "value": "gate",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "gate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.sigmoid(gate)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_26": {
                "in_features": {
                    "value": "input_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "input_dim * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/layer_norm.py": {
        "torch": {
            "LayerNorm_18": {
                "normalized_shape": {
                    "value": "normalized_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "eps": {
                    "value": "eps",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1e-05",
                            "MethodArgument"
                        ]
                    ]
                },
                "elementwise_affine": {
                    "value": "elementwise_affine",
                    "type": "Name",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "is_available_12": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/learned_positional_embedding.py": {
        "torch": {}
    },
    "fairseq/modules/lightweight_convolution.py": {
        "torch": {
            "Parameter_47": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(num_heads, 1, kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_73": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "F.softmax(weight, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous().view(T * B * H, K, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv1d_79": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input.view(-1, H, T)",
                            "Call"
                        ]
                    ]
                },
                "weight": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "F.softmax(weight, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous().view(T * B * H, K, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "groups": {
                    "value": "self.num_heads",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Parameter_117": {
                "variable": {
                    "value": "self.weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(num_heads, 1, kernel_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_184": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "F.softmax(weight, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous().view(T * B * H, K, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bmm_185": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x_unfold",
                    "type": "Call",
                    "possible_values": [
                        [
                            "unfold1d(x, self.kernel_size, self.padding_l, 0)",
                            "Call"
                        ],
                        [
                            "x_unfold.view(T * B * H, R, K)",
                            "Call"
                        ],
                        [
                            "torch.cat([input_buffer, x.unsqueeze(3)], dim=3)",
                            "Call"
                        ],
                        [
                            "x_unfold.view(T * B * H, R, -1)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "F.softmax(weight, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous().view(T * B * H, K, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_214": {
                "variable": {
                    "value": "weight_expanded",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight_expanded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "weight.new_zeros(B * H, T, T + K - 1, requires_grad=False)",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, P, T)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight_expanded, self.weight_dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.weight_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bmm_216": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight_expanded",
                    "type": "Call",
                    "possible_values": [
                        [
                            "weight.new_zeros(B * H, T, T + K - 1, requires_grad=False)",
                            "Call"
                        ],
                        [
                            "weight_expanded.narrow(2, P, T)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight_expanded, self.weight_dropout, training=self.training)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "x",
                    "type": "Name",
                    "possible_values": [
                        [
                            "x.view(T, B * H, R).transpose(0, 1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Parameter_50": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(input_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_71": {
                "variable": {
                    "value": "weight",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.weight",
                            "Attribute"
                        ],
                        [
                            "F.softmax(weight, dim=-1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight[:, -x_unfold.size(2):]",
                            "Subscript"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous().view(T * B * H, K, 1)",
                            "Call"
                        ],
                        [
                            "F.dropout(weight, self.weight_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.weight.view(H, K)",
                            "Call"
                        ],
                        [
                            "utils.softmax(weight, dim=1, onnx_trace=self.onnx_trace).type_as(weight)",
                            "Call"
                        ],
                        [
                            "weight.view(1, H, K).expand(T * B, H, K).contiguous()",
                            "Call"
                        ],
                        [
                            "weight.view(T, B * H, K).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "weight.narrow(2, K - T, T)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Parameter_119": {
                "variable": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(input_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_166": {
                "variable": {
                    "value": "x_unfold",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[input_buffer, x.unsqueeze(3)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/linearized_convolution.py": {
        "torch": {
            "linear_65": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input.view(bsz, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weight": {
                    "value": "weight",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._get_linearized_weight()",
                            "Call"
                        ],
                        [
                            "self.weight.transpose(2, 1).transpose(1, 0).contiguous()",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "no_grad_64": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/logsumexp_moe.py": {
        "torch": {
            "logsumexp_22": {
                "input": {
                    "value": "logp",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "-1",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/modules/mean_pool_gating_network.py": {
        "torch": {
            "Linear_25": {
                "variable": {
                    "value": "self.fc1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "embed_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Linear_27": {
                "variable": {
                    "value": "self.fc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_experts",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tanh_49": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.fc1(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sum_44": {
                "variable": {
                    "value": "ntokens",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "1 - encoder_padding_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mean_47": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder_out['encoder_out'].transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "encoder_out.clone()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "log_softmax_53": {
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.sum(encoder_out, dim=1) / ntokens.type_as(encoder_out)",
                            "BinOp"
                        ],
                        [
                            "torch.mean(encoder_out, dim=1)",
                            "Call"
                        ],
                        [
                            "torch.tanh(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "self.dropout(x)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_26": {
                "p": {
                    "value": "dropout",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "sum_45": {
                "input": {
                    "value": "encoder_out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder_out['encoder_out'].transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "encoder_out.clone()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/multihead_attention.py": {
        "torch": {
            "Linear_56": {
                "variable": {
                    "value": "self.out_proj",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "embed_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[:self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[self.embed_dim:2 * self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[2 * self.embed_dim:]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[start:end]",
                            "Subscript"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bmm_190": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "q",
                    "type": "Call",
                    "possible_values": [
                        [
                            "q * self.scaling",
                            "BinOp"
                        ],
                        [
                            "self.in_proj_q(query)",
                            "Call"
                        ],
                        [
                            "self.in_proj_q(query)",
                            "Call"
                        ],
                        [
                            "q.contiguous().view(tgt_len, bsz * self.num_heads, self.head_dim).transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "mat2": {
                    "value": "k.transpose(1, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_218": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + attn_mask",
                            "BinOp"
                        ],
                        [
                            "attn_weights.view(bsz, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "utils.softmax(attn_weights, dim=-1, onnx_trace=self.onnx_trace).type_as(attn_weights)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "torch.where(key_padding_mask.unsqueeze(1).unsqueeze(2), torch.Tensor([float('-Inf')]), attn_weights.float()).type_as(attn_weights)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), float('-inf'))",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz * self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.sum(dim=1) / self.num_heads",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bmm_220": {
                "variable": {
                    "value": "attn",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "torch.bmm(q, k.transpose(1, 2))",
                            "Call"
                        ],
                        [
                            "attn_weights + attn_mask",
                            "BinOp"
                        ],
                        [
                            "attn_weights.view(bsz, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "utils.softmax(attn_weights, dim=-1, onnx_trace=self.onnx_trace).type_as(attn_weights)",
                            "Call"
                        ],
                        [
                            "F.dropout(attn_weights, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "torch.where(key_padding_mask.unsqueeze(1).unsqueeze(2), torch.Tensor([float('-Inf')]), attn_weights.float()).type_as(attn_weights)",
                            "Call"
                        ],
                        [
                            "attn_weights.masked_fill(key_padding_mask.unsqueeze(1).unsqueeze(2), float('-inf'))",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz * self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.view(bsz, self.num_heads, tgt_len, src_len)",
                            "Call"
                        ],
                        [
                            "attn_weights.sum(dim=1) / self.num_heads",
                            "BinOp"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "mat2": {
                    "value": "v",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.in_proj_v(value)",
                            "Call"
                        ],
                        [
                            "self.in_proj_v(key)",
                            "Call"
                        ],
                        [
                            "torch.cat([v, self.bias_v.repeat(1, bsz, 1)])",
                            "Call"
                        ],
                        [
                            "v.contiguous().view(-1, bsz * self.num_heads, self.head_dim).transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "prev_value",
                            "Name"
                        ],
                        [
                            "torch.cat((prev_value, v), dim=1)",
                            "Call"
                        ],
                        [
                            "torch.cat([v, v.new_zeros((v.size(0), 1) + v.size()[2:])], dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Parameter_45": {
                "variable": {
                    "value": "self.in_proj_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(3 * embed_dim, embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_47": {
                "variable": {
                    "value": "self.k_proj_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(embed_dim, self.kdim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_48": {
                "variable": {
                    "value": "self.v_proj_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(embed_dim, self.vdim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_49": {
                "variable": {
                    "value": "self.q_proj_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(embed_dim, embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_52": {
                "variable": {
                    "value": "self.in_proj_bias",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(3 * embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_59": {
                "variable": {
                    "value": "self.bias_k",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, 1, embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Parameter_60": {
                "variable": {
                    "value": "self.bias_v",
                    "type": "Attribute",
                    "possible_values": []
                },
                "data": {
                    "value": "torch.Tensor(1, 1, embed_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_136": {
                "variable": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[k, self.bias_k.repeat(1, bsz, 1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_137": {
                "variable": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[v, self.bias_v.repeat(1, bsz, 1)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cat_182": {
                "variable": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[k, k.new_zeros((k.size(0), 1) + k.size()[2:])]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_183": {
                "variable": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[v, v.new_zeros((v.size(0), 1) + v.size()[2:])]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "linear_277": {
                "input": {
                    "value": "input",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weight",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.k_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.v_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.in_proj_weight",
                            "Attribute"
                        ],
                        [
                            "weight[start:end, :]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[:self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[self.embed_dim:2 * self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[2 * self.embed_dim:]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[start:end]",
                            "Subscript"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cat_139": {
                "variable": {
                    "value": "attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_141": {
                "variable": {
                    "value": "key_padding_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[key_padding_mask, key_padding_mask.new_zeros(key_padding_mask.size(0), 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_185": {
                "variable": {
                    "value": "attn_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[attn_mask, attn_mask.new_zeros(attn_mask.size(0), 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_187": {
                "variable": {
                    "value": "key_padding_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[key_padding_mask, torch.zeros(key_padding_mask.size(0), 1).type_as(key_padding_mask)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "where_203": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "key_padding_mask.unsqueeze(1).unsqueeze(2)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "torch.Tensor([float('-Inf')])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "attn_weights.float()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "linear_249": {
                "input": {
                    "value": "query",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "self.q_proj_weight",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "bias",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[:self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[self.embed_dim:2 * self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[2 * self.embed_dim:]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[start:end]",
                            "Subscript"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "linear_259": {
                "input": {
                    "value": "key",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weight",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.k_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.v_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.in_proj_weight",
                            "Attribute"
                        ],
                        [
                            "weight[start:end, :]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[:self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[self.embed_dim:2 * self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[2 * self.embed_dim:]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[start:end]",
                            "Subscript"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "linear_269": {
                "input": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "weight": {
                    "value": "weight",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.k_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.v_proj_weight",
                            "Attribute"
                        ],
                        [
                            "self.in_proj_weight",
                            "Attribute"
                        ],
                        [
                            "weight[start:end, :]",
                            "Subscript"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[:self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[self.embed_dim:2 * self.embed_dim]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[2 * self.embed_dim:]",
                            "Subscript"
                        ],
                        [
                            "self.in_proj_bias",
                            "Attribute"
                        ],
                        [
                            "bias[start:end]",
                            "Subscript"
                        ],
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cat_157": {
                "variable": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(prev_key, k)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_163": {
                "variable": {
                    "value": "v",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(prev_value, v)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_188": {
                "*size": {
                    "value": "key_padding_mask.size(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/positional_embedding.py": {
        "torch": {}
    },
    "fairseq/modules/scalar_bias.py": {
        "torch": {}
    },
    "fairseq/modules/sinusoidal_positional_embedding.py": {
        "torch": {
            "exp_47": {
                "variable": {
                    "value": "emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "torch.arange(half_dim, dtype=torch.float) * -emb",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cat_49": {
                "variable": {
                    "value": "emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[torch.sin(emb), torch.cos(emb)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_52": {
                "variable": {
                    "value": "emb",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "[emb, torch.zeros(num_embeddings, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_80": {
                "variable": {
                    "value": "embedding_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(bsz.view(1), seq_len.view(1), torch.LongTensor([-1]))",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "arange_48": {
                "start": {
                    "value": "num_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unsqueeze_48": {
                "input": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "arange_47": {
                "start": {
                    "value": "half_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "embedding_dim // 2",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.float",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_52": {
                "*size": {
                    "value": "num_embeddings",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sin_49": {
                "input": {
                    "value": "emb",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math.log(10000) / (half_dim - 1)",
                            "BinOp"
                        ],
                        [
                            "torch.exp(torch.arange(half_dim, dtype=torch.float) * -emb)",
                            "Call"
                        ],
                        [
                            "torch.arange(num_embeddings, dtype=torch.float).unsqueeze(1) * emb.unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "torch.cat([torch.sin(emb), torch.cos(emb)], dim=1).view(num_embeddings, -1)",
                            "Call"
                        ],
                        [
                            "torch.cat([emb, torch.zeros(num_embeddings, 1)], dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "cos_49": {
                "input": {
                    "value": "emb",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math.log(10000) / (half_dim - 1)",
                            "BinOp"
                        ],
                        [
                            "torch.exp(torch.arange(half_dim, dtype=torch.float) * -emb)",
                            "Call"
                        ],
                        [
                            "torch.arange(num_embeddings, dtype=torch.float).unsqueeze(1) * emb.unsqueeze(0)",
                            "BinOp"
                        ],
                        [
                            "torch.cat([torch.sin(emb), torch.cos(emb)], dim=1).view(num_embeddings, -1)",
                            "Call"
                        ],
                        [
                            "torch.cat([emb, torch.zeros(num_embeddings, 1)], dim=1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/modules/transformer_sentence_encoder.py": {
        "torch": {
            "Embedding_106": {
                "variable": {
                    "value": "self.embed_tokens",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.vocab_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "self.padding_idx",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ModuleList_131": {
                "variable": {
                    "value": "self.layers",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "[TransformerSentenceEncoderLayer(embedding_dim=self.embedding_dim, ffn_embedding_dim=ffn_embedding_dim, num_attention_heads=num_attention_heads, dropout=self.dropout, attention_dropout=attention_dropout, activation_dropout=activation_dropout, activation_fn=activation_fn, add_bias_kv=add_bias_kv, add_zero_attn=add_zero_attn, export=export) for _ in range(num_encoder_layers)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "dropout_185": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embed_tokens(tokens)",
                            "Call"
                        ],
                        [
                            "x * (1 - padding_mask.unsqueeze(-1).type_as(x))",
                            "BinOp"
                        ],
                        [
                            "self.emb_layer_norm(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ],
                        [
                            "x.transpose(0, 1)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Embedding_112": {
                "num_embeddings": {
                    "value": "self.num_segments",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/transformer_sentence_encoder_layer.py": {
        "torch": {
            "Linear_58": {
                "variable": {
                    "value": "self.fc1",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "ffn_embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Linear_59": {
                "variable": {
                    "value": "self.fc2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "ffn_embedding_dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.embedding_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_83": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.self_attn_layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.final_layer_norm(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_89": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.self_attn_layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.final_layer_norm(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.activation_dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_91": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.self_attn_layer_norm(x)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(self.fc1(x))",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.activation_dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "self.fc2(x)",
                            "Call"
                        ],
                        [
                            "F.dropout(x, p=self.dropout, training=self.training)",
                            "Call"
                        ],
                        [
                            "residual + x",
                            "BinOp"
                        ],
                        [
                            "self.final_layer_norm(x)",
                            "Call"
                        ]
                    ]
                },
                "p": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "training": {
                    "value": "self.training",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/modules/unfold.py": {
        "torch": {
            "pad_15": {
                "variable": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Call",
                    "possible_values": [
                        [
                            "F.pad(x, (0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l), value=pad_value)",
                            "Call"
                        ],
                        [
                            "x.as_strided((T, B, C, kernel_size), (B * C, C, 1, B * C))",
                            "Call"
                        ],
                        [
                            "x.unsqueeze(3)",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, 0, padding_l, kernel_size - 1 - padding_l)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "pad_value",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/optim/adadelta.py": {
        "torch": {}
    },
    "fairseq/optim/adafactor.py": {
        "torch": {
            "mul_128": {
                "input": {
                    "value": "r_factor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "(exp_avg_sq_row / exp_avg_sq_row.mean(dim=-1)).rsqrt_().unsqueeze(-1)",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "c_factor",
                    "type": "Name",
                    "possible_values": [
                        [
                            "exp_avg_sq_col.unsqueeze(-2).rsqrt()",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "zeros_like_159": {
                "variable": {
                    "value": "state[exp_avg]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "grad",
                    "type": "Name",
                    "possible_values": [
                        [
                            "p.grad.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_161": {
                "variable": {
                    "value": "state[exp_avg_sq_row]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "*size": {
                    "value": "grad_shape[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_162": {
                "variable": {
                    "value": "state[exp_avg_sq_col]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "*size": {
                    "value": "grad_shape[:-2] + grad_shape[-1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_164": {
                "variable": {
                    "value": "state[exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "grad",
                    "type": "Name",
                    "possible_values": [
                        [
                            "p.grad.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "rsqrt_197": {
                "input": {
                    "value": "exp_avg_sq",
                    "type": "Name",
                    "possible_values": [
                        [
                            "state['exp_avg_sq']",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "update",
                    "type": "Name",
                    "possible_values": [
                        [
                            "grad ** 2 + group['eps'][0]",
                            "BinOp"
                        ],
                        [
                            "exp_avg",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/optim/adagrad.py": {
        "torch": {}
    },
    "fairseq/optim/adam.py": {
        "torch": {
            "is_available_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_124": {
                "variable": {
                    "value": "state[exp_avg]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p_data_fp32",
                    "type": "Call",
                    "possible_values": [
                        [
                            "p.data.float()",
                            "Call"
                        ],
                        [
                            "p.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_126": {
                "variable": {
                    "value": "state[exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p_data_fp32",
                    "type": "Call",
                    "possible_values": [
                        [
                            "p.data.float()",
                            "Call"
                        ],
                        [
                            "p.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_283": {
                "variable": {
                    "value": "state[exp_avg]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p_data_fp32",
                    "type": "Call",
                    "possible_values": [
                        [
                            "p.data.float()",
                            "Call"
                        ],
                        [
                            "p.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_285": {
                "variable": {
                    "value": "state[exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p_data_fp32",
                    "type": "Call",
                    "possible_values": [
                        [
                            "p.data.float()",
                            "Call"
                        ],
                        [
                            "p.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_129": {
                "variable": {
                    "value": "state[max_exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p_data_fp32",
                    "type": "Call",
                    "possible_values": [
                        [
                            "p.data.float()",
                            "Call"
                        ],
                        [
                            "p.data.float()",
                            "Call"
                        ]
                    ]
                }
            },
            "max_148": {
                "input": {
                    "value": "max_exp_avg_sq",
                    "type": "Name",
                    "possible_values": [
                        [
                            "state['max_exp_avg_sq']",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "max_exp_avg_sq",
                    "type": "Name",
                    "possible_values": [
                        [
                            "state['max_exp_avg_sq']",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/optim/fairseq_optimizer.py": {
        "torch": {
            "clip_grad_norm__85": {
                "parameters": {
                    "value": "self.params",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_norm": {
                    "value": "max_norm",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/optim/fp16_optimizer.py": {
        "torch": {
            "Parameter_99": {
                "variable": {
                    "value": "fp32_params",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "fp32_params",
                    "type": "Call",
                    "possible_values": [
                        [
                            "params[0].new(0).float().new(total_param_size)",
                            "Call"
                        ],
                        [
                            "torch.nn.Parameter(fp32_params)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/optim/lamb.py": {
        "torch": {
            "zeros_like_111": {
                "variable": {
                    "value": "state[exp_avg]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_113": {
                "variable": {
                    "value": "state[exp_avg_sq]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "p.data",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/optim/lr_scheduler/reduce_lr_on_plateau.py": {
        "torch": {}
    },
    "fairseq/optim/nag.py": {
        "torch": {
            "zeros_like_81": {
                "variable": {
                    "value": "param_state[momentum_buffer]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "d_p",
                    "type": "Name",
                    "possible_values": [
                        [
                            "p.grad.data.float()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/optim/sgd.py": {
        "torch": {}
    },
    "fairseq/options.py": {
        "torch": {
            "device_count_272": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/search.py": {
        "torch": {
            "stack_163": {
                "variable": {
                    "value": "self.scores_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensors": {
                    "value": "scores_G",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "self.scores_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_164": {
                "variable": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensors": {
                    "value": "indices_G",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_165": {
                "variable": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensors": {
                    "value": "beams_G",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "topk_73": {
                "input": {
                    "value": "lprobs.view(bsz, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "k": {
                    "value": "min(beam_size * 2, lprobs.view(bsz, -1).size(1) - 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "(self.scores_buf, self.indices_buf)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "div_83": {
                "input": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "other": {
                    "value": "vocab_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_135": {
                "*size": {
                    "value": "lprobs[:, 0, :].size()",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "self.diversity_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multinomial_195": {
                "variable": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "probs_nopad.view(bsz, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "beam_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "replacement": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multinomial_202": {
                "variable": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "probs_nopad.view(bsz * beam_size, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_samples": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "replacement": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_214": {
                "input": {
                    "value": "probs_nopad",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lprobs_nopad.exp_()",
                            "Call"
                        ],
                        [
                            "probs_nopad.expand(bsz, beam_size, -1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "self.indices_buf.unsqueeze(-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "out": {
                    "value": "self.scores_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_224": {
                "variable": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "topk_indices.expand(bsz, beam_size, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "self.indices_buf.unsqueeze(-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_224": {
                "variable": {
                    "value": "self.indices_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "arange_236": {
                "variable": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "end": {
                    "value": "beam_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_144": {
                "variable": {
                    "value": "lprobs_g",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lprobs_g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lprobs[:, g::self.num_groups, :]",
                            "Subscript"
                        ],
                        [
                            "torch.add(lprobs_g, self.diversity_strength, self.diversity_buf.unsqueeze(1))",
                            "Call"
                        ],
                        [
                            "lprobs_g.contiguous()",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "self.diversity_strength",
                    "type": "Attribute",
                    "possible_values": []
                },
                "alpha": {
                    "value": "self.diversity_buf.unsqueeze(1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_239": {
                "input": {
                    "value": "scores[:, :, step - 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "self.beams_buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/sequence_generator.py": {
        "torch": {
            "arange_166": {
                "variable": {
                    "value": "new_order",
                    "type": "Variable",
                    "possible_values": []
                },
                "start": {
                    "value": "bsz",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_size[0]",
                            "Subscript"
                        ],
                        [
                            "new_bsz",
                            "Name"
                        ]
                    ]
                }
            },
            "arange_192": {
                "variable": {
                    "value": "cand_offsets",
                    "type": "Variable",
                    "possible_values": []
                },
                "start": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "end": {
                    "value": "cand_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2 * beam_size",
                            "BinOp"
                        ]
                    ]
                }
            },
            "no_grad_104": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ModuleList_569": {
                "variable": {
                    "value": "self.models",
                    "type": "Attribute",
                    "possible_values": []
                },
                "modules": {
                    "value": "models",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "no_grad_580": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_586": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_like_179": {
                "variable": {
                    "value": "partial_prefix_mask_buf",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "src_lengths",
                    "type": "Name",
                    "possible_values": [
                        [
                            "(src_tokens.ne(self.eos) & src_tokens.ne(self.pad)).long().sum(dim=1)",
                            "Call"
                        ],
                        [
                            "src_lengths[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "gather_514": {
                "variable": {
                    "value": "active_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cand_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.gather(probs_slice, dim=1, index=prefix_tokens[:, step].view(-1, 1)).view(-1, 1).repeat(1, cand_size)",
                            "Call"
                        ],
                        [
                            "cand_scores[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "scores[:, step].view(bsz, beam_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_495": {
                "input": {
                    "value": "eos_mask.type_as(cand_offsets) * cand_size",
                    "type": "BinOp",
                    "possible_values": []
                },
                "other": {
                    "value": "cand_offsets[:eos_mask.size(1)]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "out": {
                    "value": "active_mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "buffer('active_mask')",
                            "Call"
                        ]
                    ]
                }
            },
            "topk_504": {
                "input": {
                    "value": "active_mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "buffer('active_mask')",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "beam_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.beam_size",
                            "Attribute"
                        ],
                        [
                            "1",
                            "MethodArgument"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "largest": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "(_ignore, active_hypos)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "gather_510": {
                "input": {
                    "value": "cand_bbsz_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "cand_beams.add(bbsz_offsets)",
                            "Call"
                        ],
                        [
                            "cand_beams.add(bbsz_offsets)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "active_bbsz_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "buffer('active_bbsz_idx')",
                            "Call"
                        ],
                        [
                            "active_bbsz_idx.view(-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "index_select_523": {
                "input": {
                    "value": "tokens[:, :step + 1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_bbsz_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "buffer('active_bbsz_idx')",
                            "Call"
                        ],
                        [
                            "active_bbsz_idx.view(-1)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "tokens_buf[:, :step + 1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tokens.clone()",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_527": {
                "input": {
                    "value": "cand_indices",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prefix_tokens[:, step].view(-1, 1).repeat(1, cand_size)",
                            "Call"
                        ],
                        [
                            "cand_indices[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "tokens_buf.view(bsz, beam_size, -1)[:, :, step + 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "gather_536": {
                "input": {
                    "value": "cand_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.gather(probs_slice, dim=1, index=prefix_tokens[:, step].view(-1, 1)).view(-1, 1).repeat(1, cand_size)",
                            "Call"
                        ],
                        [
                            "cand_scores[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_hypos",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "scores_buf.view(bsz, beam_size, -1)[:, :, step]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "logsumexp_616": {
                "input": {
                    "value": "torch.stack(log_probs, dim=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "gather_378": {
                "variable": {
                    "value": "cand_scores",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "probs_slice",
                    "type": "Name",
                    "possible_values": [
                        [
                            "lprobs.view(bsz, -1, lprobs.size(-1))[:, 0, :]",
                            "Subscript"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "prefix_tokens[:, step].view(-1, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_386": {
                "variable": {
                    "value": "cand_beams",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "cand_indices",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prefix_tokens[:, step].view(-1, 1).repeat(1, cand_size)",
                            "Call"
                        ],
                        [
                            "cand_indices[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sort_422": {
                "input": {
                    "value": "lprobs[:, self.eos]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "descending": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "(eos_scores, eos_bbsz_idx)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "masked_select_442": {
                "input": {
                    "value": "cand_bbsz_idx[:, :beam_size]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "eos_mask[:, :beam_size]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "cand_indices.eq(self.eos)",
                            "Call"
                        ],
                        [
                            "eos_mask[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "eos_bbsz_idx",
                    "type": "Name",
                    "possible_values": [
                        [
                            "buffer('eos_bbsz_idx')",
                            "Call"
                        ]
                    ]
                }
            },
            "index_select_532": {
                "input": {
                    "value": "scores[:, :step]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_bbsz_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "buffer('active_bbsz_idx')",
                            "Call"
                        ],
                        [
                            "active_bbsz_idx.view(-1)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "scores_buf[:, :step]",
                    "type": "Call",
                    "possible_values": [
                        [
                            "scores.clone()",
                            "Call"
                        ],
                        [
                            "scores_buf.type_as(lprobs)",
                            "Call"
                        ]
                    ]
                }
            },
            "index_select_543": {
                "input": {
                    "value": "attn[:, :, :step + 2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "index": {
                    "value": "active_bbsz_idx",
                    "type": "Call",
                    "possible_values": [
                        [
                            "buffer('active_bbsz_idx')",
                            "Call"
                        ],
                        [
                            "active_bbsz_idx.view(-1)",
                            "Call"
                        ]
                    ]
                },
                "out": {
                    "value": "attn_buf[:, :, :step + 2]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "attn.clone()",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_616": {
                "tensors": {
                    "value": "log_probs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_394": {
                "variable": {
                    "value": "partial_prefix_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "*size": {
                    "value": "bsz",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_size[0]",
                            "Subscript"
                        ],
                        [
                            "new_bsz",
                            "Name"
                        ]
                    ]
                }
            },
            "masked_select_448": {
                "input": {
                    "value": "cand_scores[:, :beam_size]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "eos_mask[:, :beam_size]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "cand_indices.eq(self.eos)",
                            "Call"
                        ],
                        [
                            "eos_mask[batch_idxs]",
                            "Subscript"
                        ]
                    ]
                },
                "out": {
                    "value": "eos_scores",
                    "type": "Name",
                    "possible_values": [
                        [
                            "buffer('eos_scores', type_of=scores)",
                            "Call"
                        ],
                        [
                            "eos_scores / (step + 1) ** self.len_penalty",
                            "BinOp"
                        ]
                    ]
                }
            },
            "arange_323": {
                "start": {
                    "value": "batch_idxs.numel()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "arange_191": {
                "start": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "end": {
                    "value": "bsz",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_size[0]",
                            "Subscript"
                        ],
                        [
                            "new_bsz",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/sequence_scorer.py": {
        "torch": {
            "no_grad_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "is_tensor_82": {
                "obj": {
                    "value": "attn",
                    "type": "Name",
                    "possible_values": [
                        [
                            "decoder_out[1]",
                            "Subscript"
                        ],
                        [
                            "attn.data",
                            "Attribute"
                        ]
                    ]
                }
            }
        }
    },
    "fairseq/tasks/fairseq_task.py": {
        "torch": {
            "mul_241": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.mul(loss, torch.FloatTensor([rewrd]))",
                            "Call"
                        ],
                        [
                            "loss * 0",
                            "BinOp"
                        ]
                    ]
                },
                "other": {
                    "value": "torch.FloatTensor([rewrd])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "no_grad_250": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_255": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/tasks/language_modeling.py": {
        "torch": {
            "no_grad_227": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/tasks/multilingual_translation.py": {
        "torch": {
            "no_grad_271": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_284": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/tasks/translation_moe.py": {
        "torch": {
            "cat_150": {
                "variable": {
                    "value": "lprob_y",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "lprob_y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "get_lprob_y(encoder_out, prev_output_tokens_k)",
                            "Call"
                        ],
                        [
                            "torch.cat(lprob_y, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "softmax_170": {
                "variable": {
                    "value": "prob_z_xy",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lprob_yz",
                    "type": "Name",
                    "possible_values": [
                        [
                            "get_lprob_yz()",
                            "Call"
                        ],
                        [
                            "get_lprob_yz()",
                            "Call"
                        ],
                        [
                            "lprob_y",
                            "Name"
                        ],
                        [
                            "lprob_y + lprob_z.type_as(lprob_y)",
                            "BinOp"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "no_grad_201": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_207": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_168": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/trainer.py": {
        "torch": {
            "manual_seed_499": {
                "seed": {
                    "value": "seed",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.args.seed + self.get_num_updates()",
                            "BinOp"
                        ]
                    ]
                }
            },
            "is_available_42": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "no_grad_377": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "manual_seed_501": {
                "seed": {
                    "value": "seed",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.args.seed + self.get_num_updates()",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_device_capability_105": {
                "device": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_device_capability_113": {
                "device": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "empty_cache_399": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "fairseq/utils.py": {
        "torch": {
            "remainder_199": {
                "variable": {
                    "value": "index",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "range - num_pads",
                    "type": "BinOp",
                    "possible_values": []
                },
                "other": {
                    "value": "max_len",
                    "type": "Name",
                    "possible_values": [
                        [
                            "src_tokens.size(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "remainder_201": {
                "variable": {
                    "value": "index",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "range + num_pads",
                    "type": "BinOp",
                    "possible_values": []
                },
                "other": {
                    "value": "max_len",
                    "type": "Name",
                    "possible_values": [
                        [
                            "src_tokens.size(1)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_tensor_39": {
                "obj": {
                    "value": "maybe_tensor",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "Tensor_124": {
                "variable": {
                    "value": "embed_dict[pieces[0]]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "arange_179": {
                "start": {
                    "value": "max",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "buffered_arange.buf",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "norm_214": {
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "softmax_278": {
                "input": {
                    "value": "x.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "softmax_280": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_softmax_285": {
                "input": {
                    "value": "x.float()",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "log_softmax_287": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "dim": {
                    "value": "dim",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "torch.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cumsum_168": {
                "input": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tensor.ne(padding_idx).long()",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "generate.py": {
        "torch": {
            "is_available_40": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "interactive.py": {
        "torch": {
            "is_available_93": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "neural_layers.py": {
        "torch": {
            "device_37": {
                "variable": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "SGD_621": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "model.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "NLLLoss_630": {
                "variable": {
                    "value": "criterion",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "pad_sequence_652": {
                "variable": {
                    "value": "eval_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[0] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_inputs, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "pad_sequence_653": {
                "variable": {
                    "value": "eval_targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_targets",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[1] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_targets, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DataLoader_660": {
                "variable": {
                    "value": "loader",
                    "type": "Variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "torch_dataset",
                    "type": "Name",
                    "possible_values": [
                        [
                            "utils.TxtDataset(eval_inputs, eval_targets)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "2 if utils.getOSystPlateform() else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Dropout_63": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_65": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Embedding_69": {
                "variable": {
                    "value": "self.bert.embeddings.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "VOCAB_SIZE",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Embedding_94": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "GRU_95": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hidden_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_97": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "LogSoftmax_98": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_102": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "model(input_tensor, target_tensor)",
                            "Call"
                        ],
                        [
                            "self.embedding(input).view(1, 1, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ],
                        [
                            "torch.cat((embedded[0], attn_applied[0]), 1)",
                            "Call"
                        ],
                        [
                            "self.attn_combine(output).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(self.out(output[0]), dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Embedding_121": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_122": {
                "variable": {
                    "value": "self.attn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.max_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_123": {
                "variable": {
                    "value": "self.attn_combine",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_124": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.dropout_p",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRU_125": {
                "variable": {
                    "value": "self.birnn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hidden_size",
                    "type": null,
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "GRU_126": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hidden_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_127": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_134": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.relu(self.attn(torch.cat((embedded[0], hidden[0]), 1)))",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bmm_136": {
                "variable": {
                    "value": "attn_applied",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights.unsqueeze(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "mat2": {
                    "value": "encoder_outputs.unsqueeze(0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_139": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(embedded[0], attn_applied[0])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_142": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "model(input_tensor, target_tensor)",
                            "Call"
                        ],
                        [
                            "self.embedding(input).view(1, 1, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ],
                        [
                            "torch.cat((embedded[0], attn_applied[0]), 1)",
                            "Call"
                        ],
                        [
                            "self.attn_combine(output).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(self.out(output[0]), dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_softmax_150": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.out(output[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensor_274": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_283": {
                "variable": {
                    "value": "encoder_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "src",
                    "type": "Name",
                    "possible_values": [
                        [
                            "encoder_hidden.reshape([-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, int(max_length - src.size(0)))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mode": {
                    "value": "constant",
                    "type": "Constant",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "save_719": {
                "obj": {
                    "value": "model.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.model' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_available_37": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_47": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_78": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_85": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_109": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_154": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_256": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "relu_135": {
                "input": {
                    "value": "self.attn(torch.cat((embedded[0], hidden[0]), 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_147": {
                "input": {
                    "value": "bihidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hidden.repeat(2, 1, 1).view(2, 1, -1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_135": {
                "tensors": {
                    "value": "(embedded[0], hidden[0])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "rl_utils/reward.py": {
        "torch": {}
    },
    "rl_utils/sem_reward.py": {
        "torch": {}
    },
    "scripts/neural_layers - attn_birnn.py": {
        "torch": {
            "device_35": {
                "variable": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "pad_503": {
                "variable": {
                    "value": "encoder_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "src",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder_hidden.reshape([-1, 256])",
                            "Call"
                        ],
                        [
                            "encoder_hidden.reshape([-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, int(MAX_LENGTH - src.size(0)))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mode": {
                    "value": "constant",
                    "type": "Constant",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensor_506": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "SGD_591": {
                "variable": {
                    "value": "encoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "SGD_592": {
                "variable": {
                    "value": "decoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "decoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "NLLLoss_601": {
                "variable": {
                    "value": "criterion",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "pad_sequence_623": {
                "variable": {
                    "value": "eval_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[0] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_inputs, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "pad_sequence_624": {
                "variable": {
                    "value": "eval_targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_targets",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[1] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_targets, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DataLoader_631": {
                "variable": {
                    "value": "loader",
                    "type": "Variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "torch_dataset",
                    "type": "Name",
                    "possible_values": [
                        [
                            "utils.TxtDataset(eval_inputs, eval_targets)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "6",
                    "type": "Constant",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "drop_last": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "2 if utils.getOSystPlateform() else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Dropout_61": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_63": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Embedding_67": {
                "variable": {
                    "value": "self.bert.embeddings.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "VOCAB_SIZE",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Embedding_92": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "GRU_93": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hidden_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_95": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "LogSoftmax_96": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_100": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embedding(input).view(1, 1, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ],
                        [
                            "torch.cat((embedded[0], attn_applied[0]), 1)",
                            "Call"
                        ],
                        [
                            "self.attn_combine(output).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(self.out(output[0]), dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "Embedding_119": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_120": {
                "variable": {
                    "value": "self.attn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.max_length",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_121": {
                "variable": {
                    "value": "self.attn_combine",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dropout_122": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "self.dropout_p",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRU_123": {
                "variable": {
                    "value": "self.birnn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hidden_size",
                    "type": null,
                    "possible_values": []
                },
                "bidirectional": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "GRU_124": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "self.hidden_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_125": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "self.output_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_132": {
                "variable": {
                    "value": "attn_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "F.relu(self.attn(torch.cat((embedded[0], hidden[0]), 1)))",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bmm_134": {
                "variable": {
                    "value": "attn_applied",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "attn_weights.unsqueeze(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "mat2": {
                    "value": "encoder_outputs.unsqueeze(0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cat_137": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(embedded[0], attn_applied[0])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_140": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embedding(input).view(1, 1, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ],
                        [
                            "torch.cat((embedded[0], attn_applied[0]), 1)",
                            "Call"
                        ],
                        [
                            "self.attn_combine(output).unsqueeze(0)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "F.log_softmax(self.out(output[0]), dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_softmax_148": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.out(output[0])",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensor_272": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_281": {
                "variable": {
                    "value": "encoder_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "src",
                    "type": "Call",
                    "possible_values": [
                        [
                            "encoder_hidden.reshape([-1, 256])",
                            "Call"
                        ],
                        [
                            "encoder_hidden.reshape([-1, 256])",
                            "Call"
                        ]
                    ]
                },
                "pad": {
                    "value": "(0, 0, 0, int(max_length - src.size(0)))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "mode": {
                    "value": "constant",
                    "type": "Constant",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "save_694": {
                "obj": {
                    "value": "encoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.encoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "save_695": {
                "obj": {
                    "value": "decoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.decoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_available_35": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_45": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_76": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_83": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_107": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_152": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_254": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mul_573": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "Constant",
                    "possible_values": [
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss + trainBert(batch_input_item, batch_target_item, encoder, decoder, eval_pairs, input_lang, output_lang, encoder_optimizer, decoder_optimizer, criterion, teacher_forcing_ratio=teacher_forcing_ratio, rl=rl)",
                            "BinOp"
                        ],
                        [
                            "torch.mul(loss, torch.FloatTensor([reward_value]))",
                            "Call"
                        ],
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss / 6.0",
                            "BinOp"
                        ],
                        [
                            "loss_fct(logits.view(-1, self.num_labels), labels.view(-1))",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "torch.FloatTensor([reward_value])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "relu_133": {
                "input": {
                    "value": "self.attn(torch.cat((embedded[0], hidden[0]), 1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "mean_145": {
                "input": {
                    "value": "bihidden",
                    "type": "Name",
                    "possible_values": [
                        [
                            "hidden.repeat(2, 1, 1).view(2, 1, -1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdim": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_133": {
                "tensors": {
                    "value": "(embedded[0], hidden[0])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "scripts/neural_layers - original.py": {
        "torch": {
            "device_35": {
                "variable": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "tensor_452": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "SGD_518": {
                "variable": {
                    "value": "encoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "SGD_519": {
                "variable": {
                    "value": "decoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "decoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "NLLLoss_528": {
                "variable": {
                    "value": "criterion",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "pad_sequence_550": {
                "variable": {
                    "value": "eval_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[0] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_inputs, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "pad_sequence_551": {
                "variable": {
                    "value": "eval_targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "eval_targets",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tensors[1] for tensors in eval_tensors]",
                            "ListComp"
                        ],
                        [
                            "rnn_utils.pad_sequence(eval_targets, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DataLoader_558": {
                "variable": {
                    "value": "loader",
                    "type": "Variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "torch_dataset",
                    "type": "Name",
                    "possible_values": [
                        [
                            "utils.TxtDataset(eval_inputs, eval_targets)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "6",
                    "type": "Constant",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "num_workers": {
                    "value": "2 if utils.getOSystPlateform() else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "Dropout_61": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_63": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Embedding_67": {
                "variable": {
                    "value": "self.bert.embeddings.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "VOCAB_SIZE",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Embedding_92": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "GRU_93": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hidden_size",
                    "type": null,
                    "possible_values": []
                }
            },
            "Linear_94": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "LogSoftmax_95": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_99": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embedding(input).view(1, 1, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_226": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "save_615": {
                "obj": {
                    "value": "encoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.encoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "save_616": {
                "obj": {
                    "value": "decoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.decoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_available_35": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_45": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_76": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_83": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_105": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_208": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mul_497": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "Constant",
                    "possible_values": [
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss + trainBert(batch_input_item, batch_target_item, encoder, decoder, eval_pairs, input_lang, output_lang, encoder_optimizer, decoder_optimizer, criterion, teacher_forcing_ratio=teacher_forcing_ratio, rl=rl)",
                            "BinOp"
                        ],
                        [
                            "torch.mul(loss, torch.FloatTensor([reward_value]))",
                            "Call"
                        ],
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss / 6",
                            "BinOp"
                        ],
                        [
                            "loss_fct(logits.view(-1, self.num_labels), labels.view(-1))",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "torch.FloatTensor([reward_value])",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "scripts/neural_layers.v02.py": {
        "torch": {
            "device_38": {
                "variable": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": []
                },
                "type": {
                    "value": "cuda if torch.cuda.is_available() else cpu",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "manual_seed_36": {
                "seed": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensor_431": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "cat_432": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "(decoder_input, decoder_input, decoder_input, decoder_input, decoder_input, decoder_input)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "SGD_504": {
                "variable": {
                    "value": "encoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "encoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "SGD_505": {
                "variable": {
                    "value": "decoder_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "decoder.parameters()",
                    "type": "Call",
                    "possible_values": []
                },
                "lr": {
                    "value": "learning_rate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.01",
                            "MethodArgument"
                        ]
                    ]
                },
                "momentum": {
                    "value": "mom",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "NLLLoss_514": {
                "variable": {
                    "value": "criterion",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "pad_sequence_540": {
                "variable": {
                    "value": "input_tensors",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "input_tensors",
                    "type": "Name",
                    "possible_values": [
                        [
                            "rnn_utils.pad_sequence(input_tensors, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "pad_sequence_541": {
                "variable": {
                    "value": "target_tensors",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequences": {
                    "value": "target_tensors",
                    "type": "Name",
                    "possible_values": [
                        [
                            "rnn_utils.pad_sequence(target_tensors, batch_first=True, padding_value=0)",
                            "Call"
                        ]
                    ]
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "padding_value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DataLoader_546": {
                "variable": {
                    "value": "loader",
                    "type": "Variable",
                    "possible_values": []
                },
                "dataset": {
                    "value": "torch_dataset",
                    "type": "Name",
                    "possible_values": [
                        [
                            "utils.TxtDataset(input_tensors, target_tensors)",
                            "Call"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "6",
                    "type": "Constant",
                    "possible_values": []
                },
                "shuffle": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Dropout_64": {
                "variable": {
                    "value": "self.dropout",
                    "type": "Attribute",
                    "possible_values": []
                },
                "p": {
                    "value": "config.hidden_dropout_prob",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Linear_66": {
                "variable": {
                    "value": "self.classifier",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "config.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "out_features": {
                    "value": "num_labels",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Embedding_70": {
                "variable": {
                    "value": "self.bert.embeddings.word_embeddings",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "VOCAB_SIZE",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding_idx": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Embedding_102": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "GRU_104": {
                "variable": {
                    "value": "self.gru",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*args": {
                    "value": "hidden_size",
                    "type": null,
                    "possible_values": []
                },
                "batch_first": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Linear_106": {
                "variable": {
                    "value": "self.out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "hidden_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "out_features": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "LogSoftmax_107": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "relu_114": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.embedding(input).view(6, -1)",
                            "Call"
                        ],
                        [
                            "F.relu(output)",
                            "Call"
                        ],
                        [
                            "output.reshape([1, 6, 256])",
                            "Call"
                        ],
                        [
                            "self.softmax(self.out(output[0]))",
                            "Call"
                        ]
                    ]
                }
            },
            "tensor_243": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "data": {
                    "value": "[[utils.SOS_token]]",
                    "type": "List",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "save_634": {
                "obj": {
                    "value": "encoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.encoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "save_635": {
                "obj": {
                    "value": "decoder.state_dict()",
                    "type": "Call",
                    "possible_values": []
                },
                "f": {
                    "value": "savepath + '/%s.decoder' % stamp",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_available_38": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_48": {
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "CrossEntropyLoss_86": {
                "variable": {
                    "value": "loss_fct",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_93": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_130": {
                "*size": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "out": {
                    "value": "6",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.hidden_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Name",
                    "possible_values": [
                        [
                            "torch.device('cuda' if torch.cuda.is_available() else 'cpu')",
                            "Call"
                        ]
                    ]
                }
            },
            "no_grad_232": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "mul_483": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "loss",
                    "type": "Constant",
                    "possible_values": [
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss + trainBert(batch_input, batch_target, encoder, decoder, eval_pairs, input_lang, output_lang, encoder_optimizer, decoder_optimizer, criterion, teacher_forcing_ratio=teacher_forcing_ratio, rl=rl)",
                            "BinOp"
                        ],
                        [
                            "torch.mul(loss, torch.LongTensor([reward_value]))",
                            "Call"
                        ],
                        [
                            "0",
                            "Constant"
                        ],
                        [
                            "loss_fct(logits.view(-1, self.num_labels), labels.view(-1))",
                            "Call"
                        ]
                    ]
                },
                "other": {
                    "value": "torch.LongTensor([reward_value])",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "scripts/seq2seq - origine.py": {
        "torch": {
            "load_38": {
                "f": {
                    "value": "enc_path",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "load_40": {
                "f": {
                    "value": "dec_path",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "seq2seq.py": {
        "torch": {}
    },
    "transf_decoder.py": {
        "torch": {
            "Embedding_110": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "num_embeddings": {
                    "value": "output_lang.n_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "embedding_dim": {
                    "value": "d_model",
                    "type": "Name",
                    "possible_values": [
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "TransformerDecoderLayer_113": {
                "variable": {
                    "value": "decoder_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "d_model": {
                    "value": "d_model",
                    "type": "Name",
                    "possible_values": [
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                },
                "nhead": {
                    "value": "nhead",
                    "type": "Name",
                    "possible_values": [
                        [
                            "8",
                            "MethodArgument"
                        ]
                    ]
                },
                "dim_feedforward": {
                    "value": "dim_feedforward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "2048",
                            "MethodArgument"
                        ]
                    ]
                },
                "dropout": {
                    "value": "dropout",
                    "type": "Name",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "LayerNorm_114": {
                "variable": {
                    "value": "decoder_norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "normalized_shape": {
                    "value": "d_model",
                    "type": "Name",
                    "possible_values": [
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "TransformerDecoder_115": {
                "variable": {
                    "value": "self.decoder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decoder_layer": {
                    "value": "decoder_layer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nn.modules.TransformerDecoderLayer(d_model, nhead, dim_feedforward, dropout)",
                            "Call"
                        ]
                    ]
                },
                "num_layers": {
                    "value": "num_decoder_layers",
                    "type": "Name",
                    "possible_values": [
                        [
                            "6",
                            "MethodArgument"
                        ]
                    ]
                },
                "norm": {
                    "value": "decoder_norm",
                    "type": "Name",
                    "possible_values": [
                        [
                            "LayerNorm(d_model)",
                            "Call"
                        ]
                    ]
                }
            },
            "Linear_122": {
                "variable": {
                    "value": "self.linear",
                    "type": "Attribute",
                    "possible_values": []
                },
                "in_features": {
                    "value": "d_model",
                    "type": "Name",
                    "possible_values": [
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                },
                "out_features": {
                    "value": "output_lang.n_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LogSoftmax_123": {
                "variable": {
                    "value": "self.softmax",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "cat_192": {
                "variable": {
                    "value": "memories",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "memories",
                    "type": "Call",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "torch.cat(memories, dim=0)",
                            "Call"
                        ],
                        [
                            "memories.reshape([src_seq_len, src_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "load_225": {
                "f": {
                    "value": "model_path",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'./model/q-dev/%(model_name)s/%(model_name)s.model' % {'model_name': load_model_name}",
                            "BinOp"
                        ]
                    ]
                }
            },
            "triu_211": {
                "input": {
                    "value": "torch.ones(sz, sz)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_211": {
                "*size": {
                    "value": "sz",
                    "type": "Variable",
                    "possible_values": []
                },
                "out": {
                    "value": "sz",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    },
    "utils.py": {
        "torch": {
            "nonzero_391": {
                "variable": {
                    "value": "idxs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "tensor_248": {
                "data": {
                    "value": "indexes",
                    "type": "Name",
                    "possible_values": [
                        [
                            "indexesFromSentence(lang, sentence)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "torch.long",
                    "type": "Attribute",
                    "possible_values": []
                },
                "device": {
                    "value": "device",
                    "type": "Variable",
                    "possible_values": []
                }
            }
        }
    }
}