{
    "models/mixture_of_experts.py": {
        "tensorflow": {
            "reshape_14": {
                "variable": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(base, [-1, 1])",
                            "Call"
                        ],
                        [
                            "base",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_max_15": {
                "variable": {
                    "value": "max_repeat",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "repeats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "repeats",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tile_16": {
                "variable": {
                    "value": "tiled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(base, [-1, 1])",
                            "Call"
                        ],
                        [
                            "base",
                            "Method Argument"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, max_repeat]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sequence_mask_17": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "repeats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "repeats",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_max_28": {
                "variable": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "segment_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_lengths",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tile_29": {
                "variable": {
                    "value": "tiled_range",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.range(tf.size(segment_lengths, out_type=out_idx)), 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, max_length]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "top_k_37": {
                "variable": {
                    "value": "(top_k_values, expert_indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "gate_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gate_values in enumerate(top_k_gates)",
                            "Call"
                        ],
                        [
                            "gate_values",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "expert_top_k",
                    "type": "variable",
                    "possible_values": [
                        [
                            "expert_top_k",
                            "Method Argument"
                        ],
                        [
                            "expert_top_k",
                            "Method Argument"
                        ],
                        [
                            "expert_top_k",
                            "Method Argument"
                        ]
                    ]
                },
                "sorted": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_42": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[row_indices, to_col(expert_indices)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_6": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_embeddings_or_tensors",
                            "variable"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_7": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_embeddings_or_tensors",
                            "variable"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_8": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_embeddings_or_tensors",
                            "variable"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "boolean_mask_31": {
                "tensor": {
                    "value": "tiled_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(tf.range(tf.size(segment_lengths, out_type=out_idx)), 1), [1, max_length])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "tf.sequence_mask(segment_lengths, max_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scatter_nd_43": {
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([row_indices, to_col(expert_indices)], axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(indices, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "top_k_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.top_k(gate_values, k=expert_top_k, sorted=False)",
                            "Call"
                        ],
                        [
                            "to_vec(tf.nn.softmax(top_k_values, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(gate_values)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_62": {
                "variable": {
                    "value": "sequence_length",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "batch_normalization_110": {
                "variable": {
                    "value": "bn1",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "expert_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(all_input, row_indices)",
                            "Call"
                        ],
                        [
                            "expert_input",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dense_111": {
                "variable": {
                    "value": "dnn1",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "bn1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=expert_input)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "128",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_112": {
                "variable": {
                    "value": "dnn2",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "dnn1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(bn1, 128, activation='relu')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "dense_113": {
                "variable": {
                    "value": "dnn3",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "dnn2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(dnn1, 64, activation='relu')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "split_120": {
                "variable": {
                    "value": "top_k_gates",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "expert_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "top_k_per_row(gate_output, expert_top_k)",
                            "Call"
                        ],
                        [
                            "self.compute_main(features, gate_output + noise_output, self._expert_top_k)",
                            "Call"
                        ],
                        [
                            "expert_weights",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "self._num_experts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "scatter_nd_131": {
                "variable": {
                    "value": "scattered_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([row_indices, to_col(expert_indices)], axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(indices, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(logits, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(top_logits * expert_weights, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(scattered_logits * tf.expand_dims(expert_weights, axis=2), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self._num_experts, tf.shape(logits)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scatter_nd_133": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([row_indices, to_col(expert_indices)], axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(indices, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "tf.ones_like(indices[:, 0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, self._num_experts]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_142": {
                "variable": {
                    "value": "bottom_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reshape(tf.boolean_mask(bottom_logits, mask), [-1, 1, self._adv_bottom_k])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, self._expert_top_k, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_144": {
                "variable": {
                    "value": "top_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(top_logits, axis=2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self._adv_bottom_k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "gather_151": {
                "variable": {
                    "value": "parent",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "all_gate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gating_network(concat_gate_input)",
                            "Call"
                        ],
                        [
                            "all_gate_output",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "parent_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_vec(tf.where(tf.equal(segment_ids[:-1], segment_ids[1:])))",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_152": {
                "variable": {
                    "value": "child",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "all_gate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gating_network(concat_gate_input)",
                            "Call"
                        ],
                        [
                            "all_gate_output",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "parent_idx + 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_153": {
                "variable": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(parent - child)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "top_k_157": {
                "variable": {
                    "value": "(top_kp1, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "gate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gating_network(gate_input)",
                            "Call"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "self._expert_top_k + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_162": {
                "variable": {
                    "value": "threshold",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater_equal(gate_output, kth_values)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tile_width(top_kp1[:, self._expert_top_k])",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tile_width(top_kp1[:, self._expert_top_k - 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_169": {
                "variable": {
                    "value": "load_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "expert_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "top_k_per_row(gate_output, expert_top_k)",
                            "Call"
                        ],
                        [
                            "self.compute_main(features, gate_output + noise_output, self._expert_top_k)",
                            "Call"
                        ],
                        [
                            "expert_weights",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_186": {
                "variable": {
                    "value": "leaf_gate_output",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "all_gate_output + all_noise_output",
                    "type": "BinOp",
                    "possible_values": []
                },
                "indices": {
                    "value": "leaf_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_vec(tf.where(tf.concat([tf.not_equal(segment_ids[:-1], segment_ids[1:]), [True]], axis=0)))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_191": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "top_logits * expert_weights",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_210": {
                "variable": {
                    "value": "gate_input",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[v for (k, v) in gating_features.items()]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_217": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "scattered_logits * tf.expand_dims(expert_weights, axis=2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "repeat_12": {
                "input": {
                    "value": "base",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(base, [-1, 1])",
                            "Call"
                        ],
                        [
                            "base",
                            "Method Argument"
                        ]
                    ]
                },
                "repeats": {
                    "value": "repeats",
                    "type": "variable",
                    "possible_values": [
                        [
                            "repeats",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "axis",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_18": {
                "tensor": {
                    "value": "tiled",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(base, [1, max_repeat])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(repeats)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(indices, tf.ones_like(indices[:, 0]), [batch_size, self._num_experts])",
                            "Call"
                        ],
                        [
                            "self.compute_main(features, -leaf_gate_output, self._adv_bottom_k)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_29": {
                "input": {
                    "value": "tf.range(tf.size(segment_lengths, out_type=out_idx))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_32": {
                "lengths": {
                    "value": "segment_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "max_length",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(segment_lengths)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_36": {
                "input": {
                    "value": "gate_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gate_values in enumerate(top_k_gates)",
                            "Call"
                        ],
                        [
                            "gate_values",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "softmax_39": {
                "logits": {
                    "value": "top_k_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.top_k(gate_values, k=expert_top_k, sorted=False)",
                            "Call"
                        ],
                        [
                            "to_vec(tf.nn.softmax(top_k_values, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_40": {
                "input": {
                    "value": "tf.reshape(tf.range(batch_size), [-1, 1])",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, expert_top_k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_43": {
                "input": {
                    "value": "gate_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gate_values in enumerate(top_k_gates)",
                            "Call"
                        ],
                        [
                            "gate_values",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "to_float_48": {
                "x": {
                    "value": "tf.size(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_49": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_50": {
                "input_tensor": {
                    "value": "tf.squared_difference(x, mean)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_69": {
                "values": {
                    "value": "ret",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reduce_sum(tf.square(parent - child))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "axis",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "dense_99": {
                "variable": {
                    "value": "gating_net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "gate_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([v for (k, v) in gating_features.items()], axis=1)",
                            "Call"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "self._num_experts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "normal_105": {
                "variable": {
                    "value": "random_weight",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, self._num_experts]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_106": {
                "variable": {
                    "value": "noise_net",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "gate_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([v for (k, v) in gating_features.items()], axis=1)",
                            "Call"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ]
                    ]
                },
                "units": {
                    "value": "self._num_experts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "reduce_sum_173": {
                "variable": {
                    "value": "load_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.exlusive_top_k_prob(gate_output, noise_stddev)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_41": {
                "tensor": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "size_48": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "squared_difference_50": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(x) / float_size",
                            "BinOp"
                        ]
                    ]
                }
            },
            "square_51": {
                "x": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(x) / float_size",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_61": {
                "input": {
                    "value": "sparse_embeddings_or_tensors[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "erf_72": {
                "x": {
                    "value": "x / (tf.math.sqrt(2.0) * stddev + 1e-20)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_98": {
                "name_or_scope": {
                    "value": "gating_network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_103": {
                "input": {
                    "value": "gate_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([v for (k, v) in gating_features.items()], axis=1)",
                            "Call"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ],
                        [
                            "gate_input",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_104": {
                "name_or_scope": {
                    "value": "noise_network",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_118": {
                "input": {
                    "value": "all_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ]
                    ]
                }
            },
            "gather_126": {
                "variable": {
                    "value": "expert_input",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "all_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "features",
                            "variable"
                        ]
                    ]
                },
                "indices": {
                    "value": "row_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_col(tf.tile(tf.reshape(tf.range(batch_size), [-1, 1]), [1, expert_top_k]))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.greater(gate_values, 0))[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_130": {
                "values": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([row_indices, to_col(expert_indices)], axis=1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(indices, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ones_like_133": {
                "input": {
                    "value": "indices[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_138": {
                "name_or_scope": {
                    "value": "adversarial",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_142": {
                "tensor": {
                    "value": "tf.boolean_mask(bottom_logits, mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, 1, self._adv_bottom_k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_144": {
                "input": {
                    "value": "top_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tile(tf.expand_dims(top_logits, axis=2), [1, 1, self._adv_bottom_k])",
                            "Call"
                        ],
                        [
                            "top_logits",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_146": {
                "input_tensor": {
                    "value": "tf.square(top_logits - bottom_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_150": {
                "condition": {
                    "value": "tf.equal(segment_ids[:-1], segment_ids[1:])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "square_153": {
                "x": {
                    "value": "parent - child",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_161": {
                "input": {
                    "value": "to_col(t)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(gate_output)[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_equal_162": {
                "x": {
                    "value": "gate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gating_network(gate_input)",
                            "Call"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "kth_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_col(top_kp1[:, self._expert_top_k - 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "where_182": {
                "condition": {
                    "value": "tf.concat([tf.not_equal(segment_ids[:-1], segment_ids[1:]), [True]], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_189": {
                "tensor": {
                    "value": "tf.boolean_mask(t, top_mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1, self._expert_top_k]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "size_29": {
                "input": {
                    "value": "segment_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "segment_lengths",
                            "Method Argument"
                        ]
                    ]
                },
                "out_type": {
                    "value": "out_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.int32",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_124": {
                "name_or_scope": {
                    "value": "'expert_{}'.format(i)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_129": {
                "values": {
                    "value": "[row_indices, i * tf.ones_like(row_indices)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_142": {
                "tensor": {
                    "value": "bottom_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.compute_main(features, -leaf_gate_output, self._adv_bottom_k)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.reshape(tf.boolean_mask(bottom_logits, mask), [-1, 1, self._adv_bottom_k]), [1, self._expert_top_k, 1])",
                            "Call"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(repeats)",
                            "Call"
                        ],
                        [
                            "tf.scatter_nd(indices, tf.ones_like(indices[:, 0]), [batch_size, self._num_experts])",
                            "Call"
                        ],
                        [
                            "self.compute_main(features, -leaf_gate_output, self._adv_bottom_k)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_147": {
                "x": {
                    "value": "top_logits - bottom_logits",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "equal_150": {
                "x": {
                    "value": "segment_ids[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "segment_ids[1:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_182": {
                "values": {
                    "value": "[tf.not_equal(segment_ids[:-1], segment_ids[1:]), [True]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "boolean_mask_189": {
                "tensor": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sparse_embeddings_or_tensors",
                            "variable"
                        ],
                        [
                            "t",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "top_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.compute_main(features, leaf_gate_output, self._expert_top_k)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_193": {
                "params": {
                    "value": "noise_stddev",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.noise_network(concat_gate_input)",
                            "Call"
                        ],
                        [
                            "self.noise_network(gate_input)",
                            "Call"
                        ],
                        [
                            "noise_stddev",
                            "Method Argument"
                        ],
                        [
                            "noise_stddev",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "leaf_pos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_vec(tf.where(tf.concat([tf.not_equal(segment_ids[:-1], segment_ids[1:]), [True]], axis=0)))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_217": {
                "input": {
                    "value": "expert_weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "top_k_per_row(gate_output, expert_top_k)",
                            "Call"
                        ],
                        [
                            "self.compute_main(features, gate_output + noise_output, self._expert_top_k)",
                            "Call"
                        ],
                        [
                            "expert_weights",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_125": {
                "condition": {
                    "value": "tf.greater(gate_values, 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_132": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(logits, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(top_logits * expert_weights, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(scattered_logits * tf.expand_dims(expert_weights, axis=2), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_125": {
                "x": {
                    "value": "gate_values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gate_values in enumerate(top_k_gates)",
                            "Call"
                        ],
                        [
                            "gate_values",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_161": {
                "input": {
                    "value": "gate_output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.gating_network(gate_input)",
                            "Call"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ],
                        [
                            "gate_output",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "not_equal_183": {
                "x": {
                    "value": "segment_ids[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "segment_ids[1:]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sqrt_72": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ones_like_129": {
                "input": {
                    "value": "row_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_col(tf.tile(tf.reshape(tf.range(batch_size), [-1, 1]), [1, expert_top_k]))",
                            "Call"
                        ],
                        [
                            "tf.where(tf.greater(gate_values, 0))[:, 0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "models/model_lib.py": {
        "tensorflow": {}
    },
    "models/utils.py": {
        "tensorflow": {
            "cast_8": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_tensor",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sign_9": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(input_tensor, tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_9": {
                "x": {
                    "value": "tf.abs(y) + 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "SparseTensor_21": {
                "indices": {
                    "value": "x.indices",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "x_value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x.values",
                            "Attribute"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "get_capped_min_max_norm(x_log, fmin_log, fmax_log)",
                            "Call"
                        ]
                    ]
                },
                "dense_shape": {
                    "value": "x.dense_shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_4": {
                "x": {
                    "value": "fmin",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fmin",
                            "Method Argument"
                        ],
                        [
                            "fmin",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.minimum(tf.cast(x, tf.float32), fmax)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_4": {
                "x": {
                    "value": "tf.cast(x, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "fmax",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fmax",
                            "Method Argument"
                        ],
                        [
                            "fmax",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "abs_9": {
                "x": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(input_tensor, tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_4": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    }
}