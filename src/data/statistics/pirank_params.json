{
    "pirank_deep.py": {
        "tensorflow": {
            "enable_eager_execution_28": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "executing_eagerly_29": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_30": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_234": {
                "variable": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_with_default_235": {
                "variable": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(False)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cond_236": {
                "variable": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder_with_default(false_tensor, ())",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : tf.convert_to_tensor(tau, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.convert_to_tensor(taustar, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_243": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_244": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_245": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_247": {
                "variable": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(labels, taustar)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(P_true)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_v2_255": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(labels, taustar)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(P_true)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.log(P_hat + 1e-20)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_257": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits_v2(labels=P_true, logits=tf.log(P_hat + 1e-20), dim=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_258": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits_v2(labels=P_true, logits=tf.log(P_hat + 1e-20), dim=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_209": {
                "variable": {
                    "value": "input_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "example_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.layers.flatten(per_example_features[name]) for name in sorted(example_feature_columns())]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_219": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_layer",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(cur_layer, units=layer[0], activation=layer[1])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_280": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_label_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfr.utils.is_label_valid(labels)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(labels)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "where_281": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_label_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfr.utils.is_label_valid(labels)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_299": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "logits_exp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_300": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "labels_exp",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_309": {
                "variable": {
                    "value": "P_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, tau)",
                            "Call"
                        ],
                        [
                            "tf.identity(P_hat, name='P_hat')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "P_hat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_321": {
                "variable": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat[:, :top_k, :]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(phat_top, name='phat_top')",
                            "Call"
                        ],
                        [
                            "tf.concat(res, 2)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "phat_top",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Estimator_434": {
                "model_fn": {
                    "value": "tfr.model.make_groupwise_ranking_fn(group_score_fn=make_score_fn(), group_size=1, transform_fn=None, ranking_head=ranking_head)",
                    "type": "Call",
                    "possible_values": []
                },
                "params": {
                    "value": "hparams",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.training.HParams(learning_rate=learning_rate)",
                            "Call"
                        ]
                    ]
                },
                "config": {
                    "value": "tf.estimator.RunConfig(model_dir=model_dir, tf_random_seed=seed)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_random_seed_453": {
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TrainSpec_462": {
                "variable": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "EvalSpec_463": {
                "variable": {
                    "value": "vali_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "lambda : input_fn(vali_path, list_size=vali_list_size if vali_list_size else list_size)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "hooks": {
                    "value": "[hook_vali] if hook_vali else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "numeric_column_183": {
                "key": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "default_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "dense_213": {
                "variable": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_layer",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(cur_layer, units=layer[0], activation=layer[1])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "layer[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "parse_arch(hidden_layers)",
                            "Call"
                        ]
                    ]
                },
                "activation": {
                    "value": "layer[1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "parse_arch(hidden_layers)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_278": {
                "name": {
                    "value": "'merge_nr_scope_depth_{}'.format(depth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_293": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "list(logits)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "merged_logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_304": {
                "variable": {
                    "value": "P_hat_backward",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P_hat_backward",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "util.neuralsort(logits, tau)",
                            "Call"
                        ],
                        [
                            "tf.identity(P_hat_backward, name='P_hat_backward')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "P_hat_backward",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_326": {
                "variable": {
                    "value": "sorted_powers",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat[:, :top_k, :]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(phat_top, name='phat_top')",
                            "Call"
                        ],
                        [
                            "tf.concat(res, 2)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "label_powers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(2.0, tf.cast(labels, dtype=tf.float32), name='label_powers') - 1.0",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "sorted_powers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_327": {
                "variable": {
                    "value": "numerator",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sorted_powers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(phat_top, label_powers, name='sorted_powers')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_numerator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_328": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(1, ndcg_k + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_position",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_329": {
                "variable": {
                    "value": "denominator",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "position + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_denominator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_331": {
                "variable": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(dcg), tf.zeros_like(dcg), dcg)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_332": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "top_k_333": {
                "variable": {
                    "value": "(ideal_sorted_labels, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "ndcg_k",
                    "type": "variable",
                    "possible_values": []
                },
                "sorted": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_337": {
                "variable": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='ideal_dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(ideal_dcg), tf.ones_like(ideal_dcg), ideal_dcg)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "ideal_dcg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "where_338": {
                "variable": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_nan(dcg)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.zeros_like(dcg)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(dcg), tf.zeros_like(dcg), dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_339": {
                "variable": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.is_nan(ideal_dcg)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(ideal_dcg)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='ideal_dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(ideal_dcg), tf.ones_like(ideal_dcg), ideal_dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "identity_341": {
                "variable": {
                    "value": "ndcg",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ndcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(dcg) / (1e-10 + tf.reduce_sum(ideal_dcg))",
                            "BinOp"
                        ],
                        [
                            "tf.identity(ndcg, name='ndcg')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "ndcg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_344": {
                "variable": {
                    "value": "topk_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat[:, :top_k, :]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(phat_top, name='phat_top')",
                            "Call"
                        ],
                        [
                            "tf.concat(res, 2)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_347": {
                "variable": {
                    "value": "topk_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "topk_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(phat_top, logits)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(topk_logits)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(topk_logits, 2, name='topk_logits')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "topk_logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "flatten_206": {
                "structure": {
                    "value": "per_example_features[name]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stop_gradient_251": {
                "input": {
                    "value": "P_hat_forward - P_hat_backward",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_256": {
                "x": {
                    "value": "P_hat + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_280": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_296": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "phat_tops",
                    "type": "variable",
                    "possible_values": [
                        [
                            "list(phat_tops)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "merged_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_319": {
                "variable": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_346": {
                "variable": {
                    "value": "topk_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "topk_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(phat_top, logits)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(topk_logits)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(topk_logits, 2, name='topk_logits')",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_349": {
                "variable": {
                    "value": "topk_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "phat_top",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat[:, :top_k, :]",
                            "Subscript"
                        ],
                        [
                            "tf.identity(phat_top, name='phat_top')",
                            "Call"
                        ],
                        [
                            "tf.concat(res, 2)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_350": {
                "variable": {
                    "value": "topk_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "topk_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(phat_top, labels)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(topk_labels, 2, name='topk_labels')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "topk_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_441": {
                "model_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/tmp/model_{}'.format(ex.current_run._id)",
                            "Call"
                        ]
                    ]
                },
                "tf_random_seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "train_and_evaluate_470": {
                "estimator": {
                    "value": "ranker",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_estimator(hparams, model_dir=model_dir)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(**train_args)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "vali_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=lambda : input_fn(vali_path, list_size=vali_list_size if vali_list_size else list_size), hooks=[hook_vali] if hook_vali else None)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_162": {
                "dims": {
                    "value": "[list_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_237": {
                "value": {
                    "value": "tau",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tau ** depth if tau_scheme == 'square' else tau",
                            "IfExp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_239": {
                "value": {
                    "value": "taustar",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_282": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stop_gradient_306": {
                "input": {
                    "value": "P_hat_forward - P_hat_backward",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pow_325": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "label_powers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pow_334": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(ideal_sorted_labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "ideal_dcg_numerator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "is_nan_338": {
                "x": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(dcg), tf.zeros_like(dcg), dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_338": {
                "input": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(dcg), tf.zeros_like(dcg), dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_nan_339": {
                "x": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='ideal_dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(ideal_dcg), tf.ones_like(ideal_dcg), ideal_dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_339": {
                "input": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='ideal_dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(ideal_dcg), tf.ones_like(ideal_dcg), ideal_dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_340": {
                "input_tensor": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='ideal_dcg')",
                            "Call"
                        ],
                        [
                            "tf.where(tf.is_nan(ideal_dcg), tf.ones_like(ideal_dcg), ideal_dcg)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_global_step_425": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TensorShape_160": {
                "dims": {
                    "value": "[list_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_281": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True), name='logits')",
                            "Call"
                        ],
                        [
                            "tf.concat(list(logits), 1, name='merged_logits')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits_exp')",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_325": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y",
                            "variable"
                        ],
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels), name='labels')",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels_exp')",
                            "Call"
                        ],
                        [
                            "tf.concat(phat_tops, 1, name='merged_labels')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(labels, 2)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_334": {
                "x": {
                    "value": "ideal_sorted_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_318": {
                "a": {
                    "value": "phat_top[:, :, l:h]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "pt",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "pirank_simple.py": {
        "tensorflow": {
            "enable_eager_execution_20": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "executing_eagerly_21": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "set_verbosity_22": {
                "level": {
                    "value": "tf.logging.INFO",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_167": {
                "variable": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_with_default_168": {
                "variable": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(False)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(False)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cond_169": {
                "variable": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder_with_default(false_tensor, ())",
                            "Call"
                        ],
                        [
                            "tf.placeholder_with_default(false_tensor, ())",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : tf.convert_to_tensor(tau, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.convert_to_tensor(taustar, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_176": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_177": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_178": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stop_gradient_180": {
                "variable": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(labels, taustar)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(P_true)",
                            "Call"
                        ],
                        [
                            "util.neuralsort(labels, 1e-10)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_with_logits_v2_188": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(labels, taustar)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(P_true)",
                            "Call"
                        ],
                        [
                            "util.neuralsort(labels, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.log(P_hat + 1e-20)",
                    "type": "Call",
                    "possible_values": []
                },
                "dim": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_190": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits_v2(labels=P_true, logits=tf.log(P_hat + 1e-20), dim=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_191": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax_cross_entropy_with_logits_v2(labels=P_true, logits=tf.log(P_hat + 1e-20), dim=2)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "TrainSpec_342": {
                "variable": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "lambda : input_fn(train_path)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "max_steps": {
                    "value": "num_train_steps",
                    "type": "variable",
                    "possible_values": []
                },
                "hooks": {
                    "value": "[hook_train] if hook_train else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "EvalSpec_345": {
                "variable": {
                    "value": "vali_spec",
                    "type": "variable",
                    "possible_values": []
                },
                "input_fn": {
                    "value": "lambda : input_fn(vali_path)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "hooks": {
                    "value": "[hook_vali] if hook_vali else None",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "concat_142": {
                "variable": {
                    "value": "input_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "example_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.layers.flatten(group_features[name]) for name in sorted(example_feature_columns())]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dense_152": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_layer",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(cur_layer, units=layer[0], activation=layer[1])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_205": {
                "variable": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "placeholder_with_default_206": {
                "variable": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "false_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(False)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(False)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cond_208": {
                "variable": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "evaluation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder_with_default(false_tensor, ())",
                            "Call"
                        ],
                        [
                            "tf.placeholder_with_default(false_tensor, ())",
                            "Call"
                        ]
                    ]
                },
                "false_fn": {
                    "value": "lambda : tf.convert_to_tensor(tau, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.convert_to_tensor(1e-10, dtype=tf.float32)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "where_216": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_label_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfr.utils.is_label_valid(labels)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(labels)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_217": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "is_label_valid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfr.utils.is_label_valid(labels)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "-1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_219": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_220": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "name": {
                    "value": "labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_229": {
                "variable": {
                    "value": "P_hat",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "tf.identity(P_hat, name='P_hat')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "P_hat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_231": {
                "variable": {
                    "value": "sorted_powers",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "P_hat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "P_hat_backward + tf.stop_gradient(P_hat_forward - P_hat_backward)",
                            "BinOp"
                        ],
                        [
                            "util.neuralsort(logits, temperature)",
                            "Call"
                        ],
                        [
                            "tf.identity(P_hat, name='P_hat')",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "label_powers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.pow(2.0, tf.cast(labels, dtype=tf.float32), name='label_powers') - 1.0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_232": {
                "variable": {
                    "value": "numerator",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sorted_powers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(P_hat, label_powers)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_numerator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_233": {
                "variable": {
                    "value": "position",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(1, list_size + 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_position",
                    "type": "str",
                    "possible_values": []
                }
            },
            "log_234": {
                "variable": {
                    "value": "denominator",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "position + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg_denominator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_237": {
                "variable": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / denominator",
                            "BinOp"
                        ],
                        [
                            "dcg[:, :ndcg_k]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(input_tensor=dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "matmul_240": {
                "variable": {
                    "value": "ideal_sorted_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "P_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "util.neuralsort(labels, taustar)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(P_true)",
                            "Call"
                        ],
                        [
                            "util.neuralsort(labels, 1e-10)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_241": {
                "variable": {
                    "value": "ideal_sorted_labels",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "ideal_sorted_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(P_true, labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(ideal_sorted_labels, axis=-1, name='ideal_sorted_labels')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "ideal_sorted_labels",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_247": {
                "variable": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "ideal_dcg[:, :ndcg_k]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "dcg",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Estimator_321": {
                "model_fn": {
                    "value": "tfr.model.make_groupwise_ranking_fn(group_score_fn=make_score_fn(), group_size=1, transform_fn=None, ranking_head=ranking_head)",
                    "type": "Call",
                    "possible_values": []
                },
                "params": {
                    "value": "hparams",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.contrib.training.HParams(learning_rate=learning_rate)",
                            "Call"
                        ]
                    ]
                },
                "model_dir": {
                    "value": "model_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/tmp/model_{}'.format(ex.current_run._id)",
                            "Call"
                        ]
                    ]
                }
            },
            "numeric_column_116": {
                "key": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "default_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "dense_147": {
                "variable": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "cur_layer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "input_layer",
                            "variable"
                        ],
                        [
                            "tf.layers.dense(cur_layer, units=layer[0], activation=layer[1])",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "layer[0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "parse_arch(hidden_layers)",
                            "Call"
                        ]
                    ]
                },
                "activation": {
                    "value": "layer[1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "parse_arch(hidden_layers)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_204": {
                "name": {
                    "value": "pirank_scope",
                    "type": "str",
                    "possible_values": []
                }
            },
            "train_and_evaluate_350": {
                "estimator": {
                    "value": "ranker",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_estimator(hparams, model_dir=model_dir)",
                            "Call"
                        ]
                    ]
                },
                "train_spec": {
                    "value": "train_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.TrainSpec(input_fn=lambda : input_fn(train_path), max_steps=num_train_steps, hooks=[hook_train] if hook_train else None)",
                            "Call"
                        ]
                    ]
                },
                "eval_spec": {
                    "value": "vali_spec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.EvalSpec(input_fn=lambda : input_fn(vali_path), hooks=[hook_vali] if hook_vali else None)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_139": {
                "structure": {
                    "value": "group_features[name]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stop_gradient_184": {
                "input": {
                    "value": "P_hat_forward - P_hat_backward",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_189": {
                "x": {
                    "value": "P_hat + 1e-20",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_like_216": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_221": {
                "input": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                }
            },
            "pow_230": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "label_powers",
                    "type": "str",
                    "possible_values": []
                }
            },
            "pow_243": {
                "x": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(ideal_sorted_labels, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "ideal_dcg_numerator",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_248": {
                "input_tensor": {
                    "value": "ideal_dcg",
                    "type": "variable",
                    "possible_values": [
                        [
                            "numerator / (1e-10 + denominator)",
                            "BinOp"
                        ],
                        [
                            "ideal_dcg[:, :ndcg_k]",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_sum(ideal_dcg, axis=1, keepdims=True, name='dcg')",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_95": {
                "dims": {
                    "value": "[list_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_170": {
                "value": {
                    "value": "tau",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_172": {
                "value": {
                    "value": "taustar",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_218": {
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stop_gradient_226": {
                "input": {
                    "value": "P_hat_forward - P_hat_backward",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_230": {
                "x": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(labels, 2)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(labels)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, labels, tf.zeros_like(labels))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(labels, 2, name='labels')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_243": {
                "x": {
                    "value": "ideal_sorted_labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.matmul(P_true, labels)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(ideal_sorted_labels, axis=-1, name='ideal_sorted_labels')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_312": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TensorShape_93": {
                "dims": {
                    "value": "[list_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_209": {
                "value": {
                    "value": "tau",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_211": {
                "value": {
                    "value": "1e-10",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_217": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(cur_layer, units=1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.where(is_label_valid, logits, -1e-06 * tf.ones_like(logits) + tf.reduce_min(input_tensor=logits, axis=1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(logits, 2, name='logits')",
                            "Call"
                        ]
                    ]
                }
            }
        }
    }
}