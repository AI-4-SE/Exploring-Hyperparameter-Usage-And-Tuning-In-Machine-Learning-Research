{
    "nabu/postprocessing/reconstructors/deepattractornet_reconstructor.py": {
        "sklearn": {
            "KMeans_78": {
                "variable": {
                    "value": "kmeans_model",
                    "type": "Variable",
                    "possible_values": []
                },
                "n_clusters": {
                    "value": "self.nrS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "init": {
                    "value": "k-means++",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_init": {
                    "value": "10",
                    "type": "Constant",
                    "possible_values": []
                },
                "max_iter": {
                    "value": "100",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_jobs": {
                    "value": "7",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/postprocessing/reconstructors/deepattractornet_softmax_reconstructor.py": {
        "sklearn": {
            "KMeans_80": {
                "variable": {
                    "value": "kmeans_model",
                    "type": "Variable",
                    "possible_values": []
                },
                "n_clusters": {
                    "value": "self.nrS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "init": {
                    "value": "k-means++",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_init": {
                    "value": "10",
                    "type": "Constant",
                    "possible_values": []
                },
                "max_iter": {
                    "value": "100",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_jobs": {
                    "value": "7",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/postprocessing/reconstructors/deepattractornetnoise_hard_reconstructor.py": {
        "sklearn": {}
    },
    "nabu/postprocessing/reconstructors/deepclustering_reconstructor.py": {
        "sklearn": {
            "KMeans_82": {
                "variable": {
                    "value": "kmeans_model",
                    "type": "Variable",
                    "possible_values": []
                },
                "n_clusters": {
                    "value": "self.nrS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "init": {
                    "value": "k-means++",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_init": {
                    "value": "10",
                    "type": "Constant",
                    "possible_values": []
                },
                "max_iter": {
                    "value": "100",
                    "type": "Constant",
                    "possible_values": []
                },
                "n_jobs": {
                    "value": "7",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/postprocessing/reconstructors/deepclusteringnoise_reconstructor.py": {
        "sklearn": {}
    },
    "nabu/postprocessing/reconstructors/oraclemask_reconstructor.py": {
        "sklearn": {}
    },
    "nabu/postprocessing/reconstructors/parallel_deepclustering_reconstructor.py": {
        "sklearn": {}
    },
    "nabu/postprocessing/reconstructors/parallel_mask_reconstructor.py": {
        "sklearn": {}
    },
    "nabu/neuralnetworks/components/layer.py": {
        "tensorflow": {
            "transpose_131": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[shared] + range(shared) + [rank - 1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "map_fn_134": {
                "variable": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "lambda x: tf.tensordot(x[0], x[1], [[shared], [0]])",
                    "type": "Lambda",
                    "possible_values": []
                },
                "elems": {
                    "value": "(inputs, self.kernel)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype or tf.float32",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "transpose_140": {
                "variable": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "predictions",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.map_fn(fn=lambda x: tf.tensordot(x[0], x[1], [[shared], [0]]), elems=(inputs, self.kernel), dtype=self.dtype or tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.transpose(predictions, range(1, shared + 1) + [0] + [rank - 1, rank])",
                            "Call"
                        ],
                        [
                            "tf.einsum(ein_not, inputs, self.kernel)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "range(1, shared + 1) + [0] + [rank - 1, rank]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "einsum_180": {
                "variable": {
                    "value": "predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ein_not",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'%s,%s->%s' % (input_shape_str, kernel_shape_str, output_shape_str)",
                            "BinOp"
                        ]
                    ]
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "self.kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "while_loop_229": {
                "variable": {
                    "value": "lo",
                    "type": "Variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda l: True",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "body",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[logits]",
                    "type": "List",
                    "possible_values": []
                },
                "maximum_iterations": {
                    "value": "self.routing_iters",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_348": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "rnn_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn_cell.RecCapsuleCellRecOnlyVote(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.RecCapsuleCell(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_type(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "rnn_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn_cell.RecCapsuleCellRecOnlyVote(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.RecCapsuleCell(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_type(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_352": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_436": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_440": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_498": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "rnn_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn_cell.RecCapsuleCellRecOnlyVote(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.RecCapsuleCell(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_type(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "rnn_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn_cell.RecCapsuleCellRecOnlyVote(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.RecCapsuleCell(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_type(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_502": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "dynamic_rnn_554": {
                "variable": {
                    "value": "(outputs, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "lstm_cell",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dynamic_rnn_687": {
                "variable": {
                    "value": "(outputs, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "lstm_cell",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_747": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_751": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_809": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_813": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_871": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_875": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_933": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_937": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "range_1013": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1014": {
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, -1), 0)",
                            "Call"
                        ],
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_1017": {
                "input": {
                    "value": "range(0, self.next_t_reset)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mod_1019": {
                "variable": {
                    "value": "mod1",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "numbers_to_maxT - 1 - numbers_to_k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "self.next_t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_1020": {
                "variable": {
                    "value": "mod2",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "numbers_to_maxT - mod1 - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "self.t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_1021": {
                "variable": {
                    "value": "mod3",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.mod(numbers_to_maxT, self.t_reset)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.next_t_reset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "where_1023": {
                "variable": {
                    "value": "indices_for_next_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mod1 < self.t_reset",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "mod2",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(numbers_to_maxT - mod1 - 1, self.t_reset)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mod3",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.mod(numbers_to_maxT, self.t_reset), [1, 1, self.next_t_reset])",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_1028": {
                "variable": {
                    "value": "indices_for_next_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "indices_for_next_layer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.where(mod1 < self.t_reset, x=mod2, y=mod3)",
                            "Call"
                        ],
                        [
                            "tf.tile(indices_for_next_layer, [batch_size, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_1031": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1032": {
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_1033": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, max_length, self.next_t_reset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_1034": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1035": {
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_1036": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, self.next_t_reset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_1037": {
                "variable": {
                    "value": "full_indices_for_next_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, indices_for_next_layer]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_1038": {
                "variable": {
                    "value": "output_for_next_layer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "outputs_tupple[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "full_indices_for_next_layer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, indices_for_next_layer], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "GRUCell_1210": {
                "variable": {
                    "value": "gru_cell_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_units": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.get_variable_scope().reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GRUCell_1214": {
                "variable": {
                    "value": "gru_cell_bw",
                    "type": "Variable",
                    "possible_values": []
                },
                "num_units": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.get_variable_scope().reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_1220": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "gru_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.GRUCell(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LeakGRUCell(num_units=self.num_units, leak_factor=self.leak_factor, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.ResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.GroupResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "gru_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.GRUCell(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LeakGRUCell(num_units=self.num_units, leak_factor=self.leak_factor, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.ResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.GroupResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_1224": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_1277": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "gru_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.GRUCell(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LeakGRUCell(num_units=self.num_units, leak_factor=self.leak_factor, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.ResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.GroupResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "gru_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.rnn.GRUCell(num_units=self.num_units, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LeakGRUCell(num_units=self.num_units, leak_factor=self.leak_factor, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.ResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.GroupResetGRUCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_1281": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_1371": {
                "variable": {
                    "value": "actual_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(actual_outputs_forward, actual_outputs_backward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "batch_normalization_1491": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.cluster(predictions, logits)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "(actual_outputs, output_for_next_layer)",
                            "Tuple"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "(actual_outputs, outputs_for_forward, outputs_for_backward)",
                            "Tuple"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.strides, padding=self.padding, activation=self.activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.strides, padding=self.padding, activation=self.activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(outputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(outputs, self.max_pool_filter, strides=self.max_pool_filter, padding='valid')",
                            "Call"
                        ]
                    ]
                }
            },
            "max_pooling2d_1496": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.cluster(predictions, logits)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "(actual_outputs, output_for_next_layer)",
                            "Tuple"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "tf.concat(outputs_tupple, 2)",
                            "Call"
                        ],
                        [
                            "(actual_outputs, outputs_for_forward, outputs_for_backward)",
                            "Tuple"
                        ],
                        [
                            "tf.layers.conv2d(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.strides, padding=self.padding, activation=self.activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d_transpose(inputs=inputs, filters=self.num_filters, kernel_size=self.kernel_size, strides=self.strides, padding=self.padding, activation=self.activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(outputs)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(outputs, self.max_pool_filter, strides=self.max_pool_filter, padding='valid')",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "self.max_pool_filter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "self.max_pool_filter",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "valid",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_initializer_56": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_124": {
                "name": {
                    "value": "predict",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_150": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(logits, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "[shape] + [1] * len(logits.shape)",
                            "BinOp"
                        ],
                        [
                            "[shape] + [1] * len(logits.shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_164": {
                "name": {
                    "value": "predict",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_189": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(logits, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "[shape] + [1] * len(logits.shape)",
                            "BinOp"
                        ],
                        [
                            "[shape] + [1] * len(logits.shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_202": {
                "name": {
                    "value": "cluster",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_223": {
                "variable": {
                    "value": "similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "predictions * tf.expand_dims(caps, -3)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_297": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_399": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_479": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_542": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_603": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_628": {
                "variable": {
                    "value": "(outputs_tupple, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell_fw": {
                    "value": "lstm_cell_fw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(num_units=self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "lstm_cell_bw",
                    "type": "Call",
                    "possible_values": [
                        [
                            "lstm_cell_type(num_capsules=self.num_capsules, capsule_dim=self.capsule_dim, routing_iters=self.routing_iters, activation=self._activation, input_probability_fn=self.input_probability_fn, recurrent_probability_fn=self.recurrent_probability_fn, logits_prior=self.logits_prior, accumulate_input_logits=self.accumulate_input_logits, accumulate_state_logits=self.accumulate_state_logits, gates_fc=self.gates_fc, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "lstm_cell_type(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormIZNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormNotRecLeakLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormBasicLeakchLSTMCell(self.num_units, leak_factor=self.leak_factor, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "tf.contrib.rnn.LayerNormBasicLSTMCell(num_units=self.num_units, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ],
                        [
                            "rnn_cell.LayerNormGroupResetLSTMCell(num_units=self.num_units, t_reset=self.t_reset, group_size=self.group_size, activation=self.activation_fn, layer_norm=self.layer_norm, dropout_keep_prob=self.recurrent_dropout, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "concat_631": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "outputs_tupple",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_675": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_729": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_791": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_853": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_915": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "shape_985": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_987": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_1096": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_1206": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_1261": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "shape_1330": {
                "input": {
                    "value": "inputs_for_forward",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_1332": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "expand_dims_1377": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "actual_outputs_forward",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "outputs_tupple[0][0]",
                            "Subscript"
                        ],
                        [
                            "outputs_tupple[0]",
                            "Subscript"
                        ],
                        [
                            "outputs_tupple[0][0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_1378": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "forward_for_backward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(actual_outputs_forward, -2)",
                            "Call"
                        ],
                        [
                            "tf.tile(forward_for_backward, tile_shape)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(forward_replicas, stacked_forward_indices_for_backward_t)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[1, 1, self.t_reset, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, gru_cell_fw._num_replicates, 1]",
                            "List"
                        ]
                    ]
                }
            },
            "expand_dims_1380": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "actual_outputs_backward",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "outputs_tupple[1][0]",
                            "Subscript"
                        ],
                        [
                            "outputs_tupple[1]",
                            "Subscript"
                        ],
                        [
                            "outputs_tupple[1][0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_1381": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "backward_for_forward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(actual_outputs_backward, -2)",
                            "Call"
                        ],
                        [
                            "tf.tile(backward_for_forward, tile_shape)",
                            "Call"
                        ],
                        [
                            "tf.gather_nd(backward_replicas, stacked_backward_indices_for_forward_t)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tile_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[1, 1, self.t_reset, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, gru_cell_fw._num_replicates, 1]",
                            "List"
                        ]
                    ]
                }
            },
            "concat_1383": {
                "variable": {
                    "value": "outputs_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_replicas, backward_for_forward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_1384": {
                "variable": {
                    "value": "outputs_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_backward, backward_replicas)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_int32_1389": {
                "variable": {
                    "value": "T",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ceil(tf.to_float(sequence_length) / tf.to_float(self.group_size))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_1390": {
                "variable": {
                    "value": "T_min_1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "range_1392": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1393": {
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, -1), 0)",
                            "Call"
                        ],
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1395": {
                "variable": {
                    "value": "numbers_to_k",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "range(0, self.num_replicates)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1399": {
                "variable": {
                    "value": "backward_indices_for_forward_t_0",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "backward_indices_for_forward_t_0",
                    "type": "Name",
                    "possible_values": [
                        [
                            "numbers_to_k + T_min_1",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(backward_indices_for_forward_t_0, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mod_1400": {
                "variable": {
                    "value": "backward_indices_for_forward_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "backward_indices_for_forward_t_0 - 2 * numbers_to_maxT",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "self.num_replicates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_1405": {
                "variable": {
                    "value": "forward_indices_for_backward_t_0",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "forward_indices_for_backward_t_0",
                    "type": "Name",
                    "possible_values": [
                        [
                            "numbers_to_k - T_min_1",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(forward_indices_for_backward_t_0, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mod_1406": {
                "variable": {
                    "value": "forward_indices_for_backward_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "forward_indices_for_backward_t_0 + 2 * numbers_to_maxT",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "self.num_replicates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "range_1409": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1410": {
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_1411": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, max_length, self.num_replicates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_1412": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_1413": {
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_1414": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.next_t_reset])",
                            "Call"
                        ],
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, self.num_replicates])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, self.num_replicates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_1415": {
                "variable": {
                    "value": "stacked_backward_indices_for_forward_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, backward_indices_for_forward_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_1416": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "backward_replicas",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "outputs_tupple[1][1]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "outputs_tupple[1][1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_backward_indices_for_forward_t",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, backward_indices_for_forward_t], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_1417": {
                "variable": {
                    "value": "stacked_forward_indices_for_backward_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, forward_indices_for_backward_t]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_1418": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "forward_replicas",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "outputs_tupple[0][1]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "outputs_tupple[0][1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_forward_indices_for_backward_t",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, forward_indices_for_backward_t], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1420": {
                "variable": {
                    "value": "outputs_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_replicas, backward_for_forward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_1421": {
                "variable": {
                    "value": "outputs_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_backward, backward_replicas)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_1471": {
                "name_or_scope": {
                    "value": "scope or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "conv2d_1474": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "self.num_filters",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "self.strides",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "conv2d_transpose_1482": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [shared] + range(shared) + [rank - 1])",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "self.num_filters",
                    "type": "Attribute",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "self.kernel_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strides": {
                    "value": "self.strides",
                    "type": "Attribute",
                    "possible_values": []
                },
                "padding": {
                    "value": "self.padding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation_fn",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_210": {
                "variable": {
                    "value": "caps",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(w, -1) * predictions",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "mod_1021": {
                "x1": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, -1), 0)",
                            "Call"
                        ],
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "self.t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_150": {
                "input": {
                    "value": "logits",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(logits, 0), tile)",
                            "Call"
                        ],
                        [
                            "self.logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(logits, 0), tile)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_189": {
                "input": {
                    "value": "logits",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "self.logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(logits, 0), tile)",
                            "Call"
                        ],
                        [
                            "self.logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(logits, 0), tile)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "name_scope_207": {
                "name": {
                    "value": "m_step",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ceil_1389": {
                "x": {
                    "value": "tf.to_float(sequence_length) / tf.to_float(self.group_size)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tensordot_135": {
                "a": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "x[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[shared], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_146": {
                "input": {
                    "value": "predictions",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.map_fn(fn=lambda x: tf.tensordot(x[0], x[1], [[shared], [0]]), elems=(inputs, self.kernel), dtype=self.dtype or tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.transpose(predictions, range(1, shared + 1) + [0] + [rank - 1, rank])",
                            "Call"
                        ],
                        [
                            "tf.einsum(ein_not, inputs, self.kernel)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_185": {
                "input": {
                    "value": "predictions",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.map_fn(fn=lambda x: tf.tensordot(x[0], x[1], [[shared], [0]]), elems=(inputs, self.kernel), dtype=self.dtype or tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.transpose(predictions, range(1, shared + 1) + [0] + [rank - 1, rank])",
                            "Call"
                        ],
                        [
                            "tf.einsum(ein_not, inputs, self.kernel)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_224": {
                "input": {
                    "value": "caps",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.expand_dims(w, -1) * predictions, -3)",
                            "Call"
                        ],
                        [
                            "self.activation_fn(caps)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "get_variable_scope_420": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_433": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_491": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_495": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_551": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_618": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_624": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_684": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_738": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_744": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_800": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_806": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_862": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_868": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_924": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_930": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_996": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1213": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1217": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1269": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1274": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_211": {
                "input": {
                    "value": "w",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.probability_fn(l)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "get_variable_scope_313": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_325": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_335": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_345": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1105": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1130": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1340": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1345": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1354": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1360": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_1389": {
                "x": {
                    "value": "self.group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_scope_1113": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1122": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1138": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_scope_1147": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/components/ntm_ops.py": {
        "tensorflow": {
            "truncated_normal_initializer_10": {
                "stddev": {
                    "value": "stddev",
                    "type": "Name",
                    "possible_values": [
                        [
                            "1.0 / np.sqrt(input_size)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/components/ops.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/components/rnn.py": {
        "tensorflow": {
            "flatten_638": {
                "variable": {
                    "value": "flat_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nest.pack_sequence_as(structure=inputs, flat_sequence=flat_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_639": {
                "variable": {
                    "value": "flat_output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "cell.output_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_642": {
                "variable": {
                    "value": "input_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "flat_input[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "pack_sequence_as_674": {
                "variable": {
                    "value": "zero_output",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "cell.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "flat_zero_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tuple((_create_zero_arrays(output) for output in flat_output_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_683": {
                "variable": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtypes.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "time",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "while_loop_774": {
                "variable": {
                    "value": "(_, output_final_ta, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda time, *_: time < loop_bound",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "_time_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "(time, output_ta, state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "parallel_iterations or 32",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "maximum_iterations": {
                    "value": "time_steps",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "pack_sequence_as_793": {
                "variable": {
                    "value": "final_outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "cell.output_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "final_outputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tuple((ta.stack() for ta in output_final_ta))",
                            "Call"
                        ],
                        [
                            "output_final_ta",
                            "Name"
                        ],
                        [
                            "nest.pack_sequence_as(structure=cell.output_size, flat_sequence=final_outputs)",
                            "Call"
                        ],
                        [
                            "nest.map_structure_up_to(cell.output_size, lambda x: array_ops.stack(x, axis=0), final_outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_537": {
                "variable": {
                    "value": "flat_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nest.pack_sequence_as(structure=inputs, flat_sequence=flat_input)",
                            "Call"
                        ]
                    ]
                }
            },
            "pack_sequence_as_578": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nest.pack_sequence_as(structure=inputs, flat_sequence=flat_input)",
                            "Call"
                        ]
                    ]
                },
                "flat_sequence": {
                    "value": "flat_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "nest.flatten(inputs)",
                            "Call"
                        ],
                        [
                            "[ops.convert_to_tensor(input_) for input_ in flat_input]",
                            "ListComp"
                        ],
                        [
                            "tuple((rnn._transpose_batch_time(input_) for input_ in flat_input))",
                            "Call"
                        ],
                        [
                            "nest.flatten(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_678": {
                "variable": {
                    "value": "min_sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_max_679": {
                "variable": {
                    "value": "max_sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "pack_sequence_as_735": {
                "variable": {
                    "value": "input_t",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nest.pack_sequence_as(structure=inputs, flat_sequence=flat_input)",
                            "Call"
                        ]
                    ]
                },
                "flat_sequence": {
                    "value": "input_t",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tuple((ta.read(time) for ta in input_ta))",
                            "Call"
                        ],
                        [
                            "tuple((ta[time.numpy()] for ta in input_ta))",
                            "Call"
                        ],
                        [
                            "nest.pack_sequence_as(structure=inputs, flat_sequence=input_t)",
                            "Call"
                        ]
                    ]
                }
            },
            "flatten_754": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "nest.flatten(output)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_768": {
                "variable": {
                    "value": "loop_bound",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time_steps",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "math_ops.maximum(1, max_sequence_length)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_108": {
                "name_or_scope": {
                    "value": "scope or 'bidirectional_rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_240": {
                "name_or_scope": {
                    "value": "scope or 'bidirectional_rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "variable_scope_379": {
                "name_or_scope": {
                    "value": "scope or 'bidirectional_rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "dynamic_rnn_382": {
                "variable": {
                    "value": "(output_fw, output_state_fw)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs_fw",
                    "type": "Variable",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "initial_state_fw",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "parallel_iterations or 32",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "time_major": {
                    "value": "time_major",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "scope": {
                    "value": "fw_scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "dynamic_rnn_408": {
                "variable": {
                    "value": "(tmp, output_state_bw)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "cell_bw",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs_reverse",
                    "type": "Call",
                    "possible_values": [
                        [
                            "_reverse(inputs, seq_lengths=sequence_length, seq_axis=time_dim, batch_axis=batch_dim)",
                            "Call"
                        ],
                        [
                            "_reverse(inputs_bw, seq_lengths=sequence_length, seq_axis=time_dim, batch_axis=batch_dim)",
                            "Call"
                        ],
                        [
                            "_reverse(inputs_bw, seq_lengths=sequence_length, seq_axis=time_dim, batch_axis=batch_dim)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "initial_state_bw",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "parallel_iterations": {
                    "value": "parallel_iterations",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "parallel_iterations or 32",
                            "BoolOp"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "swap_memory",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "time_major": {
                    "value": "time_major",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                },
                "scope": {
                    "value": "bw_scope",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_526": {
                "name_or_scope": {
                    "value": "scope or 'rnn'",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "to_int32_546": {
                "variable": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_551": {
                "variable": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "sequence_length",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_564": {
                "variable": {
                    "value": "x_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "stack_565": {
                "variable": {
                    "value": "packed_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs_got_shape",
                            "Name"
                        ],
                        [
                            "_concat([const_time_steps, const_batch_size], output_size, static=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "map_structure_594": {
                "variable": {
                    "value": "outputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "func": {
                    "value": "rnn._transpose_batch_time",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*structure": {
                    "value": "outputs",
                    "type": "Tuple",
                    "possible_values": [
                        [
                            "(output_fw, output_bw)",
                            "Tuple"
                        ],
                        [
                            "(output_fw, output_bw)",
                            "Tuple"
                        ],
                        [
                            "(output_fw, output_bw)",
                            "Tuple"
                        ],
                        [
                            "nest.map_structure(rnn._transpose_batch_time, outputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_669": {
                "shape": {
                    "value": "array_ops.stack(size)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "rnn._infer_state_dtype(dtype, state)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_685": {
                "name": {
                    "value": "dynamic_rnn",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "TensorArray_689": {
                "dtype": {
                    "value": "dtype",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "size": {
                    "value": "time_steps",
                    "type": "Name",
                    "possible_values": [
                        [
                            "input_shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "element_shape": {
                    "value": "element_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor_array_name": {
                    "value": "base_name + name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "executing_eagerly_694": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_110": {
                "name_or_scope": {
                    "value": "fw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "bw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_242": {
                "name_or_scope": {
                    "value": "fw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_269": {
                "name_or_scope": {
                    "value": "bw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_381": {
                "name_or_scope": {
                    "value": "fw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_404": {
                "name_or_scope": {
                    "value": "bw",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "executing_eagerly_530": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Assert_566": {
                "condition": {
                    "value": "math_ops.reduce_all(math_ops.equal(x_shape, packed_shape))",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "['Expected shape for Tensor %s is ' % x.name, packed_shape, ' but saw shape: ', x_shape]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_575": {
                "variable": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sequence_length",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "math_ops.to_int32(sequence_length)",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='sequence_length')",
                            "Call"
                        ],
                        [
                            "array_ops.identity(sequence_length, name='CheckSeqLen')",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "name": {
                    "value": "CheckSeqLen",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "stack_670": {
                "values": {
                    "value": "size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "_concat(batch_size, size)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_769": {
                "x": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "y": {
                    "value": "max_sequence_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "math_ops.reduce_max(sequence_length)",
                            "Call"
                        ],
                        [
                            "time_steps",
                            "Name"
                        ]
                    ]
                }
            },
            "reverse_sequence_127": {
                "input": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "seq_lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_axis": {
                    "value": "seq_axis",
                    "type": "Variable",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "batch_axis",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reverse_131": {
                "tensor": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[seq_axis]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reverse_sequence_263": {
                "input": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "seq_lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_axis": {
                    "value": "seq_axis",
                    "type": "Variable",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "batch_axis",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reverse_267": {
                "tensor": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[seq_axis]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reverse_sequence_398": {
                "input": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "seq_lengths",
                    "type": "Variable",
                    "possible_values": []
                },
                "seq_axis": {
                    "value": "seq_axis",
                    "type": "Variable",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "batch_axis",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reverse_402": {
                "tensor": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[seq_axis]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_541": {
                "value": {
                    "value": "input_",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "reduce_all_567": {
                "input_tensor": {
                    "value": "math_ops.equal(x_shape, packed_shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "executing_eagerly_571": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_573": {
                "control_inputs": {
                    "value": "[_assert_has_shape(sequence_length, [batch_size])]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_797": {
                "values": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "equal_567": {
                "x": {
                    "value": "x_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "array_ops.shape(x)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "packed_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "array_ops.stack(shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_699": {
                "dims": {
                    "value": "[const_batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concatenate_699": {
                "arys": {
                    "value": "rnn._maybe_tensor_shape_from_tensor(out_size)",
                    "type": "Call",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/components/rnn_cell.py": {
        "tensorflow": {
            "InputSpec_44": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndim": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "while_loop_307": {
                "variable": {
                    "value": "[in_lo, state_lo, _, _]",
                    "type": "List",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda l, ll, lll, llll: True",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "body",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[input_logits, state_logits, input_logits, state_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "maximum_iterations": {
                    "value": "self.routing_iters",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "InputSpec_336": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndim": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_355": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel_gates",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "matmul_356": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_357": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias_gates",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_358": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_386": {
                "variable": {
                    "value": "inputs_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, inputs_num_capsules * inputs_caps_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_387": {
                "variable": {
                    "value": "h_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "Name",
                    "possible_values": [
                        [
                            "h * self._leak_factor",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.num_capsules * self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_389": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs_flat, h_flat]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_392": {
                "variable": {
                    "value": "concat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size] + self.gates_output_shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_394": {
                "variable": {
                    "value": "(i, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_402": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_436": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel_gates",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "matmul_437": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_438": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias_gates",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_439": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_446": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel_output_matrix",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size] + out_shape",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tensordot_447": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_448": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias_output_matrix",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "out_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_477": {
                "variable": {
                    "value": "inputs_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, inputs_num_capsules * inputs_caps_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_478": {
                "variable": {
                    "value": "h_flat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "h",
                    "type": "Name",
                    "possible_values": [
                        [
                            "h * self._leak_factor",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.num_capsules * self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_480": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs_flat, h_flat]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_483": {
                "variable": {
                    "value": "concat",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size] + self.gates_output_shape",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "split_485": {
                "variable": {
                    "value": "(i, f)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_496": {
                "variable": {
                    "value": "tmp",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(o, tf.expand_dims(activated_new_c, -1))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_499": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_510": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, state], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_512": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._gate_kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_526": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_530": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_547": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "InputSpec_582": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndim": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_632": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, state], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._gate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_634": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._gate_kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._gate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_636": {
                "variable": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(array_ops.concat([inputs, state], 1), self._gate_kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_637": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "Name",
                    "possible_values": [
                        [
                            "math_ops.sigmoid(gate_inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_641": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, r_state], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._candidate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bias_add_643": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "candidate",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(array_ops.concat([inputs, r_state], 1), self._candidate_kernel)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(candidate, self._candidate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._candidate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_723": {
                "variable": {
                    "value": "gamma_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_724": {
                "variable": {
                    "value": "beta_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_735": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_736": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_745": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_748": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_767": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_844": {
                "variable": {
                    "value": "gamma_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_845": {
                "variable": {
                    "value": "beta_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_856": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_857": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_866": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel_inonly",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_867": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_876": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_880": {
                "variable": {
                    "value": "(f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_881": {
                "variable": {
                    "value": "(i, j)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat_inonly",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._linear_inonly(inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_900": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_977": {
                "variable": {
                    "value": "gamma_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_978": {
                "variable": {
                    "value": "beta_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_989": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_990": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_1002": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1021": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_1097": {
                "variable": {
                    "value": "gamma_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._g",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_1098": {
                "variable": {
                    "value": "beta_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._b",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_1109": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_1110": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_1124": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "split_1127": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1144": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_initializer_1211": {
                "variable": {
                    "value": "gamma_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._norm_gain",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_1212": {
                "variable": {
                    "value": "beta_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "self._norm_shift",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_1224": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "kernel",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[proj_size, out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "tensordot_1225": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "Call",
                    "possible_values": [
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs_flat, h_flat], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h], 1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ],
                        [
                            "array_ops.concat([inputs, h_reset], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_gates', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_output_matrix', [proj_size] + out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel_inonly', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('kernel', [proj_size, out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "mod_1234": {
                "variable": {
                    "value": "state_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "x2": {
                    "value": "self._t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_1235": {
                "variable": {
                    "value": "next_state_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "time + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "self._t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_1241": {
                "input": {
                    "value": "tmp",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.matmul(o, tf.expand_dims(activated_new_c, -1)), -1)",
                            "Call"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(state_index, 0), 0), tf.constant([1.0]), tf.constant([self._t_reset]))",
                            "BinOp"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(replicate_index, 0), 0), tf.constant([1.0]), tf.constant([self._num_replicates]))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_1246": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h_reset]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_1250": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_1266": {
                "variable": {
                    "value": "new_h_maxmem",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "next_state_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(time + 1, self._t_reset)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1268": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "mod_1339": {
                "variable": {
                    "value": "state_index_in_group",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "x2": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floor_div_1340": {
                "variable": {
                    "value": "group_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_1341": {
                "variable": {
                    "value": "replicate_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "group_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.floor_div(time, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "self._num_replicates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floor_div_1342": {
                "variable": {
                    "value": "next_group_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_1343": {
                "variable": {
                    "value": "next_replicate_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "next_group_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.floor_div(time + 1, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "self._num_replicates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_1350": {
                "input": {
                    "value": "tmp",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "tf.squeeze(tf.matmul(o, tf.expand_dims(activated_new_c, -1)), -1)",
                            "Call"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(state_index, 0), 0), tf.constant([1.0]), tf.constant([self._t_reset]))",
                            "BinOp"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(replicate_index, 0), 0), tf.constant([1.0]), tf.constant([self._num_replicates]))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "equal_1352": {
                "variable": {
                    "value": "reset_flag",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "state_index_in_group + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_1353": {
                "variable": {
                    "value": "c_reset",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "reset_flag",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.equal(state_index_in_group + 1, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : c * reset_mask",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : c",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_1354": {
                "variable": {
                    "value": "h_reset",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "reset_flag",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.equal(state_index_in_group + 1, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : h * reset_mask",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : h",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_1356": {
                "variable": {
                    "value": "args",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, h_reset]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_1360": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "concat",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args, out_size=self.gates_output_shape[0] * self.gates_output_shape[1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(concat, [batch_size] + self.gates_output_shape)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(inputs)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ],
                        [
                            "self._linear(args)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_1377": {
                "variable": {
                    "value": "new_h_maxmem",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "next_replicate_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(next_group_index, self._num_replicates)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1379": {
                "variable": {
                    "value": "new_state",
                    "type": "Variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "new_c * self._leak_factor",
                            "BinOp"
                        ],
                        [
                            "c * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state')",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "c_reset * math_ops.sigmoid(f + self._forget_bias) + math_ops.sigmoid(i) * g",
                            "BinOp"
                        ],
                        [
                            "self._norm(new_c, 'state', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(tmp)",
                            "Call"
                        ],
                        [
                            "new_c * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ],
                        [
                            "self._activation(new_c) * math_ops.sigmoid(o)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_1413": {
                "variable": {
                    "value": "combined_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inputs, tf.reshape(prev_read_vector, [batch_size, self.read_head_num * self.memory_vector_dim])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_1426": {
                "variable": {
                    "value": "head_parameters",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "head_parameters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "parameters[:, :num_parameters_per_head * num_heads]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(head_parameters, [batch_size, num_heads, num_parameters_per_head])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, num_heads, num_parameters_per_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1429": {
                "variable": {
                    "value": "erase_parameters",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "erase_parameters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "parameters[:, num_parameters_per_head * num_heads:num_parameters_per_head * num_heads + num_parameters_erase_per_write_head * self.write_head_num]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(erase_parameters, [batch_size, self.write_head_num, num_parameters_erase_per_write_head])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.write_head_num, num_parameters_erase_per_write_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_1431": {
                "variable": {
                    "value": "add_parameters",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "add_parameters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "parameters[:, num_parameters_per_head * num_heads + num_parameters_erase_per_write_head * self.write_head_num:]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(add_parameters, [batch_size, self.write_head_num, num_parameters_erase_per_write_head])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.write_head_num, num_parameters_erase_per_write_head]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_1436": {
                "variable": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "head_parameters[:, :, 0:self.memory_vector_dim]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softplus_1437": {
                "variable": {
                    "value": "beta",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "head_parameters[:, :, self.memory_vector_dim]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "sigmoid_1438": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "head_parameters[:, :, self.memory_vector_dim + 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_1439": {
                "variable": {
                    "value": "s",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "head_parameters[:, :, self.memory_vector_dim + 2:self.memory_vector_dim + 2 + self.shift_win_size]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_1445": {
                "variable": {
                    "value": "read_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "w[:, :self.read_head_num]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_1446": {
                "variable": {
                    "value": "read_vector",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "read_w * tf.expand_dims(prev_M, 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1451": {
                "variable": {
                    "value": "write_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "w[:, self.read_head_num:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_prod_1452": {
                "variable": {
                    "value": "forget_vectors",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "1 - tf.matmul(write_w, tf.expand_dims(tf.sigmoid(erase_parameters), 2))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_1453": {
                "variable": {
                    "value": "add_vectors",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.matmul(write_w, tf.expand_dims(tf.tanh(add_parameters), 2))",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_1456": {
                "variable": {
                    "value": "read_w",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "read_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(w[:, :self.read_head_num], -1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(read_w, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_1466": {
                "variable": {
                    "value": "k",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "k",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tanh(head_parameters[:, :, 0:self.memory_vector_dim])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(k, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "norm_1467": {
                "variable": {
                    "value": "k_norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "k",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tanh(head_parameters[:, :, 0:self.memory_vector_dim])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(k, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_1469": {
                "variable": {
                    "value": "prev_M",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(prev_M, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, num_head, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "norm_1470": {
                "variable": {
                    "value": "prev_M_norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "prev_M",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prev_state.M",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(prev_M, 1), [1, num_head, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "squeeze_1473": {
                "variable": {
                    "value": "K",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.matmul(prev_M_normalized, k_normalized)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_1477": {
                "variable": {
                    "value": "K_amplified",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(beta, axis=2) * K",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "softmax_1478": {
                "variable": {
                    "value": "w_c",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "K_amplified",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.exp(tf.expand_dims(beta, axis=2) * K)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1485": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_1493": {
                "variable": {
                    "value": "s",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[s[:, :, :shift_range + 1], tf.zeros(s.get_shape()[0:2].concatenate(tf.TensorShape([self.memory_size - self.shift_win_size]))), s[:, :, shift_range + 1:]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_1499": {
                "variable": {
                    "value": "t",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.reverse(s, axis=[-1]), tf.reverse(s, axis=[-1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_1500": {
                "variable": {
                    "value": "s_matrix",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[t[:, :, self.memory_size - i - 1:self.memory_size * 2 - i - 1] for i in range(self.memory_size)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_1504": {
                "variable": {
                    "value": "w_",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(w_g, axis=2) * s_matrix",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pow_1505": {
                "variable": {
                    "value": "w_sharpen",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "w_",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.expand_dims(w_g, axis=2) * s_matrix, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(gamma, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "VariableScope_1566": {
                "variable": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_1623": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "nest.flatten(new_state)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "TensorShape_58": {
                "dims": {
                    "value": "[self.num_capsules, self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_62": {
                "dims": {
                    "value": "[self.num_capsules, self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_152": {
                "variable": {
                    "value": "input_predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ein_not",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'%s,%s->%s' % (input_shape_str, kernel_shape_str, output_shape_str)",
                            "BinOp"
                        ]
                    ]
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.input_kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "einsum_153": {
                "variable": {
                    "value": "state_predictions",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ein_not",
                    "type": "Name",
                    "possible_values": [
                        [
                            "'%s,%s->%s' % (input_shape_str, kernel_shape_str, output_shape_str)",
                            "BinOp"
                        ]
                    ]
                },
                "*inputs": {
                    "value": "state",
                    "type": "Variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "self.state_kernel",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "while_loop_220": {
                "variable": {
                    "value": "[in_lo, state_lo]",
                    "type": "List",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda l, ll: True",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "body",
                    "type": "Variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[input_logits, state_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "maximum_iterations": {
                    "value": "self.routing_iters",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_291": {
                "variable": {
                    "value": "in_similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "input_predictions * tf.expand_dims(caps, -3)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_292": {
                "variable": {
                    "value": "state_similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "state_predictions * tf.expand_dims(caps, -3)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_345": {
                "c": {
                    "value": "tf.TensorShape([self.num_capsules, self.capsule_dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "h": {
                    "value": "tf.TensorShape([self.num_capsules, self.capsule_dim])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_350": {
                "dims": {
                    "value": "[self.num_capsules, self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_539": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_715": {
                "c": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_738": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_739": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_757": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_836": {
                "c": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_859": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_860": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_869": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias_inonly",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_870": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_890": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_969": {
                "c": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_992": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_993": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_1011": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1089": {
                "c": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self._num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_1112": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_1113": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_1136": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1202": {
                "c": {
                    "value": "tf.TensorShape([self._t_reset, self._num_units])",
                    "type": "Call",
                    "possible_values": []
                },
                "h": {
                    "value": "tf.TensorShape([self._t_reset, self._num_units])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_1227": {
                "variable": {
                    "value": "bias",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[out_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "bias_add_1228": {
                "variable": {
                    "value": "out",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, axes=[[-1], [0]])",
                            "Call"
                        ],
                        [
                            "out + tf.expand_dims(bias, 0)",
                            "BinOp"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "math_ops.matmul(args, weights)",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(args, weights, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(out, bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "dropout_1259": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_1328": {
                "c": {
                    "value": "tf.TensorShape([self._num_replicates, self._num_units])",
                    "type": "Call",
                    "possible_values": []
                },
                "h": {
                    "value": "tf.TensorShape([self._num_replicates, self._num_units])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_1369": {
                "variable": {
                    "value": "g",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "g",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "self._activation(j)",
                            "Call"
                        ],
                        [
                            "nn_ops.dropout(g, self._keep_prob, seed=self._seed)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(head_parameters[:, :, self.memory_vector_dim + 1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(g, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self._keep_prob",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seed": {
                    "value": "self._seed",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_1424": {
                "variable": {
                    "value": "parameters",
                    "type": "Variable",
                    "possible_values": []
                },
                "t": {
                    "value": "parameters",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.fully_connected(combined_inputs, total_parameter_num, activation_fn=None, weights_initializer=self.o2p_initializer)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(parameters, -self.clip_value, self.clip_value)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "-self.clip_value",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "self.clip_value",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_1512": {
                "variable": {
                    "value": "read_vector_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.get_variable(name='init_read_vector', shape=self.memory_vector_dim, initializer=create_linear_initializer(self.memory_vector_dim), trainable=self.init_mode_other_params == 'learned')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_1518": {
                "variable": {
                    "value": "read_vector_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(read_vector_init, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, self.read_head_num, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_1520": {
                "variable": {
                    "value": "w_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "tf.get_variable(name='init_w', shape=[self.read_head_num + self.write_head_num, self.memory_size], initializer=create_linear_initializer(self.memory_size), trainable=self.init_mode_other_params == 'learned')",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_1526": {
                "variable": {
                    "value": "w_init",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(w_init, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_1540": {
                "variable": {
                    "value": "M",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(M, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_initializer_49": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "name_scope_135": {
                "name": {
                    "value": "predict",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_163": {
                "variable": {
                    "value": "input_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(input_logits, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "[shape] + [1] * len(input_logits.shape)",
                            "BinOp"
                        ],
                        [
                            "[shape] + [1] * len(state_logits.shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "tile_173": {
                "variable": {
                    "value": "state_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(state_logits, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "[shape] + [1] * len(input_logits.shape)",
                            "BinOp"
                        ],
                        [
                            "[shape] + [1] * len(state_logits.shape)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "name_scope_186": {
                "name": {
                    "value": "cluster",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_214": {
                "variable": {
                    "value": "in_similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "input_predictions * tf.expand_dims(caps, -3)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_215": {
                "variable": {
                    "value": "state_similarity",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "state_predictions * tf.expand_dims(caps, -3)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_261": {
                "name": {
                    "value": "cluster",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "TensorShape_345": {
                "dims": {
                    "value": "[self.num_capsules, self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_346": {
                "dims": {
                    "value": "[self.num_capsules, self.capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_400": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_449": {
                "input": {
                    "value": "bias",
                    "type": "Call",
                    "possible_values": [
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_gates', [out_size], dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_output_matrix', out_shape, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias_inonly', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size])",
                            "Call"
                        ],
                        [
                            "vs.get_variable('bias', [out_size], dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_496": {
                "a": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.expand_dims(activated_new_c, -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_511": {
                "values": {
                    "value": "[inputs, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_545": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_633": {
                "values": {
                    "value": "[inputs, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_642": {
                "values": {
                    "value": "[inputs, r_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "warn_700": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_725": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_727": {
                "name": {
                    "value": "gamma",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_728": {
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_763": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_821": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_846": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_848": {
                "name": {
                    "value": "gamma",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_849": {
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_896": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_954": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_979": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_981": {
                "name": {
                    "value": "gamma",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_982": {
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_1017": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_1074": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_1099": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_1101": {
                "name": {
                    "value": "gamma",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_1102": {
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_1142": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_1187": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "TensorShape_1202": {
                "dims": {
                    "value": "[self._t_reset, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_1207": {
                "dims": {
                    "value": "[self._t_reset, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_1213": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "MethodArgument",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_1215": {
                "name": {
                    "value": "gamma",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "gamma_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._g)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_gain)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "get_variable_1216": {
                "name": {
                    "value": "beta",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "tf.shape(input_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "input_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "tf.shape(state_predictions)[shared - i - 1]",
                            "Subscript"
                        ],
                        [
                            "state_predictions.shape[shared - i - 1].value",
                            "Attribute"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ],
                        [
                            "inp.get_shape()[-1:]",
                            "Subscript"
                        ]
                    ]
                },
                "initializer": {
                    "value": "beta_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._b)",
                            "Call"
                        ],
                        [
                            "init_ops.constant_initializer(self._norm_shift)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "Attribute",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "dtypes.float32",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "scatter_nd_1239": {
                "indices": {
                    "value": "tf.expand_dims(tf.expand_dims(state_index, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.constant([1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.constant([self._t_reset])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_1265": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "warn_1317": {
                "msg": {
                    "value": "%s: The input_size parameter is deprecated.",
                    "type": "Constant",
                    "possible_values": []
                },
                "*args": {
                    "value": "self",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "TensorShape_1328": {
                "dims": {
                    "value": "[self._num_replicates, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_1329": {
                "dims": {
                    "value": "[self._num_replicates, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_1334": {
                "dims": {
                    "value": "[self._num_replicates, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "scatter_nd_1348": {
                "indices": {
                    "value": "tf.expand_dims(tf.expand_dims(replicate_index, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.constant([1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.constant([self._num_replicates])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_1376": {
                "x": {
                    "value": "o",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._linear_matrix(args, out_shape=self.rot_matrix_shape)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output')",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(o, 'output', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_1420": {
                "name_or_scope": {
                    "value": "o2p",
                    "type": "Constant",
                    "possible_values": []
                },
                "default_name": {
                    "value": "self.reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softplus_1441": {
                "features": {
                    "value": "head_parameters[:, :, -1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "matmul_1453": {
                "a": {
                    "value": "write_w",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(w[:, self.read_head_num:], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.expand_dims(tf.tanh(add_parameters), 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_1469": {
                "input": {
                    "value": "prev_M",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prev_state.M",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(prev_M, 1), [1, num_head, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_1473": {
                "a": {
                    "value": "prev_M_normalized",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prev_M / (prev_M_norm + 1e-12)",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "k_normalized",
                    "type": "Name",
                    "possible_values": [
                        [
                            "k / (k_norm + 1e-12)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_1505": {
                "input": {
                    "value": "gamma",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.softplus(head_parameters[:, :, -1]) + 1",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_1506": {
                "input_tensor": {
                    "value": "w_sharpen",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.pow(w_, tf.expand_dims(gamma, axis=-1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_1511": {
                "name_or_scope": {
                    "value": "init",
                    "type": "Constant",
                    "possible_values": []
                },
                "reuse": {
                    "value": "self.reuse",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tanh_1529": {
                "variable": {
                    "value": "M",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.get_variable(name='init_M', shape=[self.memory_size, self.memory_vector_dim], initializer=create_linear_initializer(self.memory_vector_dim))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_1556": {
                "dims": {
                    "value": "self.read_head_dim",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_1588": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flatten_1623": {
                "structure": {
                    "value": "new_state",
                    "type": "Call",
                    "possible_values": [
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ],
                        [
                            "rnn_cell_impl.LSTMStateTuple(new_c, new_h)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_398": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_489": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_496": {
                "input": {
                    "value": "activated_new_c",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self._activation(new_c)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sigmoid_542": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_759": {
                "x": {
                    "value": "f + self._forget_bias",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_760": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_892": {
                "x": {
                    "value": "f + self._forget_bias",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_893": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_1013": {
                "x": {
                    "value": "f + self._forget_bias",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_1014": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_1138": {
                "x": {
                    "value": "f + self._forget_bias",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_1139": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_1239": {
                "input": {
                    "value": "state_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(time, self._t_reset)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_1239": {
                "value": {
                    "value": "[1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_1240": {
                "value": {
                    "value": "[self._t_reset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_1262": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_1348": {
                "input": {
                    "value": "replicate_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(group_index, self._num_replicates)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_1348": {
                "value": {
                    "value": "[1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_1349": {
                "value": {
                    "value": "[self._num_replicates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_1373": {
                "x": {
                    "value": "i",
                    "type": "Call",
                    "possible_values": [
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "range(shared)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input')",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ],
                        [
                            "self._norm(i, 'input', dtype=dtype)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_1414": {
                "tensor": {
                    "value": "prev_read_vector",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prev_state.read_vector",
                            "Attribute"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, self.read_head_num * self.memory_vector_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_1446": {
                "input": {
                    "value": "prev_M",
                    "type": "Name",
                    "possible_values": [
                        [
                            "prev_state.M",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(prev_M, 1), [1, num_head, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_1452": {
                "a": {
                    "value": "write_w",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(w[:, self.read_head_num:], -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "tf.expand_dims(tf.sigmoid(erase_parameters), 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_1453": {
                "input": {
                    "value": "tf.tanh(add_parameters)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1477": {
                "input": {
                    "value": "beta",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.nn.softplus(head_parameters[:, :, self.memory_vector_dim])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "zeros_1496": {
                "shape": {
                    "value": "s.get_shape()[0:2].concatenate(tf.TensorShape([self.memory_size - self.shift_win_size]))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reverse_1499": {
                "tensor": {
                    "value": "s",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(head_parameters[:, :, self.memory_vector_dim + 2:self.memory_vector_dim + 2 + self.shift_win_size], -1)",
                            "Call"
                        ],
                        [
                            "tf.concat([s[:, :, :shift_range + 1], tf.zeros(s.get_shape()[0:2].concatenate(tf.TensorShape([self.memory_size - self.shift_win_size]))), s[:, :, shift_range + 1:]], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_1504": {
                "input": {
                    "value": "w_g",
                    "type": "Name",
                    "possible_values": [
                        [
                            "g * w_c + (1 - g) * prev_w",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_1513": {
                "name": {
                    "value": "init_read_vector",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.memory_vector_dim",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_linear_initializer(self.memory_vector_dim)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "self.init_mode_other_params == 'learned'",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "expand_dims_1518": {
                "input": {
                    "value": "read_vector_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tanh(tf.get_variable(name='init_read_vector', shape=self.memory_vector_dim, initializer=create_linear_initializer(self.memory_vector_dim), trainable=self.init_mode_other_params == 'learned'))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(read_vector_init, 0), 0), [batch_size, self.read_head_num, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_1521": {
                "name": {
                    "value": "init_w",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.read_head_num + self.write_head_num, self.memory_size]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_linear_initializer(self.memory_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "self.init_mode_other_params == 'learned'",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "expand_dims_1526": {
                "input": {
                    "value": "w_init",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(tf.get_variable(name='init_w', shape=[self.read_head_num + self.write_head_num, self.memory_size], initializer=create_linear_initializer(self.memory_size), trainable=self.init_mode_other_params == 'learned'), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(w_init, 0), [batch_size, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_1540": {
                "input": {
                    "value": "M",
                    "type": "Call",
                    "possible_values": [
                        [
                            "prev_M",
                            "Name"
                        ],
                        [
                            "M * forget_vectors + add_vectors",
                            "BinOp"
                        ],
                        [
                            "tf.tanh(tf.get_variable(name='init_M', shape=[self.memory_size, self.memory_vector_dim], initializer=create_linear_initializer(self.memory_vector_dim)))",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(M, 0), [batch_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.random_normal(shape=[self.memory_size, self.memory_vector_dim], mean=0.0, stddev=0.5, name='init_M')",
                            "Call"
                        ],
                        [
                            "tf.get_variable(name='init_M', shape=[self.memory_size, self.memory_vector_dim], initializer=tf.constant_initializer(1e-06), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "TensorShape_1552": {
                "dims": {
                    "value": "[self.memory_size * self.memory_vector_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_163": {
                "input": {
                    "value": "input_logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.input_logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(input_logits, 0), tile)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_173": {
                "input": {
                    "value": "state_logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.state_logits",
                            "Attribute"
                        ],
                        [
                            "tf.tile(tf.expand_dims(state_logits, 0), tile)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "name_scope_191": {
                "name": {
                    "value": "m_step",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_195": {
                "variable": {
                    "value": "in_caps",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(in_w, -1) * input_predictions",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_200": {
                "variable": {
                    "value": "state_caps",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(state_w, -1) * state_predictions",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_266": {
                "name": {
                    "value": "m_step",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_270": {
                "variable": {
                    "value": "in_caps",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(in_w, -1) * input_predictions",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_276": {
                "variable": {
                    "value": "state_caps",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.expand_dims(state_w, -1) * state_predictions",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_291": {
                "input": {
                    "value": "caps",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(caps)",
                            "Call"
                        ],
                        [
                            "self._activation(caps)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_292": {
                "input": {
                    "value": "caps",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(caps)",
                            "Call"
                        ],
                        [
                            "self._activation(caps)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_614": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_625": {
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_1452": {
                "input": {
                    "value": "tf.sigmoid(erase_parameters)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tanh_1453": {
                "x": {
                    "value": "add_parameters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "parameters[:, num_parameters_per_head * num_heads + num_parameters_erase_per_write_head * self.write_head_num:]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(add_parameters, [batch_size, self.write_head_num, num_parameters_erase_per_write_head])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_1529": {
                "name": {
                    "value": "init_M",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.memory_size, self.memory_vector_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "create_linear_initializer(self.memory_vector_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_1535": {
                "variable": {
                    "value": "M",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "init_M",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.memory_size, self.memory_vector_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1e-06)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "flatten_1606": {
                "structure": {
                    "value": "self._cell.state_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_159": {
                "input": {
                    "value": "input_predictions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.einsum(ein_not, inputs, self.input_kernel)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_169": {
                "input": {
                    "value": "state_predictions",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.einsum(ein_not, state, self.state_kernel)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_192": {
                "name": {
                    "value": "m_step_in",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "name_scope_197": {
                "name": {
                    "value": "m_step_state",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_214": {
                "input": {
                    "value": "caps",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(caps)",
                            "Call"
                        ],
                        [
                            "self._activation(caps)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_215": {
                "input": {
                    "value": "caps",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self._activation(caps)",
                            "Call"
                        ],
                        [
                            "self._activation(caps)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-3",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "name_scope_267": {
                "name": {
                    "value": "m_step_in",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "name_scope_273": {
                "name": {
                    "value": "m_step_state",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_1452": {
                "x": {
                    "value": "erase_parameters",
                    "type": "Name",
                    "possible_values": [
                        [
                            "parameters[:, num_parameters_per_head * num_heads:num_parameters_per_head * num_heads + num_parameters_erase_per_write_head * self.write_head_num]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(erase_parameters, [batch_size, self.write_head_num, num_parameters_erase_per_write_head])",
                            "Call"
                        ]
                    ]
                }
            },
            "TensorShape_1496": {
                "dims": {
                    "value": "[self.memory_size - self.shift_win_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_195": {
                "input": {
                    "value": "in_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.input_probability_fn(in_l)",
                            "Call"
                        ],
                        [
                            "self.input_probability_fn(in_l)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_200": {
                "input": {
                    "value": "state_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.recurrent_probability_fn(state_l)",
                            "Call"
                        ],
                        [
                            "self.recurrent_probability_fn(state_l)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_271": {
                "input": {
                    "value": "in_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.input_probability_fn(in_l)",
                            "Call"
                        ],
                        [
                            "self.input_probability_fn(in_l)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_277": {
                "input": {
                    "value": "state_w",
                    "type": "Call",
                    "possible_values": [
                        [
                            "self.recurrent_probability_fn(state_l)",
                            "Call"
                        ],
                        [
                            "self.recurrent_probability_fn(state_l)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_1537": {
                "value": {
                    "value": "1e-06",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/components/rnn_cell_impl.py": {
        "tensorflow": {
            "executing_eagerly_142": {
                "variable": {
                    "value": "is_eager",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "InputSpec_218": {
                "variable": {
                    "value": "self.input_spec",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ndim": {
                    "value": "3",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mod_267": {
                "variable": {
                    "value": "state_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "x2": {
                    "value": "self._t_reset",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_269": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, state], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._gate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_271": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._gate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_273": {
                "variable": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_274": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.sigmoid(gate_inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.sigmoid(gate_inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensordot_278": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, r_state], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._candidate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_280": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "candidate",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, r_state], 2), self._candidate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(candidate, self._candidate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, r_state], 2), self._candidate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(candidate, self._candidate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._candidate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_285": {
                "variable": {
                    "value": "new_h_current",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "state_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(time, self._t_reset)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_290": {
                "input": {
                    "value": "tmp",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(state_index, 0), 0), tf.constant([1.0]), tf.constant([self._t_reset]))",
                            "BinOp"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(replicate_index, 0), 0), tf.constant([1.0]), tf.constant([self._num_replicates]))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "mod_350": {
                "variable": {
                    "value": "state_index_in_group",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "x2": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floor_div_351": {
                "variable": {
                    "value": "group_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "time",
                    "type": "Variable",
                    "possible_values": []
                },
                "y": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "mod_352": {
                "variable": {
                    "value": "replicate_index",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "group_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.floor_div(time, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "x2": {
                    "value": "self._num_replicates",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_354": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, state], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._gate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_356": {
                "variable": {
                    "value": "gate_inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._gate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_358": {
                "variable": {
                    "value": "value",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "gate_inputs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, state], 2), self._gate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(gate_inputs, self._gate_bias)",
                            "Call"
                        ]
                    ]
                }
            },
            "split_359": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "Call",
                    "possible_values": [
                        [
                            "math_ops.sigmoid(gate_inputs)",
                            "Call"
                        ],
                        [
                            "math_ops.sigmoid(gate_inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tensordot_363": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "array_ops.concat([inputs, r_state], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "self._candidate_kernel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axes": {
                    "value": "[[-1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "bias_add_365": {
                "variable": {
                    "value": "candidate",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "candidate",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.tensordot(array_ops.concat([inputs, r_state], 2), self._candidate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(candidate, self._candidate_bias)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(array_ops.concat([inputs, r_state], 2), self._candidate_kernel, [[-1], [0]])",
                            "Call"
                        ],
                        [
                            "nn_ops.bias_add(candidate, self._candidate_bias)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "self._candidate_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_370": {
                "variable": {
                    "value": "new_h_current",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "new_h",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ]
                    ]
                },
                "indices": {
                    "value": "replicate_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(group_index, self._num_replicates)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_376": {
                "input": {
                    "value": "tmp",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(state_index, 0), 0), tf.constant([1.0]), tf.constant([self._t_reset]))",
                            "BinOp"
                        ],
                        [
                            "1 - tf.scatter_nd(tf.expand_dims(tf.expand_dims(replicate_index, 0), 0), tf.constant([1.0]), tf.constant([self._num_replicates]))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "equal_378": {
                "variable": {
                    "value": "reset_flag",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "state_index_in_group + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "self._group_size",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_379": {
                "variable": {
                    "value": "new_h_reset",
                    "type": "Variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "reset_flag",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.equal(state_index_in_group + 1, self._group_size)",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : new_h * reset_mask",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : new_h",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "executing_eagerly_95": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TensorShape_228": {
                "dims": {
                    "value": "[self._t_reset, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_341": {
                "dims": {
                    "value": "[self._num_replicates, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_88": {
                "variable": {
                    "value": "scope",
                    "type": "Variable",
                    "possible_values": []
                },
                "name_or_scope": {
                    "value": "vs.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "self._rnn_get_variable",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_148": {
                "name": {
                    "value": "type(self).__name__ + 'ZeroState'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_232": {
                "dims": {
                    "value": "[self._t_reset, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_269": {
                "values": {
                    "value": "[inputs, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_278": {
                "values": {
                    "value": "[inputs, r_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "scatter_nd_288": {
                "indices": {
                    "value": "tf.expand_dims(tf.expand_dims(state_index, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.constant([1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.constant([self._t_reset])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "TensorShape_345": {
                "dims": {
                    "value": "[self._num_replicates, self._num_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_354": {
                "values": {
                    "value": "[inputs, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_363": {
                "values": {
                    "value": "[inputs, r_state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "scatter_nd_373": {
                "indices": {
                    "value": "tf.expand_dims(tf.expand_dims(replicate_index, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "updates": {
                    "value": "tf.constant([1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.constant([self._num_replicates])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_82": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "Call",
                    "possible_values": [
                        [
                            "getattr(self, scope_attrname, None)",
                            "Call"
                        ],
                        [
                            "vs.variable_scope(vs.get_variable_scope(), custom_getter=self._rnn_get_variable)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "custom_getter": {
                    "value": "self._rnn_get_variable",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_289": {
                "input": {
                    "value": "state_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(time, self._t_reset)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_289": {
                "value": {
                    "value": "[self._t_reset]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_374": {
                "input": {
                    "value": "replicate_index",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.mod(group_index, self._num_replicates)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_375": {
                "value": {
                    "value": "[self._num_replicates]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_scope_88": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_99": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_249": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_260": {
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_102": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/components/sessions.py": {
        "tensorflow": {
            "ChiefSessionCreator_108": {
                "variable": {
                    "value": "session_creator",
                    "type": "Variable",
                    "possible_values": []
                },
                "scaffold": {
                    "value": "scaffold",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "master": {
                    "value": "master",
                    "type": "Name",
                    "possible_values": [
                        [
                            "''",
                            "MethodArgument"
                        ]
                    ]
                },
                "config": {
                    "value": "config",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "MonitoredSession_130": {
                "session_creator": {
                    "value": "session_creator",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.train.ChiefSessionCreator(scaffold=scaffold, checkpoint_dir=checkpoint_dir, master=master, config=config)",
                            "Call"
                        ]
                    ]
                },
                "hooks": {
                    "value": "all_hooks",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "stop_grace_period_secs": {
                    "value": "stop_grace_period_secs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "120",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "StepCounterHook_117": {
                "output_dir": {
                    "value": "checkpoint_dir",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "every_n_steps": {
                    "value": "log_step_count_steps",
                    "type": "Name",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "summary_writer": {
                    "value": "tf.summary.FileWriter(checkpoint_dir)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "FileWriter_118": {
                "logdir": {
                    "value": "checkpoint_dir",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/evaluators/task_evaluator.py": {
        "tensorflow": {
            "reduce_sum_168": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reduce_sum(loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_169": {
                "variable": {
                    "value": "norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "norm",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.reduce_sum(norm)",
                            "Call"
                        ]
                    ]
                }
            },
            "name_scope_107": {
                "name": {
                    "value": "evaluate",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "string_input_producer_131": {
                "variable": {
                    "value": "data_queue",
                    "type": "Variable",
                    "possible_values": []
                },
                "string_tensor": {
                    "value": "data_queue_elements",
                    "type": "Name",
                    "possible_values": [
                        [
                            "data_queue_elements[start_utt_ind:number_of_elements]",
                            "Subscript"
                        ]
                    ]
                },
                "shuffle": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "seed": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "capacity": {
                    "value": "self.batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/evaluators/task_loss_evaluator.py": {
        "tensorflow": {
            "name_scope_44": {
                "name": {
                    "value": "evaluate_logits",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "name_scope_72": {
                "name": {
                    "value": "evaluate_loss",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/anchor_deepattractornet_softmax_loss.py": {
        "tensorflow": {
            "reshape_234": {
                "variable": {
                    "value": "V",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "emb_vec",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "logits['bin_emb']",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, -1, feat_dim, emb_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "V",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "matmul_258": {
                "variable": {
                    "value": "prod_1",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "V",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(emb_vec, [self.batch_size, -1, feat_dim, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "V / (tf.norm(V, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "AVT",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_269": {
                "variable": {
                    "value": "X",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mix_to_mask",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ],
                        [
                            "targets['mix_to_mask']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "X",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "multiply_270": {
                "variable": {
                    "value": "reconstructions",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(prod_1, axis=-1, name='M')",
                            "Call"
                        ],
                        [
                            "prod_1",
                            "Name"
                        ],
                        [
                            "tf.nn.sigmoid(prod_1, name='M')",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid(prod_1, name='M')",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "X",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(mix_to_mask, -1, name='X')",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_271": {
                "variable": {
                    "value": "reconstructions",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "reconstructions",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.multiply(masks, X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(reconstructions, perm=[3, 0, 1, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_273": {
                "variable": {
                    "value": "S",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "spectrogram_targets",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ],
                        [
                            "targets['multi_targets']",
                            "Subscript"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_227": {
                "name": {
                    "value": "anchor_deepattractornet_loss",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_240": {
                "variable": {
                    "value": "anchors",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(anchors, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self.batch_size, time_dim, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_246": {
                "variable": {
                    "value": "speaker_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "speaker_logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['speaker_logits']",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.expand_dims(speaker_logits, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(speaker_logits, 1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_255": {
                "variable": {
                    "value": "anchors",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_256": {
                "variable": {
                    "value": "anchors",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, time_dim, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_261": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "prod_1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.matmul(V, anchors, transpose_a=False, transpose_b=True, name='AVT')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "name": {
                    "value": "M",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_sum_277": {
                "variable": {
                    "value": "vad_sum",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "targets['vad_targets']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "where_278": {
                "variable": {
                    "value": "bin_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "vad_sum > 1",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones([self.batch_size, time_dim]) * overlap_weight",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.ones([self.batch_size, time_dim])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_282": {
                "variable": {
                    "value": "bin_weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bin_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.where(vad_sum > 1, tf.ones([self.batch_size, time_dim]) * overlap_weight, tf.ones([self.batch_size, time_dim]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_weights, -1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_float_286": {
                "variable": {
                    "value": "norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum(seq_length) * feat_dim",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_231": {
                "input": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "shape_237": {
                "input": {
                    "value": "V",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(emb_vec, [self.batch_size, -1, feat_dim, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "V / (tf.norm(V, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_248": {
                "variable": {
                    "value": "speaker_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "speaker_logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['speaker_logits']",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.expand_dims(speaker_logits, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(speaker_logits, 1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_240": {
                "input": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_265": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prod_1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.matmul(V, anchors, transpose_a=False, transpose_b=True, name='AVT')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "M",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sigmoid_267": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prod_1",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.matmul(V, anchors, transpose_a=False, transpose_b=True, name='AVT')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "M",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_281": {
                "shape": {
                    "value": "[self.batch_size, time_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_283": {
                "input_tensor": {
                    "value": "bin_weights",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.where(vad_sum > 1, tf.ones([self.batch_size, time_dim]) * overlap_weight, tf.ones([self.batch_size, time_dim]))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_weights, -1)",
                            "Call"
                        ],
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                }
            },
            "to_float_283": {
                "x": {
                    "value": "feat_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "spectrogram_targets.get_shape()[2]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "norm_236": {
                "tensor": {
                    "value": "V",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.reshape(emb_vec, [self.batch_size, -1, feat_dim, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "V / (tf.norm(V, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "norm_243": {
                "tensor": {
                    "value": "anchors",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(anchors, 0), 0), [self.batch_size, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "anchors / (tf.norm(anchors, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "anchors * anchors_scale",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(anchors, axis=1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.tile(anchors, [1, time_dim, 1, 1])",
                            "Call"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ],
                        [
                            "logits['anchors']",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "ones_280": {
                "shape": {
                    "value": "[self.batch_size, time_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_286": {
                "input_tensor": {
                    "value": "seq_length",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ],
                        [
                            "seq_length['bin_emb']",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/crossentropy_loss.py": {
        "tensorflow": {
            "squeeze_33": {
                "variable": {
                    "value": "spkids",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "targets['spkids']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_mean_37": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "logits['spkest']",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_mean(logits, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/crossentropy_multi_loss.py": {
        "tensorflow": {
            "reduce_mean_47": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['spkest']",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_mean(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [self.batch_size, nrS, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_50": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['spkest']",
                            "Subscript"
                        ],
                        [
                            "tf.reduce_mean(logits, 1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [self.batch_size, nrS, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[self.batch_size, nrS, -1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/dc_pit_loss.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/loss_computers/deepclusteringnoise_loss.py": {
        "tensorflow": {
            "exp_154": {
                "x": {
                    "value": "-self.alpha * (snr - self.beta)",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/dummy_loss.py": {
        "tensorflow": {
            "constant_26": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/loss_computers/intravar2centervar_rat_loss.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/loss_computers/l41_loss.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/loss_computers/ms_loss.py": {
        "tensorflow": {
            "squeeze_19": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_40": {
                "variable": {
                    "value": "seq_length_mask",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tmp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_47": {
                "variable": {
                    "value": "targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones([batch_size, nr_act_spk]), tf.zeros([batch_size, nr_spk - nr_act_spk])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_49": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(logits - targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_50": {
                "variable": {
                    "value": "norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "batch_size * nr_spk",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "squeeze_60": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_72": {
                "variable": {
                    "value": "targets",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones([batch_size, nr_act_spk]), tf.zeros([batch_size, nr_spk - nr_act_spk])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "variable": {
                    "value": "loss",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.square(logits - targets)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "to_float_75": {
                "variable": {
                    "value": "norm",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "batch_size * nr_spk",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sigmoid_24": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_44": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "divide_45": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.expand_dims(tf.to_float(seq_length), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_65": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_70": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_32": {
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "logits * seq_length_mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.divide(logits, tf.expand_dims(tf.to_float(seq_length), -1))",
                            "Call"
                        ],
                        [
                            "logits['act_logit']",
                            "Subscript"
                        ],
                        [
                            "tf.squeeze(logits, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(logits, 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_49": {
                "x": {
                    "value": "logits - targets",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_74": {
                "x": {
                    "value": "logits - targets",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_36": {
                "input": {
                    "value": "tf.concat([tf.ones([second_dim, seq_length[utt_ind]]), tf.zeros([second_dim, max_len - seq_length[utt_ind]])], -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_45": {
                "input": {
                    "value": "tf.to_float(seq_length)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_47": {
                "shape": {
                    "value": "[batch_size, nr_act_spk]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_47": {
                "shape": {
                    "value": "[batch_size, nr_spk - nr_act_spk]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_72": {
                "shape": {
                    "value": "[batch_size, nr_act_spk]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_72": {
                "shape": {
                    "value": "[batch_size, nr_spk - nr_act_spk]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_37": {
                "values": {
                    "value": "[tf.ones([second_dim, seq_length[utt_ind]]), tf.zeros([second_dim, max_len - seq_length[utt_ind]])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "to_float_45": {
                "x": {
                    "value": "seq_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "seq_length['features']",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_38": {
                "shape": {
                    "value": "[second_dim, seq_length[utt_ind]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_38": {
                "shape": {
                    "value": "[second_dim, max_len - seq_length[utt_ind]]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/attractor.py": {
        "tensorflow": {
            "to_float_56": {
                "variable": {
                    "value": "usedbins",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "usedbins",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(usedbins)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_73": {
                "variable": {
                    "value": "numerator_A",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "V",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(data, [batch_size, nrS, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [batch_size, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ]
                    ]
                },
                "transpose_a": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "YTV",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "where_83": {
                "variable": {
                    "value": "nb_bins_class",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.less(nb_bins_class, tf.ones_like(nb_bins_class))",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(nb_bins_class)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "nb_bins_class",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(Y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(Y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.less(nb_bins_class, tf.ones_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(nb_bins_class, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_85": {
                "variable": {
                    "value": "nb_bins_class",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "nb_bins_class",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(Y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(Y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.less(nb_bins_class, tf.ones_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(nb_bins_class, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_86": {
                "variable": {
                    "value": "denominator_A",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "nb_bins_class",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(Y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(Y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.less(nb_bins_class, tf.ones_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(nb_bins_class, -1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, emb_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "denominator_A",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "divide_87": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "numerator_A",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.matmul(Y, V, transpose_a=True, transpose_b=False, name='YTV')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(numerator_A)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "denominator_A",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(nb_bins_class, [1, 1, emb_dim], name='denominator_A')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "A",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_59": {
                "variable": {
                    "value": "ubresh",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "usedbins",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(usedbins)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, 1, -1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "ebresh",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_60": {
                "variable": {
                    "value": "V",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, nrS, -1, emb_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "V",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "multiply_61": {
                "variable": {
                    "value": "V",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "V",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(data, [batch_size, nrS, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [batch_size, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "ubresh",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(usedbins, [batch_size, 1, -1, 1], name='ebresh')",
                            "Call"
                        ],
                        [
                            "tf.reshape(usedbins, [batch_size, -1, 1], name='ebresh')",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_63": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, nrS, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_64": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_66": {
                "variable": {
                    "value": "ubresh",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "usedbins",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[2]",
                            "Subscript"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.to_float(usedbins)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "ebresh",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_67": {
                "variable": {
                    "value": "V",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "data",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, emb_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "V",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "multiply_68": {
                "variable": {
                    "value": "V",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "V",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(data, [batch_size, nrS, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.reshape(data, [batch_size, -1, emb_dim], name='V')",
                            "Call"
                        ],
                        [
                            "tf.multiply(V, ubresh)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "ubresh",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(usedbins, [batch_size, 1, -1, 1], name='ebresh')",
                            "Call"
                        ],
                        [
                            "tf.reshape(usedbins, [batch_size, -1, 1], name='ebresh')",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_69": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, nrS]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "Y",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "to_float_70": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_71": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "ubresh",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(usedbins, [batch_size, 1, -1, 1], name='ebresh')",
                            "Call"
                        ],
                        [
                            "tf.reshape(usedbins, [batch_size, -1, 1], name='ebresh')",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_75": {
                "variable": {
                    "value": "numerator_A",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "numerator_A",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.matmul(Y, V, transpose_a=True, transpose_b=False, name='YTV')",
                            "Call"
                        ],
                        [
                            "tf.squeeze(numerator_A)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_76": {
                "variable": {
                    "value": "Y",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_78": {
                "variable": {
                    "value": "nb_bins_class",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_81": {
                "variable": {
                    "value": "nb_bins_class",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "Y",
                    "type": "Call",
                    "possible_values": [
                        [
                            "ubresh",
                            "Name"
                        ],
                        [
                            "tf.tile(Y, [1, nrS, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.reshape(labels, [batch_size, -1, nrS], name='Y')",
                            "Call"
                        ],
                        [
                            "tf.to_float(Y)",
                            "Call"
                        ],
                        [
                            "tf.multiply(Y, ubresh)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(Y, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "l2_normalize_90": {
                "variable": {
                    "value": "A",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "A",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.divide(numerator_A, denominator_A, name='A')",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(A, axis=-1, epsilon=1e-12)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "1e-12",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "less_83": {
                "x": {
                    "value": "nb_bins_class",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(Y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(Y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.less(nb_bins_class, tf.ones_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(nb_bins_class, -1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.ones_like(nb_bins_class)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_83": {
                "input": {
                    "value": "nb_bins_class",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(Y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(Y, axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.less(nb_bins_class, tf.ones_like(nb_bins_class)), tf.ones_like(nb_bins_class), nb_bins_class)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(nb_bins_class, -1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/averager.py": {
        "tensorflow": {
            "reduce_sum_50": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "input * weights",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "average_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['average_dim'])",
                            "Call"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "einsum_53": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "einsum",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.conf['einsum']",
                            "Subscript"
                        ],
                        [
                            "False",
                            "Constant"
                        ]
                    ]
                },
                "*inputs": {
                    "value": "input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "weights",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ones(tf.shape(input))",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "ones_44": {
                "variable": {
                    "value": "weights",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(input)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tanh_57": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(input * weights, average_dim)",
                            "Call"
                        ],
                        [
                            "output / (tf.reduce_sum(weights, average_dim) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum(einsum, input, weights)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_59": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(input * weights, average_dim)",
                            "Call"
                        ],
                        [
                            "output / (tf.reduce_sum(weights, average_dim) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum(einsum, input, weights)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_44": {
                "input": {
                    "value": "input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "weights",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.ones(tf.shape(input))",
                            "Call"
                        ],
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "average_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['average_dim'])",
                            "Call"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "relu_61": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(input * weights, average_dim)",
                            "Call"
                        ],
                        [
                            "output / (tf.reduce_sum(weights, average_dim) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum(einsum, input, weights)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_63": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_sum(input * weights, average_dim)",
                            "Call"
                        ],
                        [
                            "output / (tf.reduce_sum(weights, average_dim) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "tf.einsum(einsum, input, weights)",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/capsnet.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/concat.py": {
        "tensorflow": {
            "concat_87": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "inputs",
                    "type": "ListComp",
                    "possible_values": [
                        [
                            "[inp + tf.random_normal(tf.shape(inp), stddev=inp_noise) for (inp, inp_noise) in zip(inputs, inputs_noise)]",
                            "ListComp"
                        ],
                        [
                            "[inputs[ind] for (ind, sel) in enumerate(select_inputs) if sel]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_54": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_80": {
                "variable": {
                    "value": "multiplicates",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "multiplicates",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.ones(out_dim, np.int).tolist()",
                            "Call"
                        ],
                        [
                            "tf.stack(multiplicates)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_61": {
                "variable": {
                    "value": "inp_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inp, expand_dimension)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_66": {
                "variable": {
                    "value": "new_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[inp_shape[:-2], [new_last_shape]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_67": {
                "variable": {
                    "value": "inputs[ind]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inp, expand_dimension)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "new_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([inp_shape[:-2], [new_last_shape]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_84": {
                "variable": {
                    "value": "inp",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inp, expand_dimension)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "expand_dimension",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['expand_dimension'])",
                            "Call"
                        ],
                        [
                            "-2",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "tile_85": {
                "variable": {
                    "value": "inputs[ind]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "input": {
                    "value": "inp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inp, expand_dimension)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "multiplicates",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.ones(out_dim, np.int).tolist()",
                            "Call"
                        ],
                        [
                            "tf.stack(multiplicates)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_76": {
                "input": {
                    "value": "inputs[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "shape_52": {
                "input": {
                    "value": "inp",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(inp, expand_dimension)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/constant_generator.py": {
        "tensorflow": {
            "shape_36": {
                "input": {
                    "value": "output",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "constant_value * np.ones(tensor_shape, dtype=np.float32)",
                            "BinOp"
                        ],
                        [
                            "output + tf.random_normal(tf.shape(output), stddev=output_noise)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dbgru.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/dblstm.py": {
        "tensorflow": {
            "variable_scope_85": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_120": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.stack([batch_size] + other_dims.as_list() + [-1] + [num_output_units], 0))",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "output[:, :, -1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_125": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "tf.concat(output, 2)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.stack([batch_size] + other_dims.as_list() + [-1] + [num_output_units], 0))",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "output[:, :, -1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.stack([batch_size] + other_dims.as_list() + [-1] + [num_output_units], 0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_98": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(inputs, [batch_size * np.prod(other_dims), -1, num_inp_units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * np.prod(other_dims), -1, num_inp_units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_99": {
                "variable": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_seq_length",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_seq_length, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(input_seq_length, [1, np.prod(other_dims)])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_seq_length, [-1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_100": {
                "variable": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_seq_length",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_seq_length, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(input_seq_length, [1, np.prod(other_dims)])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_seq_length, [-1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, np.prod(other_dims)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_101": {
                "variable": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input_seq_length",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_seq_length, -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(input_seq_length, [1, np.prod(other_dims)])",
                            "Call"
                        ],
                        [
                            "tf.reshape(input_seq_length, [-1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dropout_115": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "(logits, logits)",
                            "Tuple"
                        ],
                        [
                            "blstm_layers[l](logits, input_seq_length, 'layer' + str(l))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(logits, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "float(self.conf['dropout'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_125": {
                "values": {
                    "value": "[batch_size] + other_dims.as_list() + [-1] + [num_output_units]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_88": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(inputs, [batch_size * np.prod(other_dims), -1, num_inp_units])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dblstm_capsnet.py": {
        "tensorflow": {
            "reshape_107": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'inputs')",
                            "Call"
                        ],
                        [
                            "tf.identity(primary_capsules, 'primary_capsules')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0].value, tf.shape(output)[1], output_dim])",
                            "Call"
                        ],
                        [
                            "caps_blstm_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0].value, tf.shape(output)[1], output_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_64": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "identity_72": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                },
                "name": {
                    "value": "inputs",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "identity_73": {
                "variable": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_seq_length",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.identity(input_seq_length, 'input_seq_length')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "input_seq_length",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_81": {
                "variable": {
                    "value": "primary_capsules",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "primary_capsules",
                    "type": "Call",
                    "possible_values": [
                        [
                            "primary_capsules_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.reshape(primary_capsules, [output.shape[0].value, tf.shape(output)[1], num_capsules * 2, capsule_dim])",
                            "Call"
                        ],
                        [
                            "ops.squash(primary_capsules)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[output.shape[0].value, tf.shape(output)[1], num_capsules * 2, capsule_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "identity_86": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "primary_capsules",
                    "type": "Call",
                    "possible_values": [
                        [
                            "primary_capsules_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.reshape(primary_capsules, [output.shape[0].value, tf.shape(output)[1], num_capsules * 2, capsule_dim])",
                            "Call"
                        ],
                        [
                            "ops.squash(primary_capsules)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "primary_capsules",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_71": {
                "name_or_scope": {
                    "value": "primary_capsule",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_90": {
                "name_or_scope": {
                    "value": "'layer%d' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_104": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'inputs')",
                            "Call"
                        ],
                        [
                            "tf.identity(primary_capsules, 'primary_capsules')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0].value, tf.shape(output)[1], output_dim])",
                            "Call"
                        ],
                        [
                            "caps_blstm_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "float(self.conf['dropout'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_67": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_107": {
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'inputs')",
                            "Call"
                        ],
                        [
                            "tf.identity(primary_capsules, 'primary_capsules')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0].value, tf.shape(output)[1], output_dim])",
                            "Call"
                        ],
                        [
                            "caps_blstm_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_81": {
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.identity(inputs, 'inputs')",
                            "Call"
                        ],
                        [
                            "tf.identity(primary_capsules, 'primary_capsules')",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [output.shape[0].value, tf.shape(output)[1], output_dim])",
                            "Call"
                        ],
                        [
                            "caps_blstm_layer(output, input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dbr_capsnet.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/dbresetgru.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/dbresetlstm.py": {
        "tensorflow": {
            "expand_dims_152": {
                "input": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "range_155": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_156": {
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_maxT, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_157": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_maxT, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "input": {
                    "value": "range(0, num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_162": {
                "variable": {
                    "value": "numbers_to_k",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "numbers_to_k",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(range(0, num_replicas), 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_k, [batch_size, max_length, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, max_length, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_167": {
                "variable": {
                    "value": "max_tau_tf",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.constant(max_tau, dtype=int_dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, max_length, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "mod_168": {
                "variable": {
                    "value": "tau_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "numbers_to_maxT - group_size * numbers_to_k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "t_reset",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "minimum_169": {
                "variable": {
                    "value": "tau_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tau_forward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.mod(numbers_to_maxT - group_size * numbers_to_k, t_reset)",
                            "Call"
                        ],
                        [
                            "tf.minimum(tau_forward, max_tau_tf)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_tau_tf",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.constant(max_tau, dtype=int_dtype), [batch_size, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_170": {
                "variable": {
                    "value": "tau_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "reversed_numbers_to_maxT - group_size * numbers_to_k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "t_reset",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "minimum_171": {
                "variable": {
                    "value": "tau_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tau_backward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.mod(reversed_numbers_to_maxT - group_size * numbers_to_k, t_reset)",
                            "Call"
                        ],
                        [
                            "tf.minimum(tau_backward, max_tau_tf)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_tau_tf",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.constant(max_tau, dtype=int_dtype), [batch_size, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_174": {
                "variable": {
                    "value": "forward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(numbers_to_maxT - tau_forward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_178": {
                "variable": {
                    "value": "backward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_182": {
                "variable": {
                    "value": "backward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_186": {
                "variable": {
                    "value": "forward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(numbers_to_maxT - tau_backward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "range_190": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_191": {
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_192": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, max_length, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_193": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_194": {
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_195": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_196": {
                "variable": {
                    "value": "stacked_forward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, forward_indices_for_forward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_197": {
                "variable": {
                    "value": "stacked_backward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, backward_indices_for_forward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_198": {
                "variable": {
                    "value": "stacked_forward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, forward_indices_for_backward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_199": {
                "variable": {
                    "value": "stacked_backward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, backward_indices_for_backward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_202": {
                "variable": {
                    "value": "forward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "forward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_forward_indices_for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, forward_indices_for_forward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_207": {
                "variable": {
                    "value": "backward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "backward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_backward_indices_for_backward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, backward_indices_for_backward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_212": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "backward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_backward_indices_for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, backward_indices_for_forward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_213": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "forward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_forward_indices_for_backward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, forward_indices_for_backward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_225": {
                "variable": {
                    "value": "for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_forward, backward_for_forward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_226": {
                "variable": {
                    "value": "for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_backward, backward_for_backward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_127": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_141": {
                "input": {
                    "value": "forward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_167": {
                "value": {
                    "value": "max_tau",
                    "type": "Name",
                    "possible_values": [
                        [
                            "previous_t_reset - 1",
                            "BinOp"
                        ],
                        [
                            "np.expand_dims(np.expand_dims(np.expand_dims(max_tau, -1), -1), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mod_174": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(numbers_to_maxT - tau_forward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_178": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_182": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_186": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(numbers_to_maxT - tau_backward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_215": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(backward_output, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, num_replicas, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_83": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ceil_175": {
                "x": {
                    "value": "tf.truediv(numbers_to_maxT - tau_forward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_179": {
                "x": {
                    "value": "tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_183": {
                "x": {
                    "value": "tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_187": {
                "x": {
                    "value": "tf.truediv(numbers_to_maxT - tau_backward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_219": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(forward_output, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, num_replicas, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_105": {
                "variable": {
                    "value": "multistate_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_107": {
                "variable": {
                    "value": "multistate_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "multistate_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(multistate_input, tf.constant([1, 1, num_replicates, 1]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.constant([1, 1, num_replicates, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "truediv_175": {
                "x": {
                    "value": "numbers_to_maxT - tau_forward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_179": {
                "x": {
                    "value": "reversed_numbers_to_maxT - tau_forward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_183": {
                "x": {
                    "value": "reversed_numbers_to_maxT - tau_backward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_187": {
                "x": {
                    "value": "numbers_to_maxT - tau_backward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_215": {
                "input": {
                    "value": "backward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_219": {
                "input": {
                    "value": "forward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_86": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_107": {
                "value": {
                    "value": "[1, 1, num_replicates, 1]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dbresetlstm_insert_additional_input.py": {
        "tensorflow": {
            "expand_dims_174": {
                "input": {
                    "value": "sequence_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "range_177": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_178": {
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_maxT, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_179": {
                "variable": {
                    "value": "numbers_to_maxT",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "numbers_to_maxT",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(0, max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(numbers_to_maxT, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_maxT, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_183": {
                "input": {
                    "value": "range(0, num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_184": {
                "variable": {
                    "value": "numbers_to_k",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "numbers_to_k",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(range(0, num_replicas), 0), 0)",
                            "Call"
                        ],
                        [
                            "tf.tile(numbers_to_k, [batch_size, max_length, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, max_length, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_189": {
                "variable": {
                    "value": "max_tau_tf",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.constant(max_tau, dtype=int_dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_size, max_length, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "mod_190": {
                "variable": {
                    "value": "tau_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "numbers_to_maxT - group_size * numbers_to_k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "t_reset",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "minimum_191": {
                "variable": {
                    "value": "tau_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tau_forward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.mod(numbers_to_maxT - group_size * numbers_to_k, t_reset)",
                            "Call"
                        ],
                        [
                            "tf.minimum(tau_forward, max_tau_tf)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_tau_tf",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.constant(max_tau, dtype=int_dtype), [batch_size, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_192": {
                "variable": {
                    "value": "tau_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x1": {
                    "value": "reversed_numbers_to_maxT - group_size * numbers_to_k",
                    "type": "BinOp",
                    "possible_values": []
                },
                "x2": {
                    "value": "t_reset",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "minimum_193": {
                "variable": {
                    "value": "tau_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tau_backward",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.mod(reversed_numbers_to_maxT - group_size * numbers_to_k, t_reset)",
                            "Call"
                        ],
                        [
                            "tf.minimum(tau_backward, max_tau_tf)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "max_tau_tf",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.tile(tf.constant(max_tau, dtype=int_dtype), [batch_size, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_196": {
                "variable": {
                    "value": "forward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(numbers_to_maxT - tau_forward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_200": {
                "variable": {
                    "value": "backward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_204": {
                "variable": {
                    "value": "backward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "cast_208": {
                "variable": {
                    "value": "forward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.mod(tf.ceil(tf.truediv(numbers_to_maxT - tau_backward, previous_group_size)), previous_num_replicas)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "range_212": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_213": {
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_214": {
                "variable": {
                    "value": "ra1",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra1",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(batch_size)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra1, -1), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra1, [1, max_length, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, max_length, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "range_215": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_216": {
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_217": {
                "variable": {
                    "value": "ra2",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "ra2",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.range(max_length)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(ra2, 0), -1)",
                            "Call"
                        ],
                        [
                            "tf.tile(ra2, [batch_size, 1, num_replicas])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[batch_size, 1, num_replicas]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_218": {
                "variable": {
                    "value": "stacked_forward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, forward_indices_for_forward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_219": {
                "variable": {
                    "value": "stacked_backward_indices_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, backward_indices_for_forward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_220": {
                "variable": {
                    "value": "stacked_forward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, forward_indices_for_backward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_221": {
                "variable": {
                    "value": "stacked_backward_indices_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[ra1, ra2, backward_indices_for_backward]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_224": {
                "variable": {
                    "value": "forward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "forward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_forward_indices_for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, forward_indices_for_forward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_229": {
                "variable": {
                    "value": "backward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "backward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_backward_indices_for_backward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, backward_indices_for_backward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_234": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "backward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[1]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_backward_indices_for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, backward_indices_for_forward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "gather_nd_235": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "forward_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "replicas[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "stacked_forward_indices_for_backward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.stack([ra1, ra2, forward_indices_for_backward], axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_247": {
                "variable": {
                    "value": "for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_forward, backward_for_forward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_248": {
                "variable": {
                    "value": "for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(forward_for_backward, backward_for_backward)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_149": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_163": {
                "input": {
                    "value": "forward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "constant_189": {
                "value": {
                    "value": "max_tau",
                    "type": "Name",
                    "possible_values": [
                        [
                            "previous_t_reset - 1",
                            "BinOp"
                        ],
                        [
                            "np.expand_dims(np.expand_dims(np.expand_dims(max_tau, -1), -1), -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "int_dtype",
                    "type": "Name",
                    "possible_values": [
                        [
                            "sequence_length.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "mod_196": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(numbers_to_maxT - tau_forward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_200": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_204": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "mod_208": {
                "x1": {
                    "value": "tf.ceil(tf.truediv(numbers_to_maxT - tau_backward, previous_group_size))",
                    "type": "Call",
                    "possible_values": []
                },
                "x2": {
                    "value": "previous_num_replicas",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(float(previous_t_reset) / float(previous_group_size))",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_237": {
                "variable": {
                    "value": "backward_for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(backward_output, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, num_replicas, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_93": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ceil_197": {
                "x": {
                    "value": "tf.truediv(numbers_to_maxT - tau_forward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_201": {
                "x": {
                    "value": "tf.truediv(reversed_numbers_to_maxT - tau_forward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_205": {
                "x": {
                    "value": "tf.truediv(reversed_numbers_to_maxT - tau_backward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ceil_209": {
                "x": {
                    "value": "tf.truediv(numbers_to_maxT - tau_backward, previous_group_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_241": {
                "variable": {
                    "value": "forward_for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(forward_output, -2)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, num_replicas, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_115": {
                "variable": {
                    "value": "multistate_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_117": {
                "variable": {
                    "value": "multistate_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "multistate_input",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(multistate_input, tf.constant([1, 1, num_replicates, 1]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.constant([1, 1, num_replicates, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "stack_135": {
                "variable": {
                    "value": "multiplicates",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "multiplicates",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.ones(len(for_forward.get_shape()), np.int).tolist()",
                            "Call"
                        ],
                        [
                            "tf.stack(multiplicates)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_137": {
                "input": {
                    "value": "add_input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_138": {
                "variable": {
                    "value": "add_input_broadcast",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "add_input_broadcast",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.expand_dims(add_input, 1), -2)",
                            "Call"
                        ],
                        [
                            "tf.tile(add_input_broadcast, multiplicates)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "multiplicates",
                    "type": "Call",
                    "possible_values": [
                        [
                            "np.ones(len(for_forward.get_shape()), np.int).tolist()",
                            "Call"
                        ],
                        [
                            "tf.stack(multiplicates)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_140": {
                "variable": {
                    "value": "for_forward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[for_forward, add_input_broadcast]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_141": {
                "variable": {
                    "value": "for_backward",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[for_backward, add_input_broadcast]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "truediv_197": {
                "x": {
                    "value": "numbers_to_maxT - tau_forward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_201": {
                "x": {
                    "value": "reversed_numbers_to_maxT - tau_forward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_205": {
                "x": {
                    "value": "reversed_numbers_to_maxT - tau_backward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "truediv_209": {
                "x": {
                    "value": "numbers_to_maxT - tau_backward",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "previous_group_size",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "expand_dims_237": {
                "input": {
                    "value": "backward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_241": {
                "input": {
                    "value": "forward_output",
                    "type": "Name",
                    "possible_values": [
                        [
                            "actual_outputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_96": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_117": {
                "value": {
                    "value": "[1, 1, num_replicates, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_133": {
                "input": {
                    "value": "for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "forward_for_forward",
                            "Name"
                        ],
                        [
                            "tf.concat((forward_for_forward, backward_for_forward), -1)",
                            "Call"
                        ],
                        [
                            "multistate_input",
                            "Name"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "tf.concat([for_forward, add_input_broadcast], -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_134": {
                "input": {
                    "value": "for_forward",
                    "type": "Name",
                    "possible_values": [
                        [
                            "forward_for_forward",
                            "Name"
                        ],
                        [
                            "tf.concat((forward_for_forward, backward_for_forward), -1)",
                            "Call"
                        ],
                        [
                            "multistate_input",
                            "Name"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "tf.concat([for_forward, add_input_broadcast], -1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dbrnn.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/dcnn.py": {
        "tensorflow": {
            "expand_dims_88": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_89": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_109": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.reshape(logits, [shapes[0], -1, shapes[2] * shapes[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shapes[0], -1, shapes[2] * shapes[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_97": {
                "name_or_scope": {
                    "value": "cnn",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_92": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_99": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dlstm.py": {
        "tensorflow": {
            "variable_scope_75": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_87": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "lstm_layers[l](logits, input_seq_length, 'layer' + str(l))",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(logits, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "float(self.conf['dropout'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_78": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/dresetlstm.py": {
        "tensorflow": {
            "expand_dims_66": {
                "variable": {
                    "value": "logits_multistate",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_67": {
                "variable": {
                    "value": "logits_multistate",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits_multistate",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits, 2)",
                            "Call"
                        ],
                        [
                            "tf.tile(logits_multistate, tf.constant([1, 1, t_resets[0], 1]))",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "tf.constant([1, 1, t_resets[0], 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_57": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_67": {
                "value": {
                    "value": "[1, 1, t_resets[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_60": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/encoder_decoder_cnn.py": {
        "tensorflow": {
            "expand_dims_154": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_155": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_163": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "centre",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_188": {
                "name_or_scope": {
                    "value": "decoder",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_223": {
                "variable": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_231": {
                "variable": {
                    "value": "last_t_slice",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits[:, -1, :, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_232": {
                "variable": {
                    "value": "duplicate_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "last_t_slice",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits[:, -1, :, :], 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, missing_t_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_233": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, duplicate_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_234": {
                "variable": {
                    "value": "last_f_slice",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits[:, :, -1, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_235": {
                "variable": {
                    "value": "duplicate_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "last_f_slice",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits[:, :, -1, :], 2)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, missing_f_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_236": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, duplicate_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_158": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_167": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_180": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_190": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_197": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, corresponding_encoder_output]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_216": {
                "variable": {
                    "value": "wanted_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_218": {
                "variable": {
                    "value": "wanted_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_outputs[corresponding_encoder_l - 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/encoder_lstm_decoder.py": {
        "tensorflow": {
            "expand_dims_181": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "transpose_207": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size * new_freq_dim, -1, num_chan])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "blstm_layers[l](logits, tmp_input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_208": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size * new_freq_dim, -1, num_chan])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "blstm_layers[l](logits, tmp_input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * new_freq_dim, -1, num_chan]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_209": {
                "variable": {
                    "value": "tmp_input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_210": {
                "variable": {
                    "value": "tmp_input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tmp_input_seq_length",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_seq_length, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tmp_input_seq_length, [1, new_freq_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tmp_input_seq_length, [batch_size * new_freq_dim])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, new_freq_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_211": {
                "variable": {
                    "value": "tmp_input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tmp_input_seq_length",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.expand_dims(input_seq_length, 1)",
                            "Call"
                        ],
                        [
                            "tf.tile(tmp_input_seq_length, [1, new_freq_dim])",
                            "Call"
                        ],
                        [
                            "tf.reshape(tmp_input_seq_length, [batch_size * new_freq_dim])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size * new_freq_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_221": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size * new_freq_dim, -1, num_chan])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "blstm_layers[l](logits, tmp_input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_222": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size * new_freq_dim, -1, num_chan])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "blstm_layers[l](logits, tmp_input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_190": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_205": {
                "name_or_scope": {
                    "value": "lstm_centre",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_224": {
                "name_or_scope": {
                    "value": "decoder",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_259": {
                "variable": {
                    "value": "output_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size * new_freq_dim, -1, num_chan])",
                            "Call"
                        ],
                        [
                            "tf.reshape(logits, [batch_size, new_freq_dim, -1, 2 * lstm_num_units[-1]])",
                            "Call"
                        ],
                        [
                            "tf.transpose(logits, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "blstm_layers[l](logits, tmp_input_seq_length)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 1)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits, duplicate_logits], 2)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_267": {
                "variable": {
                    "value": "last_t_slice",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits[:, -1, :, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_268": {
                "variable": {
                    "value": "duplicate_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "last_t_slice",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits[:, -1, :, :], 1)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, missing_t_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_269": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, duplicate_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_270": {
                "variable": {
                    "value": "last_f_slice",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits[:, :, -1, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tile_271": {
                "variable": {
                    "value": "duplicate_logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "last_f_slice",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.expand_dims(logits[:, :, -1, :], 2)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, missing_f_size, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_272": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, duplicate_logits]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "shape_185": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "variable_scope_194": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_213": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_226": {
                "name_or_scope": {
                    "value": "'layer_%s' % l",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_233": {
                "variable": {
                    "value": "decoder_input",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits, corresponding_encoder_output]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_252": {
                "variable": {
                    "value": "wanted_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shape_254": {
                "variable": {
                    "value": "wanted_size",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "encoder_outputs[corresponding_encoder_l - 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/feedforward.py": {
        "tensorflow": {
            "variable_scope_56": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_71": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.contrib.layers.fully_connected(inputs=logits, num_outputs=num_units[l], activation_fn=activation_fn)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(logits, float(self.conf['dropout']))",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "float(self.conf['dropout'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_59": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/framer.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/kmeans.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/leaky_dbgru.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/leaky_dblstm.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/leaky_dblstm_iznotrec.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/leaky_dblstm_notrec.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/leaky_dlstm.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/linear.py": {
        "tensorflow": {
            "linear_48": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ]
                    ]
                },
                "num_outputs": {
                    "value": "output_size",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.prod(output_shape)",
                            "Call"
                        ]
                    ]
                },
                "biases_initializer": {
                    "value": "biases_initializer",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_33": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_46": {
                "variable": {
                    "value": "biases_initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reshape_52": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.concat([fixed_shape, tf.constant(output_shape)], -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "dropout_68": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "float(self.conf['dropout'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_72": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "tanh_56": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_51": {
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_52": {
                "values": {
                    "value": "[fixed_shape, tf.constant(output_shape)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "sigmoid_58": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_35": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "relu_60": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_52": {
                "value": {
                    "value": "output_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "map(int, self.conf['output_dims'].split(' '))",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_62": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.contrib.layers.linear(inputs=logits, num_outputs=output_size, biases_initializer=biases_initializer)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, tf.concat([fixed_shape, tf.constant(output_shape)], -1))",
                            "Call"
                        ],
                        [
                            "tf.tanh(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.dropout(output, float(self.conf['dropout']))",
                            "Call"
                        ],
                        [
                            "tf.sigmoid(output)",
                            "Call"
                        ],
                        [
                            "output[:, -1, :]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(output, 1)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(output)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(output, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/mask_estimator_from_attractors.py": {
        "tensorflow": {
            "reshape_52": {
                "variable": {
                    "value": "bin_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bin_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(bin_embs, [batch_size, -1, feat_dim, emb_dim])",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(bin_embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, feat_dim, emb_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_float_80": {
                "variable": {
                    "value": "binary_masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "binary_masks",
                    "type": "Name",
                    "possible_values": [
                        [
                            "masks > thr",
                            "Compare"
                        ],
                        [
                            "tf.to_float(binary_masks)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_59": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "l2_normalize_61": {
                "variable": {
                    "value": "bin_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bin_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(bin_embs, [batch_size, -1, feat_dim, emb_dim])",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(bin_embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_62": {
                "variable": {
                    "value": "attractors",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "attractors",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.l2_normalize(attractors, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(attractors, 2), 3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_64": {
                "variable": {
                    "value": "bin_embs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bin_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(bin_embs, [batch_size, -1, feat_dim, emb_dim])",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(bin_embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_65": {
                "input": {
                    "value": "attractors",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.l2_normalize(attractors, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(attractors, 2), 3)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_mean_66": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "bin_embs * attractors",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_68": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "einsum",
                    "type": "Name",
                    "possible_values": [
                        [
                            "self.conf['einsum']",
                            "Subscript"
                        ],
                        [
                            "False",
                            "Constant"
                        ]
                    ]
                },
                "*inputs": {
                    "value": "bin_embs",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(bin_embs, [batch_size, -1, feat_dim, emb_dim])",
                            "Call"
                        ],
                        [
                            "tf.nn.l2_normalize(bin_embs, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(bin_embs, 1)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "attractors",
                    "type": "Call",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ],
                        [
                            "tf.nn.l2_normalize(attractors, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf.expand_dims(attractors, 2), 3)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_71": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_mean(bin_embs * attractors, -1)",
                            "Call"
                        ],
                        [
                            "tf.einsum(einsum, bin_embs, attractors)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "transpose_93": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "binary_masks",
                            "Name"
                        ],
                        [
                            "masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "rescaled_masks",
                            "Name"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, feat_dim * nrS])",
                            "Call"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, nrS * feat_dim])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 3, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_94": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "binary_masks",
                            "Name"
                        ],
                        [
                            "masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "rescaled_masks",
                            "Name"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, feat_dim * nrS])",
                            "Call"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, nrS * feat_dim])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, feat_dim * nrS]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_96": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "binary_masks",
                            "Name"
                        ],
                        [
                            "masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "rescaled_masks",
                            "Name"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, feat_dim * nrS])",
                            "Call"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, nrS * feat_dim])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_97": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "binary_masks",
                            "Name"
                        ],
                        [
                            "masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "rescaled_masks",
                            "Name"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, feat_dim * nrS])",
                            "Call"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, nrS * feat_dim])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1, nrS * feat_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_75": {
                "variable": {
                    "value": "masks",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "logits",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reduce_mean(bin_embs * attractors, -1)",
                            "Call"
                        ],
                        [
                            "tf.einsum(einsum, bin_embs, attractors)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_min_86": {
                "input_tensor": {
                    "value": "masks",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.nn.softmax(logits, axis=1)",
                            "Call"
                        ],
                        [
                            "logits",
                            "Name"
                        ],
                        [
                            "binary_masks",
                            "Name"
                        ],
                        [
                            "masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "tf.nn.sigmoid(logits)",
                            "Call"
                        ],
                        [
                            "rescaled_masks",
                            "Name"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 3, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, feat_dim * nrS])",
                            "Call"
                        ],
                        [
                            "tf.transpose(masks, [0, 2, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(masks, [batch_size, -1, nrS * feat_dim])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reduce_max_88": {
                "input_tensor": {
                    "value": "rescaled_masks",
                    "type": "BinOp",
                    "possible_values": [
                        [
                            "masks - tf.reduce_min(masks, axis=[1, 2, 3], keepdims=True)",
                            "BinOp"
                        ],
                        [
                            "rescaled_masks * binary_masks",
                            "BinOp"
                        ],
                        [
                            "rescaled_masks / (tf.reduce_max(rescaled_masks, axis=[1, 2, 3], keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "rescaled_masks * binary_masks",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/model.py": {
        "tensorflow": {
            "VariableScope_27": {
                "variable": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                },
                "reuse": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "name": {
                    "value": "name or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            },
            "get_collection_ref_63": {
                "variable": {
                    "value": "trainable_collection",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_74": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "scope": {
                    "value": "self.scope.name",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "while_loop_156": {
                "variable": {
                    "value": "logits",
                    "type": "Variable",
                    "possible_values": []
                },
                "cond": {
                    "value": "self.stop_condition",
                    "type": "Attribute",
                    "possible_values": []
                },
                "body": {
                    "value": "self._get_outputs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[self.zero_state(inputs, input_seq_length, is_training)]",
                    "type": "List",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "maximum_iterations": {
                    "value": "self.max_iters",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_155": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/ntm.py": {
        "tensorflow": {
            "dynamic_rnn_72": {
                "variable": {
                    "value": "(outputs, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "ntm_cell",
                    "type": "Name",
                    "possible_values": [
                        [
                            "NTMCell(input_size=input_size, memory_size=memory_size, memory_vector_dim=memory_vector_dim, read_head_num=read_head_num, write_head_num=write_head_num, addressing_mode=addressing_mode, shift_win_size=shift_win_size, clip_value=20, init_mode=init_mode, init_mode_other_params=init_mode_other_params, reuse=tf.get_variable_scope().reuse)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "sequence_length": {
                    "value": "input_seq_length",
                    "type": "Variable",
                    "possible_values": []
                }
            },
            "variable_scope_59": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_62": {
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs + tf.random_normal(tf.shape(inputs), stddev=float(self.conf['input_noise']))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "get_variable_scope_69": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/models/ntt_rec.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/permute_stacker.py": {
        "tensorflow": {
            "concat_41": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "all_inp_perms",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tf.gather(input, perm, axis=permute_dim) for perm in permutations]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "stack_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['stack_dim'])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_36": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_40": {
                "params": {
                    "value": "input",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "perm",
                    "type": "Variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "permute_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['permute_dim'])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/plain_variables.py": {
        "tensorflow": {
            "get_variable_51": {
                "variable": {
                    "value": "vector_set",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "vector_set",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "array_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initializer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.constant_initializer(np.ones(array_shape) * init_value)",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal(array_shape, stddev=tf.sqrt(2 / float(self.conf['vec_dim'])))",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(np.ones(array_shape) * init_value)",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal(array_shape, stddev=tf.sqrt(2 / float(self.conf['vec_dim'])))",
                            "Call"
                        ]
                    ]
                },
                "constraint": {
                    "value": "constraint",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "lambda x: tf.clip_by_value(x, floor_val, ceil_val)",
                            "Lambda"
                        ]
                    ]
                }
            },
            "get_variable_57": {
                "variable": {
                    "value": "scale",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "single_scale",
                    "type": "Constant",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_97": {
                "variable": {
                    "value": "vector_set",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "vector_set",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "array_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ]
                    ]
                },
                "initializer": {
                    "value": "initializer",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.constant_initializer(np.ones(array_shape) * init_value)",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal(array_shape, stddev=tf.sqrt(2 / float(self.conf['vec_dim'])))",
                            "Call"
                        ],
                        [
                            "tf.constant_initializer(np.ones(array_shape) * init_value)",
                            "Call"
                        ],
                        [
                            "tf.truncated_normal(array_shape, stddev=tf.sqrt(2 / float(self.conf['vec_dim'])))",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_99": {
                "variable": {
                    "value": "inputs",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_nd_101": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "params": {
                    "value": "vector_set",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('vector_set', shape=array_shape, initializer=initializer, constraint=constraint)",
                            "Call"
                        ],
                        [
                            "vector_set / (tf.norm(vector_set, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "vector_set * scale",
                            "BinOp"
                        ],
                        [
                            "tf.get_variable('vector_set', shape=array_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "inputs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "tf.expand_dims(inputs, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_102": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather_nd(vector_set, inputs)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [tf.shape(output)[0], 1, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[tf.shape(output)[0], 1, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_26": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_31": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(array_shape) * init_value",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_33": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "array_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ]
                    ]
                },
                "stddev": {
                    "value": "tf.sqrt(2 / float(self.conf['vec_dim']))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_87": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_93": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.ones(array_shape) * init_value",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "truncated_normal_95": {
                "variable": {
                    "value": "initializer",
                    "type": "Variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "array_shape",
                    "type": "List",
                    "possible_values": [
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ],
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "[int(self.conf['tot_vecs']), int(self.conf['vec_dim'])]",
                            "List"
                        ]
                    ]
                },
                "stddev": {
                    "value": "tf.sqrt(2 / float(self.conf['vec_dim']))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "clip_by_value_48": {
                "t": {
                    "value": "x",
                    "type": "Variable",
                    "possible_values": []
                },
                "clip_value_min": {
                    "value": "floor_val",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "float(self.conf['floor_val'])",
                            "Call"
                        ],
                        [
                            "-np.infty",
                            "UnaryOp"
                        ]
                    ]
                },
                "clip_value_max": {
                    "value": "ceil_val",
                    "type": "Name",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "float(self.conf['ceil_val'])",
                            "Call"
                        ],
                        [
                            "np.infty",
                            "Attribute"
                        ]
                    ]
                }
            },
            "norm_54": {
                "tensor": {
                    "value": "vector_set",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.get_variable('vector_set', shape=array_shape, initializer=initializer, constraint=constraint)",
                            "Call"
                        ],
                        [
                            "vector_set / (tf.norm(vector_set, axis=-1, keepdims=True) + 1e-12)",
                            "BinOp"
                        ],
                        [
                            "vector_set * scale",
                            "BinOp"
                        ],
                        [
                            "tf.get_variable('vector_set', shape=array_shape, initializer=initializer)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_57": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "sqrt_33": {
                "x": {
                    "value": "2 / float(self.conf['vec_dim'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sqrt_95": {
                "x": {
                    "value": "2 / float(self.conf['vec_dim'])",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_102": {
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.gather_nd(vector_set, inputs)",
                            "Call"
                        ],
                        [
                            "tf.reshape(output, [tf.shape(output)[0], 1, -1])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/reconstruction_layer.py": {
        "tensorflow": {
            "multiply_35": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[1]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "signal",
                    "type": "Name",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "where_36": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "output <= 1e-30",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.ones_like(output) * 1e-30",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.multiply(mask, signal)",
                            "Call"
                        ],
                        [
                            "tf.where(output <= 1e-30, tf.ones_like(output) * 1e-30, output)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_38": {
                "variable": {
                    "value": "denom",
                    "type": "Variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.constant(10, dtype=nom.dtype)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_34": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_37": {
                "x": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.multiply(mask, signal)",
                            "Call"
                        ],
                        [
                            "tf.where(output <= 1e-30, tf.ones_like(output) * 1e-30, output)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_38": {
                "value": {
                    "value": "10",
                    "type": "Constant",
                    "possible_values": []
                },
                "dtype": {
                    "value": "nom.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_36": {
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.multiply(mask, signal)",
                            "Call"
                        ],
                        [
                            "tf.where(output <= 1e-30, tf.ones_like(output) * 1e-30, output)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/neuralnetworks/models/regular_cnn.py": {
        "tensorflow": {}
    },
    "nabu/neuralnetworks/models/reshaper.py": {
        "tensorflow": {
            "shape_36": {
                "variable": {
                    "value": "input_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "concat_40": {
                "variable": {
                    "value": "reshape_dim_shape",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[left_in_shape, requested_shape, right_in_shape]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "reshape_42": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "input",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "reshape_dim_shape",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.concat([left_in_shape, requested_shape, right_in_shape], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_77": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "input",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "insert_dim",
                    "type": "Name",
                    "possible_values": [
                        [
                            "int(self.conf['insert_dim'])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_112": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "a": {
                    "value": "input",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ],
                        [
                            "inputs[0]",
                            "Subscript"
                        ]
                    ]
                },
                "perm": {
                    "value": "transpose_permutation",
                    "type": "Name",
                    "possible_values": [
                        [
                            "map(int, self.conf['transpose_permutation'].split(' '))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_35": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_76": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_81": {
                "variable": {
                    "value": "output",
                    "type": "Variable",
                    "possible_values": []
                },
                "input": {
                    "value": "output",
                    "type": "Call",
                    "possible_values": [
                        [
                            "tf.reshape(input, reshape_dim_shape)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(input, insert_dim)",
                            "Call"
                        ],
                        [
                            "tf.tile(output, multiplicates)",
                            "Call"
                        ],
                        [
                            "tf.transpose(input, perm=transpose_permutation)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "multiplicates",
                    "type": "Name",
                    "possible_values": [
                        [
                            "np.ones(len(output.get_shape()))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_111": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/trainers/multi_task_trainer.py": {
        "tensorflow": {
            "Graph_71": {
                "variable": {
                    "value": "self.graph",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_484": {
                "variable": {
                    "value": "config",
                    "type": "Variable",
                    "possible_values": []
                },
                "device_count": {
                    "value": "{'CPU': 1}",
                    "type": "Dict",
                    "possible_values": []
                }
            },
            "get_variable_110": {
                "variable": {
                    "value": "self.num_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "num_steps",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_119": {
                "variable": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_126": {
                "variable": {
                    "value": "should_terminate",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "should_terminate",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(False)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_133": {
                "variable": {
                    "value": "self.should_save_final_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "should_save_final_model",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(False)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "logical_or_145": {
                "variable": {
                    "value": "self.should_stop",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater_equal(self.global_step, self.num_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "should_terminate",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable(name='should_terminate', shape=[], dtype=tf.bool, initializer=tf.constant_initializer(False), trainable=False)",
                            "Call"
                        ]
                    ]
                }
            },
            "group_162": {
                "variable": {
                    "value": "self.done",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*done_ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "Scaffold_478": {
                "variable": {
                    "value": "self.scaffold",
                    "type": "Attribute",
                    "possible_values": []
                },
                "saver": {
                    "value": "tf.train.Saver(max_to_keep=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_169": {
                "variable": {
                    "value": "learning_rate_fact",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "learning_rate_fact",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "group_239": {
                "variable": {
                    "value": "self.reset_grad_loss_norm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[task_trainer.reset_grad_loss_norm for task_trainer in self.task_trainers]",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "reset_grad_loss_norm_all_tasks",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "group_246": {
                "variable": {
                    "value": "self.normalize_gradients",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*tmp",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "normalize_gradients_all_tasks",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_collection_264": {
                "variable": {
                    "value": "update_ops",
                    "type": "Variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "group_275": {
                "variable": {
                    "value": "self.other_update_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*update_ops + [global_step_inc]",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "other_update",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "greater_equal_146": {
                "x": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "self.num_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_165": {
                "name_or_scope": {
                    "value": "train",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "AdamOptimizer_220": {
                "variable": {
                    "value": "optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_251": {
                "variable": {
                    "value": "self.total_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[loss * weight for (loss, weight) in zip(self.loss_all_tasks, self.task_weights)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "name": {
                    "value": "acc_loss",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_286": {
                "variable": {
                    "value": "validated_step",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "validated_step",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(-int(conf['valid_frequency']))",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "greater_equal_294": {
                "variable": {
                    "value": "self.should_validate",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "self.global_step - validated_step",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "int(conf['valid_frequency'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "group_314": {
                "variable": {
                    "value": "self.process_val_batch",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[task_trainer.process_val_batch for task_trainer in self.val_task_trainers]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "group_317": {
                "variable": {
                    "value": "self.reset_val_loss_norm",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*[task_trainer.reset_val_loss_norm for task_trainer in self.val_task_trainers]",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "reduce_sum_323": {
                "variable": {
                    "value": "self.validation_loss",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "[loss * weight for (loss, weight) in zip(self.val_loss_all_tasks, self.task_weights)]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "get_variable_450": {
                "variable": {
                    "value": "waiting_workers",
                    "type": "Variable",
                    "possible_values": []
                },
                "name": {
                    "value": "waiting_workers",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "equal_464": {
                "variable": {
                    "value": "self.all_waiting",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "waiting_workers",
                    "type": "Name",
                    "possible_values": [
                        [
                            "tf.get_variable(name='waiting_workers', shape=[], dtype=tf.int32, initializer=tf.constant_initializer(0), trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "num_replicas - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_114": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_123": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_130": {
                "value": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_137": {
                "value": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "exponential_decay_177": {
                "learning_rate": {
                    "value": "float(conf['initial_learning_rate'])",
                    "type": "Call",
                    "possible_values": []
                },
                "global_step": {
                    "value": "self.global_step",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "self.num_steps",
                    "type": "Attribute",
                    "possible_values": []
                },
                "decay_rate": {
                    "value": "float(conf['learning_rate_decay'])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_249": {
                "name_or_scope": {
                    "value": "accumulate_losses_from_tasks",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "variable_scope_282": {
                "name_or_scope": {
                    "value": "validate",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_400": {
                "variable": {
                    "value": "self.best_validation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "best_validation",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_411": {
                "variable": {
                    "value": "self.previous_validation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "previous_validation",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_422": {
                "variable": {
                    "value": "self.rel_validation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "rel_validation",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[int(self.conf['num_tries'])]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_431": {
                "variable": {
                    "value": "all_rel_imprs",
                    "type": "Variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.rel_validation[1:], tf.expand_dims(rel_impr, -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "assign_432": {
                "variable": {
                    "value": "self.update_rel",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ref": {
                    "value": "self.rel_validation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "all_rel_imprs",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[tf.concat([rel_val_task[1:], tf.expand_dims(rel_impr[ind], -1)], axis=0) for (ind, rel_val_task) in enumerate(self.rel_validation_all_tasks)]",
                            "ListComp"
                        ],
                        [
                            "tf.concat([self.rel_validation[1:], tf.expand_dims(rel_impr, -1)], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_435": {
                "variable": {
                    "value": "self.num_tries",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "num_tries",
                    "type": "Constant",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "Saver_478": {
                "max_to_keep": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_172": {
                "value": {
                    "value": "1.0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "AdamOptimizer_193": {
                "variable": {
                    "value": "dummy_optimizer",
                    "type": "Variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "self.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_290": {
                "value": {
                    "value": "-int(conf['valid_frequency'])",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "get_variable_334": {
                "name": {
                    "value": "'best_validation_task_%i' % ind",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_348": {
                "name": {
                    "value": "'previous_validation_task_%i' % ind",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "get_variable_361": {
                "name": {
                    "value": "'rel_validation_task_%i' % ind",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[int(self.conf['num_tries'])]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(1.79e+308)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "concat_373": {
                "values": {
                    "value": "[rel_val_task[1:], tf.expand_dims(rel_impr[ind], -1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "assign_376": {
                "ref": {
                    "value": "rel_val_task",
                    "type": "Variable",
                    "possible_values": []
                },
                "value": {
                    "value": "all_rel_imprs[ind]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_variable_380": {
                "name": {
                    "value": "'num_tries_task_%i' % ind",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_454": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "trainable_variables_550": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_404": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_415": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_426": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_431": {
                "input": {
                    "value": "rel_impr",
                    "type": "Name",
                    "possible_values": [
                        [
                            "[(self.previous_validation_all_tasks[ind] - self.val_loss_all_tasks[ind]) / self.previous_validation_all_tasks[ind] for ind in range(nr_val_tasks)]",
                            "ListComp"
                        ],
                        [
                            "(self.previous_validation - self.validation_loss) / self.previous_validation",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_439": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "trainable_variables_554": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_557": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_560": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_338": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_352": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "constant_initializer_365": {
                "value": {
                    "value": "1.79e+308",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "expand_dims_373": {
                "input": {
                    "value": "rel_impr[ind]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_initializer_384": {
                "value": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/neuralnetworks/trainers/task_trainer.py": {
        "tensorflow": {}
    },
    "nabu/processing/tfreaders/tfreader.py": {
        "tensorflow": {
            "TFRecordReader_27": {
                "variable": {
                    "value": "self.reader",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parse_single_example_46": {
                "variable": {
                    "value": "features",
                    "type": "Variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "serialized",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "self.features",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "name_scope_40": {
                "name": {
                    "value": "name or type(self).__name__",
                    "type": "BoolOp",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/processing/tfwriters/float_list_as_tfrecord_writer.py": {
        "tensorflow": {
            "Feature_17": {
                "variable": {
                    "value": "shape_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(np.array(data).astype(np.int32).shape).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_19": {
                "variable": {
                    "value": "data_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(data).astype(np.float32).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Example_24": {
                "variable": {
                    "value": "example",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'shape': shape_feature, 'data': data_feature})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_17": {
                "value": {
                    "value": "[np.array(np.array(data).astype(np.int32).shape).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_19": {
                "value": {
                    "value": "[np.array(data).astype(np.float32).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Features_24": {
                "feature": {
                    "value": "{'shape': shape_feature, 'data': data_feature}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/processing/tfwriters/index_list_as_tfrecord_writer.py": {
        "tensorflow": {
            "Feature_17": {
                "variable": {
                    "value": "shape_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(np.array(data).astype(np.int32).shape).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_19": {
                "variable": {
                    "value": "data_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(data).astype(np.int32).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Example_24": {
                "variable": {
                    "value": "example",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'shape': shape_feature, 'data': data_feature})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_17": {
                "value": {
                    "value": "[np.array(np.array(data).astype(np.int32).shape).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_19": {
                "value": {
                    "value": "[np.array(data).astype(np.int32).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Features_24": {
                "feature": {
                    "value": "{'shape': shape_feature, 'data': data_feature}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/processing/tfwriters/numpy_bool_array_as_tfrecord_writer.py": {
        "tensorflow": {
            "Feature_17": {
                "variable": {
                    "value": "shape_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(data.astype(np.int32).shape).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_19": {
                "variable": {
                    "value": "data_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[data.reshape([-1]).astype(np.bool).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Example_24": {
                "variable": {
                    "value": "example",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'shape': shape_feature, 'data': data_feature})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_17": {
                "value": {
                    "value": "[np.array(data.astype(np.int32).shape).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_19": {
                "value": {
                    "value": "[data.reshape([-1]).astype(np.bool).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Features_24": {
                "feature": {
                    "value": "{'shape': shape_feature, 'data': data_feature}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/processing/tfwriters/numpy_float_array_as_tfrecord_writer.py": {
        "tensorflow": {
            "Feature_18": {
                "variable": {
                    "value": "shape_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[np.array(data.astype(np.int32).shape).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Feature_20": {
                "variable": {
                    "value": "data_feature",
                    "type": "Variable",
                    "possible_values": []
                },
                "bytes_list": {
                    "value": "tf.train.BytesList(value=[data.reshape([-1]).astype(np.float32).tostring()])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Example_24": {
                "variable": {
                    "value": "example",
                    "type": "Variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.train.Features(feature={'shape': shape_feature, 'data': data_feature})",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "BytesList_18": {
                "value": {
                    "value": "[np.array(data.astype(np.int32).shape).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "BytesList_20": {
                "value": {
                    "value": "[data.reshape([-1]).astype(np.float32).tostring()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Features_24": {
                "feature": {
                    "value": "{'shape': shape_feature, 'data': data_feature}",
                    "type": "Dict",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/processing/tfwriters/tfwriter.py": {
        "tensorflow": {
            "TFRecordWriter_52": {
                "variable": {
                    "value": "writer",
                    "type": "Variable",
                    "possible_values": []
                },
                "path": {
                    "value": "filename",
                    "type": "Name",
                    "possible_values": [
                        [
                            "os.path.join(self.write_dir, 'file%d' % self.filenum)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "nabu/scripts/data.py": {
        "tensorflow": {
            "DEFINE_string_110": {
                "name": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The experiments directory",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/scripts/prepare_data.py": {
        "tensorflow": {
            "DEFINE_string_98": {
                "name": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the exeriments directory",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_99": {
                "name": {
                    "value": "recipe",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory containing the recipe",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_100": {
                "name": {
                    "value": "computing",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "standard",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the distributed computing system one of condor",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_101": {
                "name": {
                    "value": "minmemory",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The minimum required computing RAM in MB. (only for non-standard computing)",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_102": {
                "name": {
                    "value": "sweep_flag",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "wheter the script was called from a sweep",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/scripts/prepare_param_search.py": {
        "tensorflow": {}
    },
    "nabu/scripts/prepare_sweep.py": {
        "tensorflow": {
            "DEFINE_string_87": {
                "name": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the experiments directory",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_88": {
                "name": {
                    "value": "recipe",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The directory containing the recipe",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_89": {
                "name": {
                    "value": "computing",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "standard",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the distributed computing system one of standard or condor",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_90": {
                "name": {
                    "value": "sweep",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the file containing the sweep parameters",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_91": {
                "name": {
                    "value": "command",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the command to run",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_92": {
                "name": {
                    "value": "minmemory",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The minimum required computing RAM in MB. (only for non-standard computing)",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_93": {
                "name": {
                    "value": "mincudamemory",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The minimum required computing CUDA GPU memory in MB. (only for training and non-standard computing)",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_94": {
                "name": {
                    "value": "resume",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "whether the experiment in expdir, if available, has to be resumed",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_95": {
                "name": {
                    "value": "duplicates",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "1",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "How many duplicates of the same experiment should be run",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_96": {
                "name": {
                    "value": "duplicates_ind_offset",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "Index offset for duplicates",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_97": {
                "name": {
                    "value": "test_when_finished",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "True",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "whether the test script should be started upon finishing training",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_99": {
                "name": {
                    "value": "allow_early_testing",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "False",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "whether testing is allowed before training has ended (only relevant for the test command)",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_102": {
                "name": {
                    "value": "task",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "If specified (for testing only), the evaluation tasks field in the recipe will be ignored and only the given task will be evaluated.",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    },
    "nabu/scripts/prepare_test.py": {
        "tensorflow": {}
    },
    "nabu/scripts/prepare_test_own_scipy.py": {
        "tensorflow": {}
    },
    "nabu/scripts/prepare_train.py": {
        "tensorflow": {}
    },
    "nabu/scripts/test.py": {
        "tensorflow": {}
    },
    "nabu/scripts/train.py": {
        "tensorflow": {
            "DEFINE_string_149": {
                "name": {
                    "value": "clusterfile",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The file containing the cluster",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_150": {
                "name": {
                    "value": "job_name",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "local",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "One of ps, worker",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_integer_151": {
                "name": {
                    "value": "task_index",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "0",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The task index",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_152": {
                "name": {
                    "value": "ssh_command",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "the command that should be used to create ssh tunnels",
                    "type": "Constant",
                    "possible_values": []
                }
            },
            "DEFINE_string_153": {
                "name": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "default": {
                    "value": "expdir",
                    "type": "Constant",
                    "possible_values": []
                },
                "help": {
                    "value": "The experimental directory",
                    "type": "Constant",
                    "possible_values": []
                }
            }
        }
    }
}