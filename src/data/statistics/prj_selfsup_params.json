{
    "data/default/data.py": {
        "tensorflow": {
            "flatten_51": {
                "variable": {
                    "value": "flat_args",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_64": {
                "variable": {
                    "value": "first_tensor_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "first_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "make_one_shot_iterator_166": {
                "variable": {
                    "value": "(images, labels, thetas, mask)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "builder.as_dataset(split=FLAGS.train_split if is_training else FLAGS.eval_split, shuffle_files=is_training, as_supervised=True)",
                            "Call"
                        ],
                        [
                            "dataset.cache()",
                            "Call"
                        ],
                        [
                            "dataset.shuffle(params['batch_size'] * buffer_multiplier)",
                            "Call"
                        ],
                        [
                            "dataset.repeat(-1)",
                            "Call"
                        ],
                        [
                            "dataset.map(map_fn, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.batch(params['batch_size'], drop_remainder=is_training)",
                            "Call"
                        ],
                        [
                            "pad_to_batch(dataset, params['batch_size'])",
                            "Call"
                        ]
                    ]
                }
            },
            "pack_sequence_as_98": {
                "structure": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "flat_args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(args)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_94": {
                "variable": {
                    "value": "flat_args[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args",
                            "Name"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, difference]] + [[0, 0]] * (tensor.shape.ndims - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_143": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(thetas, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_144": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_145": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_149": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(label, num_classes)",
                            "Call"
                        ],
                        [
                            "tf.zeros([num_classes])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "builder.info.features['label'].num_classes",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_85": {
                "variable": {
                    "value": "curr_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args",
                            "Name"
                        ]
                    ]
                }
            },
            "control_dependencies_92": {
                "control_inputs": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.Assert(tf.equal(curr_shape[0], first_tensor_batch_size), ['Batch size of dataset tensors %s and %s do not match. Shapes are' % (tensor.name, first_tensor.name), curr_shape, first_tensor_shape])]",
                            "List"
                        ]
                    ]
                }
            },
            "Assert_86": {
                "condition": {
                    "value": "tf.equal(curr_shape[0], first_tensor_batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "['Batch size of dataset tensors %s and %s do not match. Shapes are' % (tensor.name, first_tensor.name), curr_shape, first_tensor_shape]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_87": {
                "x": {
                    "value": "curr_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "first_tensor_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "first_tensor_shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "data/default/data_util.py": {
        "tensorflow": {
            "rgb_to_grayscale_55": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_202": {
                "variable": {
                    "value": "image_width_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "image_height_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_238": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "crop_to_bounding_box_245": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_height - crop_height + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "offset_width": {
                    "value": "offset_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_width - crop_width + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "target_height": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion / aspect_ratio * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "target_width": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * aspect_ratio * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_317": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_347": {
                "variable": {
                    "value": "radius",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernel_size / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_349": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(-radius, radius + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_350": {
                "variable": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_354": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[kernel_size, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_355": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, kernel_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_357": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_358": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_364": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_366": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_394": {
                "variable": {
                    "value": "(image, theta_crop)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : _transform_2(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_431": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_459": {
                "variable": {
                    "value": "(image, sigma)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_538": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_crop, tf.reshape(theta_flip, [1]), theta_color]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_539": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_540": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_558": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_559": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_560": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[(1 - CROP_PROPORTION) / 2, (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 0, 0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_image_dtype_584": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_image_dtype_606": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_34": {
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : func(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_179": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack(theta_color)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_180": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(tf.range(4))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_206": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion / aspect_ratio * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_208": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_213": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_215": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * aspect_ratio * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_220": {
                "pred": {
                    "value": "aspect_ratio > image_width_float / image_height_float",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_requested_aspect_ratio_wider_than_image",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_image_wider_than_requested_aspect_ratio",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_285": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "sample_distorted_bounding_box_286": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "[bsz, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "MethodArgument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_297": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_298": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "crop_to_bounding_box_299": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_y",
                    "type": "variable",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "offset_x",
                    "type": "variable",
                    "possible_values": []
                },
                "target_height": {
                    "value": "target_height",
                    "type": "variable",
                    "possible_values": []
                },
                "target_width": {
                    "value": "target_width",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_301": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_302": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]])",
                            "Call"
                        ],
                        [
                            "tf.cast(theta_crop, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_352": {
                "input_tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_363": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_369": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cond_413": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.8, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : color_jitter_t(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_419": {
                "variable": {
                    "value": "(image, theta_grey)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.2, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (to_grayscale(image), tf.cast(1, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_424": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_color, tf.reshape(theta_grey, [1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_455": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_480": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(tf.random_uniform(shape, 0, 1, dtype=tf.float32), p)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_491": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_517": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_523": {
                "variable": {
                    "value": "(image, theta_flip)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "do_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([]) > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : (tf.image.flip_left_right(image), tf.cast(1, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_527": {
                "variable": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_534": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 0.0, 0.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_35": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_114": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_131": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_168": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(i, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "clip_by_value_177": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_248": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_284": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_356": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_391": {
                "variable": {
                    "value": "crop_default",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_395": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_432": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_460": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_36": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_45": {
                "x": {
                    "value": "1.0 - max_delta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_179": {
                "values": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "rint_206": {
                "x": {
                    "value": "crop_proportion / aspect_ratio * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_208": {
                "x": {
                    "value": "crop_proportion * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_214": {
                "x": {
                    "value": "crop_proportion * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_215": {
                "x": {
                    "value": "crop_proportion * aspect_ratio * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "resize_bicubic_329": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "colocate_with_390": {
                "op": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_396": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_414": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.8, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_420": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.2, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_433": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_461": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_481": {
                "x": {
                    "value": "tf.random_uniform(shape, 0, 1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_493": {
                "tensor": {
                    "value": "sigma * selector",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_538": {
                "tensor": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_contrast_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_168": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_351": {
                "x": {
                    "value": "tf.to_float(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_392": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_415": {
                "x": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_421": {
                "x": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_424": {
                "tensor": {
                    "value": "theta_grey",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_435": {
                "value": {
                    "value": "[0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_463": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_489": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_saturation_106": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_169": {
                "pred": {
                    "value": "tf.less(i, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "brightness_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "contrast_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_170": {
                "pred": {
                    "value": "tf.less(i, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "saturation_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "hue_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_351": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([], 0.1, 2.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_417": {
                "value": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_422": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_423": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flip_left_right_523": {
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_523": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_524": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_hue_109": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_137": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_140": {
                "x": {
                    "value": "1.0 - brightness",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_147": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_contrast_150": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "contrast_factor": {
                    "value": "contrast_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - contrast, maxval=1 + contrast, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_154": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_saturation_157": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "saturation_factor": {
                    "value": "saturation_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - saturation, maxval=1 + saturation, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_162": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_hue_165": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "hue_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], -hue, hue)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_169": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_170": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "data/default/data_util_old.py": {
        "tensorflow": {
            "rgb_to_grayscale_55": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_184": {
                "variable": {
                    "value": "image_width_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_185": {
                "variable": {
                    "value": "image_height_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_220": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "crop_to_bounding_box_227": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_height - crop_height + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "offset_width": {
                    "value": "offset_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_width - crop_width + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "target_height": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion / aspect_ratio * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "target_width": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * aspect_ratio * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_298": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_326": {
                "variable": {
                    "value": "radius",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernel_size / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_328": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(-radius, radius + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_329": {
                "variable": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_333": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[kernel_size, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_334": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, kernel_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_336": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_337": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_343": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_345": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_450": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_451": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_469": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_470": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "convert_image_dtype_490": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_34": {
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : func(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_188": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion / aspect_ratio * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_190": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_195": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_197": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * aspect_ratio * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_202": {
                "pred": {
                    "value": "aspect_ratio > image_width_float / image_height_float",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_requested_aspect_ratio_wider_than_image",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_image_wider_than_requested_aspect_ratio",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_267": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "sample_distorted_bounding_box_268": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "[bsz, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "MethodArgument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_279": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_280": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "crop_to_bounding_box_281": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_y",
                    "type": "variable",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "offset_x",
                    "type": "variable",
                    "possible_values": []
                },
                "target_height": {
                    "value": "target_height",
                    "type": "variable",
                    "possible_values": []
                },
                "target_width": {
                    "value": "target_width",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_331": {
                "input_tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_342": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_348": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_393": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_413": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(tf.random_uniform(shape, 0, 1, dtype=tf.float32), p)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_423": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_flip_left_right_447": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_35": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_114": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_131": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_155": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(i, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "clip_by_value_163": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_230": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_266": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "resize_bicubic_308": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_335": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_36": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_45": {
                "x": {
                    "value": "1.0 - max_delta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rint_188": {
                "x": {
                    "value": "crop_proportion / aspect_ratio * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_190": {
                "x": {
                    "value": "crop_proportion * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_196": {
                "x": {
                    "value": "crop_proportion * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_197": {
                "x": {
                    "value": "crop_proportion * aspect_ratio * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_414": {
                "x": {
                    "value": "tf.random_uniform(shape, 0, 1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "random_contrast_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_155": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_330": {
                "x": {
                    "value": "tf.to_float(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "shape_421": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_saturation_106": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_contrast_143": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_saturation_148": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_hue_154": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_156": {
                "pred": {
                    "value": "tf.less(i, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "brightness_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "contrast_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_157": {
                "pred": {
                    "value": "tf.less(i, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "saturation_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "hue_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_330": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([], 0.1, 2.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_hue_109": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "less_156": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_157": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "data/imagenet/data.py": {
        "tensorflow": {
            "placeholder_29": {
                "variable": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_33": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_preprocess_image",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(shape=[None], dtype=tf.string)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorServingInputReceiver_35": {
                "features": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "receiver_tensors": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(shape=[None], dtype=tf.string)",
                            "Call"
                        ]
                    ]
                }
            },
            "parse_single_example_122": {
                "variable": {
                    "value": "parsed",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "keys_to_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image/encoded': tf.FixedLenFeature((), tf.string, ''), 'image/class/label': tf.FixedLenFeature([], tf.int64, -1)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "reshape_123": {
                "variable": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "parsed['image/encoded']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_124": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(parsed['image/class/label'], shape=[])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_152": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(thetas, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_153": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_154": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_158": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reshape(parsed['image/class/label'], shape=[]), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(label, num_classes)",
                            "Call"
                        ],
                        [
                            "tf.zeros([num_classes])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1000",
                            "Constant"
                        ]
                    ]
                }
            },
            "zeros_316": {
                "shape": {
                    "value": "[self.image_size, self.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bfloat16 if self.use_bfloat16 else tf.float32",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "TFRecordDataset_357": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "buffer_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8 * 1024 * 1024",
                            "BinOp"
                        ]
                    ]
                }
            },
            "FixedLenFeature_118": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FixedLenFeature_119": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_125": {
                "tensor": {
                    "value": "parsed['image/class/label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_and_batch_213": {
                "map_func": {
                    "value": "self.dataset_parser",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params['batch_size']",
                            "Subscript"
                        ]
                    ]
                },
                "num_parallel_batches": {
                    "value": "self.num_parallel_calls",
                    "type": "Attribute",
                    "possible_values": []
                },
                "drop_remainder": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_328": {
                "msg": {
                    "value": "Undefined data_dir implies null input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "repeat_329": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parallel_interleave_362": {
                "map_func": {
                    "value": "fetch_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "cycle_length": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "sloppy": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorShape_100": {
                "dims": {
                    "value": "[batch_size, None, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_102": {
                "dims": {
                    "value": "[batch_size, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_104": {
                "dims": {
                    "value": "[batch_size, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_106": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_322": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_376": {
                "buffer_size": {
                    "value": "1024 * 16",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "data/imagenet/data_util.py": {
        "tensorflow": {
            "rgb_to_grayscale_55": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_202": {
                "variable": {
                    "value": "image_width_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "image_height_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_239": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_249": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_height, offset_width, crop_height, crop_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_251": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_height, offset_width, crop_height, crop_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_252": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_327": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_357": {
                "variable": {
                    "value": "radius",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernel_size / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_359": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(-radius, radius + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_360": {
                "variable": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_364": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[kernel_size, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_365": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, kernel_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_367": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_368": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_374": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_376": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_406": {
                "variable": {
                    "value": "(image, theta_crop)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : _transform_2(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_443": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_471": {
                "variable": {
                    "value": "(image, sigma)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_548": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_crop, tf.reshape(theta_flip, [1]), theta_color]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_551": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_552": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_575": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_576": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_577": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[(1 - CROP_PROPORTION) / 2, (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 0, 0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_34": {
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : func(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_179": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack(theta_color)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_180": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(tf.range(4))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_206": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion / aspect_ratio * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_208": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_213": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_215": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * aspect_ratio * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_220": {
                "pred": {
                    "value": "aspect_ratio > image_width_float / image_height_float",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_requested_aspect_ratio_wider_than_image",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_image_wider_than_requested_aspect_ratio",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_291": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sample_distorted_bounding_box_292": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ],
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ],
                        [
                            "[bsz, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "MethodArgument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_303": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_304": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_307": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y, offset_x, target_height, target_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_308": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_height, offset_width, crop_height, crop_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_309": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_311": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_312": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]])",
                            "Call"
                        ],
                        [
                            "tf.cast(theta_crop, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_362": {
                "input_tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_373": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_379": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "decode_jpeg_402": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_403": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_425": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.8, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : color_jitter_t(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_431": {
                "variable": {
                    "value": "(image, theta_grey)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.2, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (to_grayscale(image), tf.cast(1, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_436": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_color, tf.reshape(theta_grey, [1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_467": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_492": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(tf.random_uniform(shape, 0, 1, dtype=tf.float32), p)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_503": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "decode_jpeg_530": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_531": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_533": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_537": {
                "variable": {
                    "value": "(image, theta_flip)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "do_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([]) > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : (tf.image.flip_left_right(image), tf.cast(1, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_541": {
                "variable": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_546": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 0.0, 0.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "decode_jpeg_571": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_572": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_35": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_114": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_131": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_168": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(i, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "clip_by_value_177": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_253": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_289": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_366": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_401": {
                "variable": {
                    "value": "crop_default",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_407": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_444": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_472": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_36": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_45": {
                "x": {
                    "value": "1.0 - max_delta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_179": {
                "values": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "rint_206": {
                "x": {
                    "value": "crop_proportion / aspect_ratio * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_208": {
                "x": {
                    "value": "crop_proportion * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_214": {
                "x": {
                    "value": "crop_proportion * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_215": {
                "x": {
                    "value": "crop_proportion * aspect_ratio * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "resize_bicubic_339": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "colocate_with_400": {
                "op": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_408": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_426": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.8, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_432": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.2, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_445": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_473": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_493": {
                "x": {
                    "value": "tf.random_uniform(shape, 0, 1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_505": {
                "tensor": {
                    "value": "sigma * selector",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bicubic_532": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_548": {
                "tensor": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bicubic_573": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_contrast_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_168": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_361": {
                "x": {
                    "value": "tf.to_float(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_404": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_427": {
                "x": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_433": {
                "x": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_436": {
                "tensor": {
                    "value": "theta_grey",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_447": {
                "value": {
                    "value": "[0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_475": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_501": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_saturation_106": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_169": {
                "pred": {
                    "value": "tf.less(i, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "brightness_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "contrast_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_170": {
                "pred": {
                    "value": "tf.less(i, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "saturation_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "hue_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_361": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([], 0.1, 2.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_429": {
                "value": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_434": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_435": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flip_left_right_537": {
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_537": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_538": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_hue_109": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_137": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_140": {
                "x": {
                    "value": "1.0 - brightness",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_147": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_contrast_150": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "contrast_factor": {
                    "value": "contrast_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - contrast, maxval=1 + contrast, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_154": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_saturation_157": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "saturation_factor": {
                    "value": "saturation_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - saturation, maxval=1 + saturation, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_162": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_hue_165": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "hue_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], -hue, hue)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_169": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_170": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "data/imagenet_simclr/data.py": {
        "tensorflow": {
            "placeholder_29": {
                "variable": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "map_fn_33": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "fn": {
                    "value": "_preprocess_image",
                    "type": "variable",
                    "possible_values": []
                },
                "elems": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(shape=[None], dtype=tf.string)",
                            "Call"
                        ]
                    ]
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorServingInputReceiver_35": {
                "features": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.pad(images, [[0, difference]] + [[0, 0], [0, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "receiver_tensors": {
                    "value": "image_bytes_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(shape=[None], dtype=tf.string)",
                            "Call"
                        ]
                    ]
                }
            },
            "parse_single_example_120": {
                "variable": {
                    "value": "parsed",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "keys_to_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image/encoded': tf.FixedLenFeature((), tf.string, ''), 'image/class/label': tf.FixedLenFeature([], tf.int64, -1)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "reshape_121": {
                "variable": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "parsed['image/encoded']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_122": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(parsed['image/class/label'], shape=[])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_222": {
                "variable": {
                    "value": "images_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.pad(images, [[0, difference]] + [[0, 0], [0, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_226": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.map_fn(_preprocess_image, image_bytes_list, back_prop=False, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.pad(images, [[0, difference]] + [[0, 0], [0, 0], [0, 0]])",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, difference]] + [[0, 0], [0, 0], [0, 0]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "pad_235": {
                "variable": {
                    "value": "labels[labels]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels['labels']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, difference], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_239": {
                "variable": {
                    "value": "labels[mask]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "labels['mask']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "paddings": {
                    "value": "[[0, difference]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_134": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_135": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_138": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reshape(parsed['image/class/label'], shape=[]), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(label, num_classes)",
                            "Call"
                        ],
                        [
                            "tf.zeros([num_classes])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1000",
                            "Constant"
                        ]
                    ]
                }
            },
            "zeros_328": {
                "shape": {
                    "value": "[self.image_size, self.image_size, 3]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bfloat16 if self.use_bfloat16 else tf.float32",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "TFRecordDataset_369": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": []
                },
                "buffer_size": {
                    "value": "buffer_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8 * 1024 * 1024",
                            "BinOp"
                        ]
                    ]
                }
            },
            "FixedLenFeature_116": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FixedLenFeature_117": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_123": {
                "tensor": {
                    "value": "parsed['image/class/label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "map_and_batch_193": {
                "map_func": {
                    "value": "self.dataset_parser",
                    "type": "Attribute",
                    "possible_values": []
                },
                "batch_size": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "params['batch_size']",
                            "Subscript"
                        ]
                    ]
                },
                "num_parallel_batches": {
                    "value": "self.num_parallel_calls",
                    "type": "Attribute",
                    "possible_values": []
                },
                "drop_remainder": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_340": {
                "msg": {
                    "value": "Undefined data_dir implies null input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "repeat_341": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "parallel_interleave_374": {
                "map_func": {
                    "value": "fetch_dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "cycle_length": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "sloppy": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TensorShape_100": {
                "dims": {
                    "value": "[batch_size, None, None, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_102": {
                "dims": {
                    "value": "[batch_size, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_104": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_231": {
                "dims": {
                    "value": "[batch_size, None]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_233": {
                "dims": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_334": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shuffle_and_repeat_388": {
                "buffer_size": {
                    "value": "1024 * 16",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "data/imagenet_simclr/data_util.py": {
        "tensorflow": {
            "rgb_to_grayscale_55": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_202": {
                "variable": {
                    "value": "image_width_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_203": {
                "variable": {
                    "value": "image_height_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_239": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_249": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_height, offset_width, crop_height, crop_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_251": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_height, offset_width, crop_height, crop_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_252": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_327": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_357": {
                "variable": {
                    "value": "radius",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernel_size / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_359": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(-radius, radius + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_360": {
                "variable": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_364": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[kernel_size, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_365": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, kernel_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_367": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_368": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_374": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_376": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_406": {
                "variable": {
                    "value": "(image, theta_crop)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : _transform_2(image)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_443": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_471": {
                "variable": {
                    "value": "(image, sigma)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : _transform(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_548": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_crop, tf.reshape(theta_flip, [1]), theta_color]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_551": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_552": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_575": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_576": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_577": {
                "variable": {
                    "value": "theta",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[(1 - CROP_PROPORTION) / 2, (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 1 - (1 - CROP_PROPORTION) / 2, 0, 0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_34": {
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : func(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_179": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.stack(theta_color)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_180": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "perm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_shuffle(tf.range(4))",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_206": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion / aspect_ratio * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_208": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_213": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_215": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * aspect_ratio * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_220": {
                "pred": {
                    "value": "aspect_ratio > image_width_float / image_height_float",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_requested_aspect_ratio_wider_than_image",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_image_wider_than_requested_aspect_ratio",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "extract_jpeg_shape_291": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sample_distorted_bounding_box_292": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ],
                        [
                            "tf.image.extract_jpeg_shape(image_bytes)",
                            "Call"
                        ],
                        [
                            "[bsz, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "MethodArgument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_303": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_304": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "stack_307": {
                "variable": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y, offset_x, target_height, target_width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "decode_and_crop_jpeg_308": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "crop_window": {
                    "value": "crop_window",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_height, offset_width, crop_height, crop_width])",
                            "Call"
                        ],
                        [
                            "tf.stack([offset_y, offset_x, target_height, target_width])",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_309": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_311": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_312": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([offset_y / shape[0], offset_x / shape[1], (offset_y + target_height) / shape[0], (offset_x + target_width) / shape[1]])",
                            "Call"
                        ],
                        [
                            "tf.cast(theta_crop, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_362": {
                "input_tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_373": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_379": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "decode_jpeg_402": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_403": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_425": {
                "variable": {
                    "value": "(image, theta_color)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.8, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : color_jitter_t(image)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.constant([0, 0, 0, 0], tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_431": {
                "variable": {
                    "value": "(image, theta_grey)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(0.2, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : (to_grayscale(image), tf.cast(1, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_436": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[theta_color, tf.reshape(theta_grey, [1])]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_467": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_492": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(tf.random_uniform(shape, 0, 1, dtype=tf.float32), p)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_503": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "decode_jpeg_530": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_531": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_533": {
                "variable": {
                    "value": "theta_crop",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_537": {
                "variable": {
                    "value": "(image, theta_flip)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "pred": {
                    "value": "do_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([]) > 0.5",
                            "Compare"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : (tf.image.flip_left_right(image), tf.cast(1, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : (image, tf.cast(0, dtype=tf.float32))",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cast_541": {
                "variable": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_546": {
                "variable": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 0.0, 0.0, 0.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "decode_jpeg_571": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_image_dtype_572": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_35": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_114": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_131": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_168": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(i, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "clip_by_value_177": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_253": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_289": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "shape_366": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_401": {
                "variable": {
                    "value": "crop_default",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "less_407": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_444": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_472": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_36": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_45": {
                "x": {
                    "value": "1.0 - max_delta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_179": {
                "values": {
                    "value": "theta_color",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.cast(tf.stack(theta_color), tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.gather(theta_color, perm)",
                            "Call"
                        ],
                        [
                            "tf.concat([theta_color, tf.reshape(theta_grey, [1])], axis=0)",
                            "Call"
                        ],
                        [
                            "tf.constant([0.0, 0.0, 0.0, 0.0, 0.0], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "rint_206": {
                "x": {
                    "value": "crop_proportion / aspect_ratio * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_208": {
                "x": {
                    "value": "crop_proportion * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_214": {
                "x": {
                    "value": "crop_proportion * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_215": {
                "x": {
                    "value": "crop_proportion * aspect_ratio * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "resize_bicubic_339": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "colocate_with_400": {
                "op": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_408": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_426": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.8, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "less_432": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(0.2, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_445": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_473": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_493": {
                "x": {
                    "value": "tf.random_uniform(shape, 0, 1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_505": {
                "tensor": {
                    "value": "sigma * selector",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bicubic_532": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_548": {
                "tensor": {
                    "value": "theta_flip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(0.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_bicubic_573": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "random_contrast_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_168": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_361": {
                "x": {
                    "value": "tf.to_float(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_404": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_427": {
                "x": {
                    "value": "0.8",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_433": {
                "x": {
                    "value": "0.2",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_436": {
                "tensor": {
                    "value": "theta_grey",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_447": {
                "value": {
                    "value": "[0, 0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_475": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_501": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_saturation_106": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "minval": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cond_169": {
                "pred": {
                    "value": "tf.less(i, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "brightness_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "contrast_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_170": {
                "pred": {
                    "value": "tf.less(i, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "saturation_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "hue_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_361": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([], 0.1, 2.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_429": {
                "value": {
                    "value": "[0, 0, 0, 0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_434": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_435": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "flip_left_right_537": {
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.decode_and_crop_jpeg(image_bytes, crop_window, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_jpeg(image, channels=3)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_537": {
                "x": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_538": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "random_hue_109": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_137": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_140": {
                "x": {
                    "value": "1.0 - brightness",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_147": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_contrast_150": {
                "images": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "contrast_factor": {
                    "value": "contrast_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - contrast, maxval=1 + contrast, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_154": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_saturation_157": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "saturation_factor": {
                    "value": "saturation_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], minval=1 - saturation, maxval=1 + saturation, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_162": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "adjust_hue_165": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, minval=1 - contrast, maxval=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, minval=1 - saturation, maxval=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "delta": {
                    "value": "hue_factor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform([], -hue, hue)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_169": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_170": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "data/simclr/data.py": {
        "tensorflow": {
            "flatten_51": {
                "variable": {
                    "value": "flat_args",
                    "type": "variable",
                    "possible_values": []
                },
                "structure": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_64": {
                "variable": {
                    "value": "first_tensor_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "first_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "make_one_shot_iterator_146": {
                "variable": {
                    "value": "(images, labels, mask)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dataset": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": [
                        [
                            "builder.as_dataset(split=FLAGS.train_split if is_training else FLAGS.eval_split, shuffle_files=is_training, as_supervised=True)",
                            "Call"
                        ],
                        [
                            "dataset.cache()",
                            "Call"
                        ],
                        [
                            "dataset.shuffle(params['batch_size'] * buffer_multiplier)",
                            "Call"
                        ],
                        [
                            "dataset.repeat(-1)",
                            "Call"
                        ],
                        [
                            "dataset.map(map_fn, num_parallel_calls=tf.data.experimental.AUTOTUNE)",
                            "Call"
                        ],
                        [
                            "dataset.batch(params['batch_size'], drop_remainder=is_training)",
                            "Call"
                        ],
                        [
                            "pad_to_batch(dataset, params['batch_size'])",
                            "Call"
                        ]
                    ]
                }
            },
            "pack_sequence_as_98": {
                "structure": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                },
                "flat_sequence": {
                    "value": "flat_args",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nest.flatten(args)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_94": {
                "variable": {
                    "value": "flat_args[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args",
                            "Name"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, difference]] + [[0, 0]] * (tensor.shape.ndims - 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_126": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_127": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_130": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(label, num_classes)",
                            "Call"
                        ],
                        [
                            "tf.zeros([num_classes])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "builder.info.features['label'].num_classes",
                            "Attribute"
                        ]
                    ]
                }
            },
            "shape_85": {
                "variable": {
                    "value": "curr_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flat_args",
                            "Name"
                        ]
                    ]
                }
            },
            "control_dependencies_92": {
                "control_inputs": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[tf.Assert(tf.equal(curr_shape[0], first_tensor_batch_size), ['Batch size of dataset tensors %s and %s do not match. Shapes are' % (tensor.name, first_tensor.name), curr_shape, first_tensor_shape])]",
                            "List"
                        ]
                    ]
                }
            },
            "Assert_86": {
                "condition": {
                    "value": "tf.equal(curr_shape[0], first_tensor_batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "data": {
                    "value": "['Batch size of dataset tensors %s and %s do not match. Shapes are' % (tensor.name, first_tensor.name), curr_shape, first_tensor_shape]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_87": {
                "x": {
                    "value": "curr_shape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "first_tensor_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "first_tensor_shape[0]",
                            "Subscript"
                        ]
                    ]
                }
            }
        }
    },
    "data/simclr/data_util.py": {
        "tensorflow": {
            "rgb_to_grayscale_55": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_184": {
                "variable": {
                    "value": "image_width_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[1]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_185": {
                "variable": {
                    "value": "image_height_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "image_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_220": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "crop_to_bounding_box_227": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_height - crop_height + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "offset_width": {
                    "value": "offset_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(image_width - crop_width + 1) // 2",
                            "BinOp"
                        ]
                    ]
                },
                "target_height": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion / aspect_ratio * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "target_width": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.rint(crop_proportion * image_width_float), tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.rint(crop_proportion * aspect_ratio * image_height_float), tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_298": {
                "variable": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[0.0, 0.0, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "to_int32_326": {
                "variable": {
                    "value": "radius",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "kernel_size / 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "to_float_328": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.range(-radius, radius + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_329": {
                "variable": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0))",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_333": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[kernel_size, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_334": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, kernel_size, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_336": {
                "variable": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_337": {
                "variable": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, num_channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "depthwise_conv2d_343": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [1, kernel_size, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_h, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "depthwise_conv2d_345": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "filter": {
                    "value": "blur_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(blur_filter, [kernel_size, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "tf.tile(blur_v, [1, 1, num_channels, 1])",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'SAME'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_450": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_451": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reshape_469": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[height, width, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "clip_by_value_470": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "convert_image_dtype_490": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_34": {
                "pred": {
                    "value": "tf.less(tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32), tf.cast(p, tf.float32))",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : func(x)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "tile_57": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "multiples": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_188": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion / aspect_ratio * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_190": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_width_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_195": {
                "variable": {
                    "value": "crop_height",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_197": {
                "variable": {
                    "value": "crop_width",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.rint(crop_proportion * aspect_ratio * image_height_float)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_202": {
                "pred": {
                    "value": "aspect_ratio > image_width_float / image_height_float",
                    "type": "Compare",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "_requested_aspect_ratio_wider_than_image",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "_image_wider_than_requested_aspect_ratio",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_267": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "sample_distorted_bounding_box_268": {
                "variable": {
                    "value": "sample_distorted_bounding_box",
                    "type": "variable",
                    "possible_values": []
                },
                "image_size": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "tf.shape(image)",
                            "Call"
                        ],
                        [
                            "[bsz, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "bounding_boxes": {
                    "value": "bbox",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32, shape=[1, 1, 4])",
                            "Call"
                        ]
                    ]
                },
                "min_object_covered": {
                    "value": "min_object_covered",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.1",
                            "MethodArgument"
                        ]
                    ]
                },
                "aspect_ratio_range": {
                    "value": "aspect_ratio_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.75",
                            "MethodArgument"
                        ]
                    ]
                },
                "area_range": {
                    "value": "area_range",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(0.05",
                            "MethodArgument"
                        ]
                    ]
                },
                "max_attempts": {
                    "value": "max_attempts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "100",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_image_if_no_bounding_boxes": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "unstack_279": {
                "variable": {
                    "value": "(offset_y, offset_x, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_begin",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "unstack_280": {
                "variable": {
                    "value": "(target_height, target_width, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bbox_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "crop_to_bounding_box_281": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "offset_y",
                    "type": "variable",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "offset_x",
                    "type": "variable",
                    "possible_values": []
                },
                "target_height": {
                    "value": "target_height",
                    "type": "variable",
                    "possible_values": []
                },
                "target_width": {
                    "value": "target_width",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_331": {
                "input_tensor": {
                    "value": "blur_filter",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.exp(-tf.pow(x, 2.0) / (2.0 * tf.pow(tf.to_float(sigma), 2.0)))",
                            "Call"
                        ],
                        [
                            "blur_filter / tf.reduce_sum(blur_filter)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_342": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_348": {
                "variable": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "blurred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.depthwise_conv2d(image, blur_h, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.nn.depthwise_conv2d(blurred, blur_v, strides=[1, 1, 1, 1], padding=padding)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(blurred, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_393": {
                "variable": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_413": {
                "variable": {
                    "value": "selector",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.less(tf.random_uniform(shape, 0, 1, dtype=tf.float32), p)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "clip_by_value_423": {
                "variable": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_flip_left_right_447": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "less_35": {
                "x": {
                    "value": "tf.random_uniform([], minval=0, maxval=1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(p, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_97": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "clip_by_value_114": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "name_scope_131": {
                "name": {
                    "value": "distort_color",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cond_155": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "tf.less(i, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo)",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "clip_by_value_163": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "resize_bicubic_230": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_266": {
                "name": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "resize_bicubic_308": {
                "images": {
                    "value": "[image]",
                    "type": "List",
                    "possible_values": []
                },
                "size": {
                    "value": "[height, width]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_335": {
                "input": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image * factor",
                            "BinOp"
                        ],
                        [
                            "random_brightness(image, max_delta=max_delta)",
                            "Call"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(image)",
                            "Call"
                        ],
                        [
                            "tf.tile(image, [1, 1, 3])",
                            "Call"
                        ],
                        [
                            "apply_transform(i, image, brightness, contrast, saturation, hue)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "apply_transform(perm[i], image)",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_height, offset_width, crop_height, crop_width)",
                            "Call"
                        ],
                        [
                            "tf.image.resize_bicubic([image], [height, width])[0]",
                            "Subscript"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(image, offset_y, offset_x, target_height, target_width)",
                            "Call"
                        ],
                        [
                            "distorted_bounding_box_crop(image, bbox, min_object_covered=0.1, aspect_ratio_range=(3.0 / 4 * aspect_ratio, 4.0 / 3.0 * aspect_ratio), area_range=(0.08, 1.0), max_attempts=100, scope=None)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(image, axis=0)",
                            "Call"
                        ],
                        [
                            "crop_and_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "random_apply(color_jitter_t, p=0.8, x=image)",
                            "Call"
                        ],
                        [
                            "random_crop_with_resize(image, height, width)",
                            "Call"
                        ],
                        [
                            "tf.image.random_flip_left_right(image)",
                            "Call"
                        ],
                        [
                            "random_color_jitter(image)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "center_crop(image, height, width, crop_proportion=CROP_PROPORTION)",
                            "Call"
                        ],
                        [
                            "tf.reshape(image, [height, width, 3])",
                            "Call"
                        ],
                        [
                            "tf.clip_by_value(image, 0.0, 1.0)",
                            "Call"
                        ],
                        [
                            "tf.image.convert_image_dtype(image, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_36": {
                "x": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_45": {
                "x": {
                    "value": "1.0 - max_delta",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "rint_188": {
                "x": {
                    "value": "crop_proportion / aspect_ratio * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_190": {
                "x": {
                    "value": "crop_proportion * image_width_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_196": {
                "x": {
                    "value": "crop_proportion * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "rint_197": {
                "x": {
                    "value": "crop_proportion * aspect_ratio * image_height_float",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_414": {
                "x": {
                    "value": "tf.random_uniform(shape, 0, 1, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "random_contrast_103": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "less_155": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_330": {
                "x": {
                    "value": "tf.to_float(sigma)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "2.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "shape_421": {
                "input": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "images_list",
                            "Name"
                        ],
                        [
                            "images_new * selector + images * (1 - selector)",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(images, 0.0, 1.0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_saturation_106": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_contrast_143": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - contrast",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + contrast",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_saturation_148": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "lower": {
                    "value": "1 - saturation",
                    "type": "BinOp",
                    "possible_values": []
                },
                "upper": {
                    "value": "1 + saturation",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_hue_154": {
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cond_156": {
                "pred": {
                    "value": "tf.less(i, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "brightness_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "contrast_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cond_157": {
                "pred": {
                    "value": "tf.less(i, 3)",
                    "type": "Call",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "saturation_foo",
                    "type": "variable",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "hue_foo",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "to_float_330": {
                "x": {
                    "value": "sigma",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.uniform([], 0.1, 2.0, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_hue_109": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "random_brightness(x, max_delta=brightness)",
                            "Call"
                        ],
                        [
                            "tf.image.random_contrast(x, lower=1 - contrast, upper=1 + contrast)",
                            "Call"
                        ],
                        [
                            "tf.image.random_saturation(x, lower=1 - saturation, upper=1 + saturation)",
                            "Call"
                        ],
                        [
                            "tf.image.random_hue(x, max_delta=hue)",
                            "Call"
                        ],
                        [
                            "tf.cond(tf.less(i, 2), lambda : tf.cond(tf.less(i, 1), brightness_foo, contrast_foo), lambda : tf.cond(tf.less(i, 3), saturation_foo, hue_foo))",
                            "Call"
                        ],
                        [
                            "tf.to_float(tf.range(-radius, radius + 1))",
                            "Call"
                        ]
                    ]
                },
                "max_delta": {
                    "value": "hue",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.2 * strength",
                            "BinOp"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ],
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "less_156": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "less_157": {
                "x": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ],
                        [
                            [
                                0,
                                1,
                                2,
                                3
                            ],
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "download_imagenet.py": {
        "tensorflow": {
            "enable_eager_execution_27": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "download_imagenet_2.py": {
        "tensorflow": {
            "enable_eager_execution_32": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "TFRecordDataset_54": {
                "variable": {
                    "value": "dataset",
                    "type": "variable",
                    "possible_values": []
                },
                "filenames": {
                    "value": "['gs://imagenet_data/train/train-00995-of-01024']",
                    "type": "List",
                    "possible_values": []
                }
            },
            "parse_single_example_73": {
                "variable": {
                    "value": "parsed",
                    "type": "variable",
                    "possible_values": []
                },
                "serialized": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "keys_to_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{'image/encoded': tf.FixedLenFeature((), tf.string, ''), 'image/class/label': tf.FixedLenFeature([], tf.int64, -1)}",
                            "Dict"
                        ]
                    ]
                }
            },
            "reshape_74": {
                "variable": {
                    "value": "image_bytes",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "parsed['image/encoded']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_75": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(parsed['image/class/label'], shape=[])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_87": {
                "variable": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_88": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "one_hot_91": {
                "variable": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "label",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reshape(parsed['image/class/label'], shape=[]), dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(label, num_classes)",
                            "Call"
                        ],
                        [
                            "tf.zeros([num_classes])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1000",
                            "Constant"
                        ]
                    ]
                }
            },
            "FixedLenFeature_69": {
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.string",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "",
                    "type": "str",
                    "possible_values": []
                }
            },
            "FixedLenFeature_70": {
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int64",
                    "type": "Attribute",
                    "possible_values": []
                },
                "default_value": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_76": {
                "tensor": {
                    "value": "parsed['image/class/label']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "download_imagenet_3.py": {
        "tensorflow": {
            "enable_eager_execution_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "model/lars_optimizer.py": {
        "tensorflow": {
            "get_or_create_global_step_85": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_95": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/Momentum'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "group_146": {
                "*inputs": {
                    "value": "*assignments",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'LARSOptimizer'",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "norm_108": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_109": {
                "variable": {
                    "value": "g_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad + self.weight_decay * param",
                            "BinOp"
                        ]
                    ]
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_110": {
                "variable": {
                    "value": "trust_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(w_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(g_norm, 0), self.eeta * w_norm / g_norm, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "norm_132": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_133": {
                "variable": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "update",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, next_v) + grad",
                            "BinOp"
                        ],
                        [
                            "next_v",
                            "Name"
                        ],
                        [
                            "tf.multiply(self.momentum, next_v) + scaled_lr * grad",
                            "BinOp"
                        ],
                        [
                            "next_v",
                            "Name"
                        ]
                    ]
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_134": {
                "variable": {
                    "value": "trust_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(w_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(v_norm, 0), self.eeta * w_norm / v_norm, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_initializer_100": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_117": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=param_name + '/Momentum', shape=param.shape.as_list(), dtype=tf.float32, trainable=False, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_124": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=param_name + '/Momentum', shape=param.shape.as_list(), dtype=tf.float32, trainable=False, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_111": {
                "x": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ],
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_111": {
                "condition": {
                    "value": "tf.greater(g_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.eeta * w_norm / g_norm",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "multiply_119": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "next_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, v) + grad",
                            "BinOp"
                        ],
                        [
                            "tf.multiply(self.momentum, v) + scaled_lr * grad",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_126": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "next_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, v) + grad",
                            "BinOp"
                        ],
                        [
                            "tf.multiply(self.momentum, v) + scaled_lr * grad",
                            "BinOp"
                        ]
                    ]
                }
            },
            "greater_135": {
                "x": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ],
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_135": {
                "condition": {
                    "value": "tf.greater(v_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.eeta * w_norm / v_norm",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "greater_112": {
                "x": {
                    "value": "g_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(grad, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_136": {
                "x": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(update, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model/model.py": {
        "tensorflow": {
            "split_57": {
                "variable": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(features_list, 0)",
                            "Call"
                        ],
                        [
                            "(features, thetas)",
                            "Tuple"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_transforms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "num_transforms + 1",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_84": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(features, num_or_size_splits=num_transforms, axis=-1)",
                            "Call"
                        ],
                        [
                            "features_list[:-1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_64": {
                "variable": {
                    "value": "thetas_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels['thetas']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "num_transforms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "num_transforms + 1",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_162": {
                "variable": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_166": {
                "variable": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_167": {
                "variable": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_168": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_169": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_170": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_171": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_190": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_n_192": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[sup_loss] + tf.losses.get_regularization_losses()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trainable_variables_197": {
                "variable": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_205": {
                "msg": {
                    "value": "===============Variables to train (begin)===============",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_206": {
                "msg": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "variables_to_train + tf.get_collection(collection_prefix + str(j))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_207": {
                "msg": {
                    "value": "================Variables to train (end)================",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_336": {
                "variable": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_67": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "thetas_list[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_76": {
                "variable": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(sigmas, 0)",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(thetas[:, 0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_77": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[thetas, sigmas[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_80": {
                "variable": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "thetas[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_81": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[thetas, sigmas[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_87": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_134": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_135": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_159": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_160": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_216": {
                "variable": {
                    "value": "prob_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_219": {
                "variable": {
                    "value": "prob_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_223": {
                "variable": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels_bu_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_bu_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_225": {
                "variable": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(contrast_bu_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_226": {
                "variable": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels_td_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_td_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_228": {
                "variable": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(contrast_td_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_230": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels['labels'], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_232": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(label_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_310": {
                "variable": {
                    "value": "tar_im",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(target_images[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_311": {
                "variable": {
                    "value": "viz_f",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(viz_features[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_312": {
                "variable": {
                    "value": "rec_im",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(reconstruction[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_314": {
                "variable": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_316": {
                "variable": {
                    "value": "g_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_318": {
                "variable": {
                    "value": "bu_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_319": {
                "variable": {
                    "value": "td_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_321": {
                "variable": {
                    "value": "c_bu_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_bu_con, 1), tf.argmax(logits_bu_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_bu_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_322": {
                "variable": {
                    "value": "c_td_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_td_con, 1), tf.argmax(logits_td_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_td_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_324": {
                "variable": {
                    "value": "l_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_325": {
                "variable": {
                    "value": "c_e_bu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "entropy_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(tf.reduce_sum(prob_bu_con * tf.math.log(prob_bu_con + 1e-08), -1))",
                            "UnaryOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_326": {
                "variable": {
                    "value": "c_e_td",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "entropy_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(tf.reduce_sum(prob_td_con * tf.math.log(prob_td_con + 1e-08), -1))",
                            "UnaryOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_328": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.learning_rate_schedule(FLAGS.learning_rate, num_train_examples)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_374": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.minimize(loss, global_step=tf.train.get_or_create_global_step(), var_list=variables_to_train)",
                            "Call"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "scaffold_fn": {
                    "value": "scaffold_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "host_call": {
                    "value": "host_call",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "(host_call_fn, [gs, g_l, bu_l, td_l, c_bu_a, c_td_a, l_a, c_e_bu, c_e_td, lr, tar_im, viz_f, rec_im])",
                            "Tuple"
                        ]
                    ]
                }
            },
            "accuracy_390": {
                "variable": {
                    "value": "metrics[label_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "recall_at_k_393": {
                "variable": {
                    "value": "metrics[label_top_5_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "accuracy_396": {
                "variable": {
                    "value": "metrics[bottomup_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_bu_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_bu_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "accuracy_402": {
                "variable": {
                    "value": "metrics[topdown_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_td_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_td_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_423": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "eval_metrics": {
                    "value": "(metric_fn, metrics)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "host_call": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "scaffold_fn": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "get_collection_202": {
                "key": {
                    "value": "collection_prefix + str(j)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "control_dependencies_339": {
                "control_inputs": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_417": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "fill_418": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "fill_419": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.losses.get_regularization_loss()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_115": {
                "name": {
                    "value": "td_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_122": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_123": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_140": {
                "name": {
                    "value": "bu_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_146": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_147": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_regularization_losses_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_regularization_losses_192": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_217": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prob_bu_con * tf.math.log(prob_bu_con + 1e-08), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_220": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prob_td_con * tf.math.log(prob_td_con + 1e-08), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_224": {
                "input": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_225": {
                "x": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_bu_con, 1), tf.argmax(logits_bu_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_bu_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_227": {
                "input": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_228": {
                "x": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_td_con, 1), tf.argmax(logits_td_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_td_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_231": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_232": {
                "x": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_310": {
                "x": {
                    "value": "target_images[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_311": {
                "x": {
                    "value": "viz_features[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_312": {
                "x": {
                    "value": "reconstruction[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_314": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_348": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_349": {
                "msg": {
                    "value": "'Initializing from checkpoint %s' % FLAGS.checkpoint",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_350": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "init_from_checkpoint_352": {
                "ckpt_dir_or_file": {
                    "value": "FLAGS.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "assignment_map": {
                    "value": "{v.op.name: v.op.name for v in tf.global_variables(FLAGS.variable_schema)}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "mean_388": {
                "a": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_391": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_394": {
                "input": {
                    "value": "labels_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_397": {
                "input": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_403": {
                "input": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_regularization_loss_420": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_218": {
                "input_tensor": {
                    "value": "prob_bu_con * tf.math.log(prob_bu_con + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_221": {
                "input_tensor": {
                    "value": "prob_td_con * tf.math.log(prob_td_con + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "create_file_writer_237": {
                "logdir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_queue": {
                    "value": "FLAGS.checkpoint_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "all_v2_summary_ops_302": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_or_create_global_step_341": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_362": {
                "msg": {
                    "value": "Initializing output layer parameters %s to zero",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "[x.op.name for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "group_365": {
                "variable": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "[tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Scaffold_368": {
                "init_op": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.group([tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters])",
                            "Call"
                        ]
                    ]
                }
            },
            "Scaffold_370": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_241": {
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "g_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_246": {
                "name": {
                    "value": "train_bottomup_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bu_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_251": {
                "name": {
                    "value": "train_topdown_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "td_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_256": {
                "name": {
                    "value": "train_bottomup_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_bu_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_260": {
                "name": {
                    "value": "train_topdown_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_td_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_265": {
                "name": {
                    "value": "train_label_accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "l_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_270": {
                "name": {
                    "value": "contrast_bu_entropy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_e_bu[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_274": {
                "name": {
                    "value": "contrast_td_entropy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_e_td[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_279": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "lr[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_289": {
                "name": {
                    "value": "Images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tar_im[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_293": {
                "name": {
                    "value": "Transformed images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "viz_f[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_297": {
                "name": {
                    "value": "Reconstructed images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "rec_im[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "control_dependencies_364": {
                "control_inputs": {
                    "value": "[tf.global_variables_initializer()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_218": {
                "x": {
                    "value": "prob_bu_con + 1e-08",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_221": {
                "x": {
                    "value": "prob_td_con + 1e-08",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "global_variables_355": {
                "scope": {
                    "value": "FLAGS.variable_schema",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_360": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_364": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assign_366": {
                "ref": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.zeros_like(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_366": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "model/model_hmax.py": {
        "tensorflow": {
            "split_57": {
                "variable": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(features_list, 0)",
                            "Call"
                        ],
                        [
                            "(features, thetas)",
                            "Tuple"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_transforms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "num_transforms + 1",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_84": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(features, num_or_size_splits=num_transforms, axis=-1)",
                            "Call"
                        ],
                        [
                            "features_list[:-1]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_64": {
                "variable": {
                    "value": "thetas_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "labels['thetas']",
                    "type": "Subscript",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "num_transforms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "num_transforms + 1",
                            "BinOp"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_162": {
                "variable": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_166": {
                "variable": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_167": {
                "variable": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_168": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_169": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_170": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_171": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_190": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_n_192": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[sup_loss] + tf.losses.get_regularization_losses()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trainable_variables_197": {
                "variable": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_205": {
                "msg": {
                    "value": "===============Variables to train (begin)===============",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_206": {
                "msg": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "variables_to_train + tf.get_collection(collection_prefix + str(j))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_207": {
                "msg": {
                    "value": "================Variables to train (end)================",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_336": {
                "variable": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_67": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "thetas_list[:-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_76": {
                "variable": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(sigmas, 0)",
                            "Call"
                        ],
                        [
                            "tf.zeros_like(thetas[:, 0])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_77": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[thetas, sigmas[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_80": {
                "variable": {
                    "value": "sigmas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "thetas[:, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_81": {
                "variable": {
                    "value": "thetas",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[thetas, sigmas[:, None]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_87": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_134": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_135": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_159": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_160": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_216": {
                "variable": {
                    "value": "prob_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_219": {
                "variable": {
                    "value": "prob_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                }
            },
            "equal_223": {
                "variable": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels_bu_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_bu_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_225": {
                "variable": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(contrast_bu_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_226": {
                "variable": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels_td_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_td_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_228": {
                "variable": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(contrast_td_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_230": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels['labels'], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_232": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(label_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_310": {
                "variable": {
                    "value": "tar_im",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(target_images[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_311": {
                "variable": {
                    "value": "viz_f",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(viz_features[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_312": {
                "variable": {
                    "value": "rec_im",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(reconstruction[:n_images], tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, n_images] + image_shape[1:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reshape_314": {
                "variable": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_316": {
                "variable": {
                    "value": "g_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_318": {
                "variable": {
                    "value": "bu_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_319": {
                "variable": {
                    "value": "td_l",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_321": {
                "variable": {
                    "value": "c_bu_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_bu_con, 1), tf.argmax(logits_bu_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_bu_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_322": {
                "variable": {
                    "value": "c_td_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_td_con, 1), tf.argmax(logits_td_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_td_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_324": {
                "variable": {
                    "value": "l_a",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_325": {
                "variable": {
                    "value": "c_e_bu",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "entropy_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(tf.reduce_sum(prob_bu_con * tf.math.log(prob_bu_con + 1e-08), -1))",
                            "UnaryOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_326": {
                "variable": {
                    "value": "c_e_td",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "entropy_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(tf.reduce_sum(prob_td_con * tf.math.log(prob_td_con + 1e-08), -1))",
                            "UnaryOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_328": {
                "variable": {
                    "value": "lr",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.learning_rate_schedule(FLAGS.learning_rate, num_train_examples)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_374": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.minimize(loss, global_step=tf.train.get_or_create_global_step(), var_list=variables_to_train)",
                            "Call"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "scaffold_fn": {
                    "value": "scaffold_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                },
                "host_call": {
                    "value": "host_call",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "(host_call_fn, [gs, g_l, bu_l, td_l, c_bu_a, c_td_a, l_a, c_e_bu, c_e_td, lr, tar_im, viz_f, rec_im])",
                            "Tuple"
                        ]
                    ]
                }
            },
            "accuracy_390": {
                "variable": {
                    "value": "metrics[label_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "recall_at_k_393": {
                "variable": {
                    "value": "metrics[label_top_5_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "accuracy_396": {
                "variable": {
                    "value": "metrics[bottomup_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_bu_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_bu_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "accuracy_402": {
                "variable": {
                    "value": "metrics[topdown_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_td_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_td_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_423": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([td_loss * FLAGS.td_loss_weight, bu_loss * FLAGS.bu_loss_weight] + tf.losses.get_regularization_losses())",
                            "Call"
                        ],
                        [
                            "tf.add_n([sup_loss] + tf.losses.get_regularization_losses())",
                            "Call"
                        ]
                    ]
                },
                "eval_metrics": {
                    "value": "(metric_fn, metrics)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "host_call": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "scaffold_fn": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "get_collection_202": {
                "key": {
                    "value": "collection_prefix + str(j)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "control_dependencies_339": {
                "control_inputs": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_417": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "bu_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "fill_418": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "td_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ],
                        [
                            "0.0",
                            "Constant"
                        ]
                    ]
                }
            },
            "fill_419": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.losses.get_regularization_loss()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "name_scope_115": {
                "name": {
                    "value": "td_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_122": {
                "variable": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_123": {
                "variable": {
                    "value": "labels_td_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "name_scope_140": {
                "name": {
                    "value": "bu_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_146": {
                "variable": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_147": {
                "variable": {
                    "value": "labels_bu_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], params['batch_size']]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_regularization_losses_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_regularization_losses_192": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_mean_217": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prob_bu_con * tf.math.log(prob_bu_con + 1e-08), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_220": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prob_td_con * tf.math.log(prob_td_con + 1e-08), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "argmax_224": {
                "input": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_225": {
                "x": {
                    "value": "contrast_bu_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_bu_con, 1), tf.argmax(logits_bu_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_bu_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_227": {
                "input": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_228": {
                "x": {
                    "value": "contrast_td_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_td_con, 1), tf.argmax(logits_td_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_td_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_231": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_232": {
                "x": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_310": {
                "x": {
                    "value": "target_images[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_311": {
                "x": {
                    "value": "viz_features[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_312": {
                "x": {
                    "value": "reconstruction[:n_images]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_global_step_314": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_348": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_349": {
                "msg": {
                    "value": "'Initializing from checkpoint %s' % FLAGS.checkpoint",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_350": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "init_from_checkpoint_352": {
                "ckpt_dir_or_file": {
                    "value": "FLAGS.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "assignment_map": {
                    "value": "{v.op.name: v.op.name for v in tf.global_variables(FLAGS.variable_schema)}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "mean_388": {
                "a": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_391": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_394": {
                "input": {
                    "value": "labels_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_397": {
                "input": {
                    "value": "logits_bu_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_403": {
                "input": {
                    "value": "logits_td_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ],
                        [
                            "tf.zeros([params['batch_size'], params['batch_size']])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_regularization_loss_420": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_218": {
                "input_tensor": {
                    "value": "prob_bu_con * tf.math.log(prob_bu_con + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_221": {
                "input_tensor": {
                    "value": "prob_td_con * tf.math.log(prob_td_con + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "create_file_writer_237": {
                "logdir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "max_queue": {
                    "value": "FLAGS.checkpoint_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "all_v2_summary_ops_302": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_or_create_global_step_341": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_362": {
                "msg": {
                    "value": "Initializing output layer parameters %s to zero",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "[x.op.name for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "group_365": {
                "variable": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "[tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Scaffold_368": {
                "init_op": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.group([tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters])",
                            "Call"
                        ]
                    ]
                }
            },
            "Scaffold_370": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "scalar_241": {
                "name": {
                    "value": "total_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "g_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_246": {
                "name": {
                    "value": "train_bottomup_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "bu_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_251": {
                "name": {
                    "value": "train_topdown_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "td_l[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_256": {
                "name": {
                    "value": "train_bottomup_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_bu_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_260": {
                "name": {
                    "value": "train_topdown_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_td_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_265": {
                "name": {
                    "value": "train_label_accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "l_a[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_270": {
                "name": {
                    "value": "contrast_bu_entropy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_e_bu[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_274": {
                "name": {
                    "value": "contrast_td_entropy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "c_e_td[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scalar_279": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "lr[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_289": {
                "name": {
                    "value": "Images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "tar_im[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_293": {
                "name": {
                    "value": "Transformed images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "viz_f[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "image_297": {
                "name": {
                    "value": "Reconstructed images",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "rec_im[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "gs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.train.get_global_step(), [1])",
                            "Call"
                        ],
                        [
                            "gs[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "control_dependencies_364": {
                "control_inputs": {
                    "value": "[tf.global_variables_initializer()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_218": {
                "x": {
                    "value": "prob_bu_con + 1e-08",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_221": {
                "x": {
                    "value": "prob_td_con + 1e-08",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "global_variables_355": {
                "scope": {
                    "value": "FLAGS.variable_schema",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_360": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_364": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assign_366": {
                "ref": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.zeros_like(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_366": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "model/model_util.py": {
        "tensorflow": {
            "get_or_create_global_step_61": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "where_76": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "global_step < warmup_steps",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_loss_48": {
                "loss": {
                    "value": "FLAGS.weight_decay * tf.add_n(l2_losses)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_89": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "FLAGS.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_nesterov": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "CrossShardOptimizer_105": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.MomentumOptimizer(learning_rate, FLAGS.momentum, use_nesterov=True)",
                            "Call"
                        ],
                        [
                            "tf.train.AdamOptimizer(learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.tpu.CrossShardOptimizer(optimizer)",
                            "Call"
                        ],
                        [
                            "LARSOptimizer(learning_rate, momentum=FLAGS.momentum, weight_decay=FLAGS.weight_decay, exclude_from_weight_decay=['batch_normalization', 'bias', 'head_supervised'])",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_130": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs=x, units=num_classes, use_bias=use_bias and (not use_bn), kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "resnet.batch_norm_relu(x, is_training, relu=False, center=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.identity(x, '%s_out' % name)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "use_bias and (not use_bn)",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.01)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_137": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs=x, units=num_classes, use_bias=use_bias and (not use_bn), kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "resnet.batch_norm_relu(x, is_training, relu=False, center=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.identity(x, '%s_out' % name)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'%s_out' % name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trainable_variables_184": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "l2_loss_46": {
                "t": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cosine_decay_78": {
                "learning_rate": {
                    "value": "scaled_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_learning_rate * FLAGS.train_batch_size / 256.0",
                            "BinOp"
                        ],
                        [
                            "base_learning_rate * math.sqrt(FLAGS.train_batch_size)",
                            "BinOp"
                        ]
                    ]
                },
                "global_step": {
                    "value": "global_step - warmup_steps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "total_steps - warmup_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "AdamOptimizer_92": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_129": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_143": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "l2_loss_38": {
                "t": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_loss_41": {
                "loss": {
                    "value": "FLAGS.weight_decay * tf.add_n(l2_losses)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_49": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'head_supervised' in v.name and 'bias' not in v.name]",
                            "ListComp"
                        ],
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "add_to_collection_186": {
                "name": {
                    "value": "trainable_variables_inblock_5",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_38": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_71": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "random_normal_initializer_134": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_n_42": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'head_supervised' in v.name and 'bias' not in v.name]",
                            "ListComp"
                        ],
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "relu_165": {
                "features": {
                    "value": "hiddens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "linear_layer(hiddens, is_training, out_dim, use_bias=False, use_bn=True, name='l_0')",
                            "Call"
                        ],
                        [
                            "hiddens_list[-1]",
                            "Subscript"
                        ],
                        [
                            "hiddens_list[FLAGS.ft_proj_selector]",
                            "Subscript"
                        ],
                        [
                            "linear_layer(hiddens, is_training, dim, use_bias=bias_relu, use_bn=True, name='nl_%d' % j)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(hiddens) if bias_relu else hiddens",
                            "IfExp"
                        ]
                    ]
                }
            }
        }
    },
    "model/objective.py": {
        "tensorflow": {
            "split_55": {
                "variable": {
                    "value": "(hidden1, hidden2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_61": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_62": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_sum_73": {
                "variable": {
                    "value": "logits_sim_a",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([logits_ab, logits_aa], 1) * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_74": {
                "variable": {
                    "value": "logits_sim_b",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([logits_ab, logits_aa], 1) * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_75": {
                "variable": {
                    "value": "logits_sim_both",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits_sim_a, logits_sim_b]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_77": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "norm_logits_sim_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_a))",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "split_103": {
                "variable": {
                    "value": "(hidden1, hidden2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_129": {
                "variable": {
                    "value": "loss_a",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_ab, logits_aa], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_131": {
                "variable": {
                    "value": "loss_b",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_ba, logits_bb], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_35": {
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "l2_normalize_54": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_102": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_112": {
                "x": {
                    "value": "xla.replica_id()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_114": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_115": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_119": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_120": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "l2_normalize_160": {
                "variable": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_161": {
                "variable": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(target, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(target, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_168": {
                "variable": {
                    "value": "(reconstruction1, reconstruction2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "one_hot_174": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_175": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_178": {
                "variable": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_179": {
                "variable": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_181": {
                "variable": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_182": {
                "variable": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_183": {
                "variable": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_197": {
                "variable": {
                    "value": "loss_a",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_at, logits_aa, logits_ab], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_199": {
                "variable": {
                    "value": "loss_b",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_bt, logits_ba, logits_bb], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_205": {
                "variable": {
                    "value": "logits_sim_a",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([logits_ab, logits_aa], 1) * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_206": {
                "variable": {
                    "value": "logits_sim_b",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([logits_ab, logits_aa], 1) * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_207": {
                "variable": {
                    "value": "logits_sim_both",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[logits_sim_a, logits_sim_b]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_209": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "norm_logits_sim_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_a))",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "reshape_228": {
                "variable": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_230": {
                "variable": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_231": {
                "variable": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_238": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_at, logits_aa], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_243": {
                "variable": {
                    "value": "logits_sim_a",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.concat([logits_aa, logits_at], 1) * labels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_245": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "norm_logits_sim_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_both))",
                            "UnaryOp"
                        ],
                        [
                            "-tf.log(tf.exp(logits_sim_a))",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "l2_normalize_271": {
                "variable": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "l2_normalize_272": {
                "variable": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "target",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(target, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(target, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "split_279": {
                "variable": {
                    "value": "(reconstruction1, reconstruction2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_301": {
                "variable": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_302": {
                "variable": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_304": {
                "variable": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_305": {
                "variable": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_306": {
                "variable": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_320": {
                "variable": {
                    "value": "loss_a",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_at, logits_aa, logits_ab], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_322": {
                "variable": {
                    "value": "loss_b",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_bt, logits_ba, logits_bb], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reshape_343": {
                "variable": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_345": {
                "variable": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_346": {
                "variable": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[enlarged_batch_size, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_353": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 3)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_at, logits_aa], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "scatter_nd_380": {
                "variable": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[xla.replica_id()]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "[tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_replicas] + tensor.shape.as_list()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cross_replica_sum_387": {
                "variable": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(indices=[[xla.replica_id()]], updates=[tensor], shape=[num_replicas] + tensor.shape.as_list())",
                            "Call"
                        ],
                        [
                            "tf.tpu.cross_replica_sum(ext_tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_56": {
                "input": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_64": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden1",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_66": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden2",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_68": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden2",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_69": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden1",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "log_76": {
                "x": {
                    "value": "tf.exp(logits_sim_both)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_104": {
                "input": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_122": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden1",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_124": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden2",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_126": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden2",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_127": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden1",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_130": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_132": {
                "values": {
                    "value": "[logits_ba, logits_bb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_219": {
                "x": {
                    "value": "xla.replica_id()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_221": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_222": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_225": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_226": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_290": {
                "x": {
                    "value": "xla.replica_id()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_292": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size * 3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_293": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_297": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 3",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_298": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "cast_334": {
                "x": {
                    "value": "xla.replica_id()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_336": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_337": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ],
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction1_large)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(reconstruction_large)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_340": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_341": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ],
                        [
                            "target.get_shape().as_list()[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "name_scope_375": {
                "name": {
                    "value": "tpu_cross_replica_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_392": {
                "tensor": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(indices=[[xla.replica_id()]], updates=[tensor], shape=[num_replicas] + tensor.shape.as_list())",
                            "Call"
                        ],
                        [
                            "tf.tpu.cross_replica_sum(ext_tensor)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + ext_tensor.shape.as_list()[2:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_73": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_74": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_76": {
                "x": {
                    "value": "logits_sim_both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([logits_sim_a, logits_sim_b], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits_sim_a, logits_sim_b], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_110": {
                "input": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "hidden1",
                            "Name"
                        ],
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                }
            },
            "matmul_185": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_186": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_188": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_191": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_194": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_195": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_198": {
                "values": {
                    "value": "[logits_at, logits_aa, logits_ab]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_200": {
                "values": {
                    "value": "[logits_bt, logits_ba, logits_bb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_208": {
                "x": {
                    "value": "tf.exp(logits_sim_both)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_233": {
                "a": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_234": {
                "a": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_239": {
                "values": {
                    "value": "[logits_at, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_244": {
                "x": {
                    "value": "tf.exp(logits_sim_a)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_308": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_309": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_311": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_314": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_317": {
                "a": {
                    "value": "reconstruction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction1, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction2, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction2",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction2_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_318": {
                "a": {
                    "value": "reconstruction2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction2, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_321": {
                "values": {
                    "value": "[logits_at, logits_aa, logits_ab]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_323": {
                "values": {
                    "value": "[logits_bt, logits_ba, logits_bb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_348": {
                "a": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "target_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(target, tpu_context)",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(target_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_349": {
                "a": {
                    "value": "reconstruction",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tf.math.l2_normalize(reconstruction, -1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(reconstruction, [batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_354": {
                "values": {
                    "value": "[logits_at, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_205": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_206": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_208": {
                "x": {
                    "value": "logits_sim_both",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([logits_sim_a, logits_sim_b], 0)",
                            "Call"
                        ],
                        [
                            "tf.concat([logits_sim_a, logits_sim_b], 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_217": {
                "input": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_243": {
                "values": {
                    "value": "[logits_aa, logits_at]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_244": {
                "x": {
                    "value": "logits_sim_a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.concat([logits_ab, logits_aa], 1) * labels, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.concat([logits_ab, logits_aa], 1) * labels, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(tf.concat([logits_aa, logits_at], 1) * labels, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_288": {
                "input": {
                    "value": "reconstruction1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction1, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction1",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction1_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_332": {
                "input": {
                    "value": "reconstruction_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ],
                        [
                            "tpu_cross_replica_concat(reconstruction, tpu_context)",
                            "Call"
                        ],
                        [
                            "reconstruction",
                            "Name"
                        ],
                        [
                            "tf.reshape(reconstruction_large, [enlarged_batch_size, -1])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model/resnet_ae.py": {
        "tensorflow": {
            "identity_65": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(features, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_74": {
                "variable": {
                    "value": "augs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "augs[:, None, None, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tf.constant([1, h_w, h_w, 1])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_78": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[features, augs]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "identity_140": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(features, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(features, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(outputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_52": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.greater(tf.random.uniform(shape=[B, A], minval=0.0, maxval=1.0), 0.5)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "augs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_62": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([features, augs], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_64": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([features, augs], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tanh_92": {
                "variable": {
                    "value": "recon_images_squash",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder(features, block_activities, is_training=is_training, skip=skip)",
                            "Call"
                        ],
                        [
                            "(recon_images - recon_mean) / recon_std",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(recon_images, clip_value_min=-5, clip_value_max=5)",
                            "Call"
                        ],
                        [
                            "(recon_images + 5) / 10",
                            "BinOp"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(recon_images)",
                            "Call"
                        ],
                        [
                            "tf.concat([recon_images, recon_images, recon_images], -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_105": {
                "variable": {
                    "value": "all_images",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[recon_images_squash, target_images]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_108": {
                "variable": {
                    "value": "metric_all_images",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "metric_all_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "metric(all_images, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(metric_all_images, [B, -1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[B, -1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "split_109": {
                "variable": {
                    "value": "(metric_hidden_r, metric_hidden_t)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "metric_all_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "metric(all_images, is_training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.reshape(metric_all_images, [B, -1])",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "moments_115": {
                "variable": {
                    "value": "(recon_mean, recon_std)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder(features, block_activities, is_training=is_training, skip=skip)",
                            "Call"
                        ],
                        [
                            "(recon_images - recon_mean) / recon_std",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(recon_images, clip_value_min=-5, clip_value_max=5)",
                            "Call"
                        ],
                        [
                            "(recon_images + 5) / 10",
                            "BinOp"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(recon_images)",
                            "Call"
                        ],
                        [
                            "tf.concat([recon_images, recon_images, recon_images], -1)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "clip_by_value_117": {
                "variable": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": []
                },
                "t": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder(features, block_activities, is_training=is_training, skip=skip)",
                            "Call"
                        ],
                        [
                            "(recon_images - recon_mean) / recon_std",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(recon_images, clip_value_min=-5, clip_value_max=5)",
                            "Call"
                        ],
                        [
                            "(recon_images + 5) / 10",
                            "BinOp"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(recon_images)",
                            "Call"
                        ],
                        [
                            "tf.concat([recon_images, recon_images, recon_images], -1)",
                            "Call"
                        ]
                    ]
                },
                "clip_value_min": {
                    "value": "-5",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "clip_value_max": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_137": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([features, augs], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_139": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([features, augs], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_55": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_74": {
                "value": {
                    "value": "[1, h_w, h_w, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_80": {
                "name_or_scope": {
                    "value": "decoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_90": {
                "name_or_scope": {
                    "value": "metric",
                    "type": "str",
                    "possible_values": []
                }
            },
            "rgb_to_grayscale_121": {
                "variable": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "decoder(features, block_activities, is_training=is_training, skip=skip)",
                            "Call"
                        ],
                        [
                            "(recon_images - recon_mean) / recon_std",
                            "BinOp"
                        ],
                        [
                            "tf.clip_by_value(recon_images, clip_value_min=-5, clip_value_max=5)",
                            "Call"
                        ],
                        [
                            "(recon_images + 5) / 10",
                            "BinOp"
                        ],
                        [
                            "tf.image.rgb_to_grayscale(recon_images)",
                            "Call"
                        ],
                        [
                            "tf.concat([recon_images, recon_images, recon_images], -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_122": {
                "variable": {
                    "value": "recon_images",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[recon_images, recon_images, recon_images]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_131": {
                "name_or_scope": {
                    "value": "encoder",
                    "type": "str",
                    "possible_values": []
                }
            },
            "greater_52": {
                "x": {
                    "value": "tf.random.uniform(shape=[B, A], minval=0.0, maxval=1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_101": {
                "variable": {
                    "value": "target_images",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[target_images, target_images]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "uniform_52": {
                "shape": {
                    "value": "[B, A]",
                    "type": "List",
                    "possible_values": []
                },
                "minval": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "model/resnet_decoder.py": {
        "tensorflow": {
            "meshgrid_272": {
                "variable": {
                    "value": "(w_i, h_i)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_273": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_279": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_280": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1 if data_format == 'channels_last' else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "cast_286": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_377": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(inputs, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_381": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(inputs, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "pooling_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_383": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "mid_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(int(filters * sk_ratio), min_dim)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv2d_389": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "2 * filters",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_393": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(mixing, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_394": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2D_403": {
                "variable": {
                    "value": "se_reduce",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "max(1, int(filters * se_ratio))",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2D_411": {
                "variable": {
                    "value": "se_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "inputs.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_421": {
                "variable": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "spatial_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_initializer_193": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_195": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "batch_normalization_213": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "BATCH_NORM_DECAY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Constant"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "BATCH_NORM_EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Constant"
                        ]
                    ]
                },
                "center": {
                    "value": "center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gamma_initializer": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_225": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_256": {
                "msg": {
                    "value": "'Applying DropBlock: dropblock_size {}, net.shape {}'.format(dropblock_size, net.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_289": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2] if data_format == 'channels_last' else [2, 3]",
                    "type": "IfExp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_329": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_332": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_359": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_396": {
                "input_tensor": {
                    "value": "inputs * mixing",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "resize_483": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "relu_498": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_594": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_633": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_167": {
                "variable": {
                    "value": "mean_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "group_mean - shard_mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_274": {
                "x": {
                    "value": "w_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "w_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_and_276": {
                "x": {
                    "value": "h_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "h_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "cast_302": {
                "x": {
                    "value": "tf.size(block_pattern)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_305": {
                "x": {
                    "value": "percent_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(block_pattern), tf.float32) / tf.cast(tf.size(block_pattern), tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "net.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_377": {
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "reduce_sum_382": {
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_393": {
                "value": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "relu_423": {
                "features": {
                    "value": "se_reduce(se_tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_424": {
                "x": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs, spatial_dims, keepdims=True)",
                            "Call"
                        ],
                        [
                            "se_expand(tf.nn.relu(se_reduce(se_tensor)))",
                            "Call"
                        ]
                    ]
                }
            },
            "resize_546": {
                "variable": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_567": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_573": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_823": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "identity_824": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "resize_L-1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "resize_852": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "identity_853": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "resize_L",
                    "type": "str",
                    "possible_values": []
                }
            },
            "trainable_variables_68": {
                "variable": {
                    "value": "trainable_variables[after_block]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cross_replica_sum_151": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_151": {
                "x": {
                    "value": "num_shards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ],
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "t.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool_298": {
                "input": {
                    "value": "-block_pattern",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "ksize": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, dropblock_size, dropblock_size, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, dropblock_size, dropblock_size]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC if data_format == channels_last else NCHW",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "reduce_sum_302": {
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "size_303": {
                "input": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "resize_465": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_473": {
                "variable": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "resize_535": {
                "variable": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "resize_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[4, 4]",
                            "List"
                        ],
                        [
                            "[7, 7]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ],
                        [
                            "[resize_shape[0] * 2, resize_shape[1] * 2]",
                            "List"
                        ]
                    ]
                }
            },
            "trainable_variables_676": {
                "variable": {
                    "value": "trainable_variables[after_block]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_71": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "max_pooling2d_105": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "kernel",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "stride",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "cast_284": {
                "x": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_679": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_to_collection_85": {
                "name": {
                    "value": "collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ],
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ]
                    ]
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ],
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ]
                    ]
                }
            },
            "add_to_collection_693": {
                "name": {
                    "value": "collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ],
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ]
                    ]
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ],
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ]
                    ]
                }
            },
            "reduce_mean_113": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_115": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=fan_out, kernel_size=kernel, strides=stride, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=kernel, strides=stride, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, 1, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, resize_shape=resize_shape, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, None, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], resize_shape=resize_shape, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], resize_shape=resize_shape, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block4']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], resize_shape=resize_shape, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block3']",
                            "BinOp"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], resize_shape=resize_shape, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "inputs + endpoints['block2']",
                            "BinOp"
                        ],
                        [
                            "inputs + endpoints['block1']",
                            "BinOp"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L-1')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(inputs, resize_shape)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'resize_L')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=3, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "model/resnet_encoder.py": {
        "tensorflow": {
            "meshgrid_192": {
                "variable": {
                    "value": "(w_i, h_i)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_193": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_199": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_200": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1 if data_format == 'channels_last' else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "cast_206": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_297": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(inputs, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_301": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(inputs, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "pooling_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_303": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "mid_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(int(filters * sk_ratio), min_dim)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv2d_309": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "2 * filters",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_313": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(mixing, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_314": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2D_323": {
                "variable": {
                    "value": "se_reduce",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "max(1, int(filters * se_ratio))",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2D_331": {
                "variable": {
                    "value": "se_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "inputs.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_341": {
                "variable": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "spatial_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_initializer_113": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_115": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "batch_normalization_133": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "BATCH_NORM_DECAY",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.9",
                            "Constant"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "BATCH_NORM_EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Constant"
                        ]
                    ]
                },
                "center": {
                    "value": "center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gamma_initializer": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_145": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "info_176": {
                "msg": {
                    "value": "'Applying DropBlock: dropblock_size {}, net.shape {}'.format(dropblock_size, net.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_209": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2] if data_format == 'channels_last' else [2, 3]",
                    "type": "IfExp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_249": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_252": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_279": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_316": {
                "input_tensor": {
                    "value": "inputs * mixing",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_407": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_495": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_534": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_87": {
                "variable": {
                    "value": "mean_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "group_mean - shard_mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_194": {
                "x": {
                    "value": "w_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "w_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_and_196": {
                "x": {
                    "value": "h_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "h_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "cast_222": {
                "x": {
                    "value": "tf.size(block_pattern)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_225": {
                "x": {
                    "value": "percent_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(block_pattern), tf.float32) / tf.cast(tf.size(block_pattern), tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "net.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_297": {
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "reduce_sum_302": {
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_313": {
                "value": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "relu_343": {
                "features": {
                    "value": "se_reduce(se_tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_344": {
                "x": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs, spatial_dims, keepdims=True)",
                            "Call"
                        ],
                        [
                            "se_expand(tf.nn.relu(se_reduce(se_tensor)))",
                            "Call"
                        ]
                    ]
                }
            },
            "average_pooling2d_380": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "average_pooling2d_446": {
                "variable": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(shortcut, is_training, relu=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "dropblock(shortcut, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters_out, kernel_size=1, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "batch_norm_relu(shortcut, is_training, relu=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(shortcut, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=shortcut, filters=filters_out, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_579": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_581": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_599": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pooling2d_602": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_605": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stop_gradient_632": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_643": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_655": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_667": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_679": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, SK_RATIO, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, SE_RATIO, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "cross_replica_sum_71": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_71": {
                "x": {
                    "value": "num_shards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ],
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "t.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool_218": {
                "input": {
                    "value": "-block_pattern",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "ksize": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, dropblock_size, dropblock_size, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, dropblock_size, dropblock_size]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC if data_format == channels_last else NCHW",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "reduce_sum_222": {
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "size_223": {
                "input": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "trainable_variables_610": {
                "variable": {
                    "value": "trainable_variables[after_block]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_204": {
                "x": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_613": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_to_collection_627": {
                "name": {
                    "value": "collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ]
                    ]
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "model/resnet_layers.py": {
        "tensorflow": {
            "floor_46": {
                "variable": {
                    "value": "binary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "random_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "keep_prob",
                            "Name"
                        ],
                        [
                            "random_tensor + tf.random_uniform([batch_size, 1, 1, 1], dtype=inputs.dtype)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "Conv2D_70": {
                "variable": {
                    "value": "se_reduce",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "num_reduced_filters",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(1, int(in_filters * se_ratio))",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2D_78": {
                "variable": {
                    "value": "se_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "in_filters * expand_ratio",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_92": {
                "variable": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "spatial_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3]",
                            "List"
                        ],
                        [
                            "[1, 2]",
                            "List"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_43": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "div_47": {
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "y": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0 - drop_connect_rate",
                            "BinOp"
                        ]
                    ]
                }
            },
            "relu_93": {
                "features": {
                    "value": "se_reduce(se_tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_95": {
                "x": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs, spatial_dims, keepdims=True)",
                            "Call"
                        ],
                        [
                            "se_expand(tf.nn.relu(se_reduce(se_tensor)))",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model/resnet_model.py": {
        "tensorflow": {
            "batch_normalization_91": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "3",
                            "Constant"
                        ],
                        [
                            "3 if data_format == 'channels_last' else 1",
                            "IfExp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "bn_momentum",
                    "type": "variable",
                    "possible_values": [
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ],
                        [
                            "MOVING_AVERAGE_DECAY",
                            "MethodArgument"
                        ]
                    ]
                },
                "epsilon": {
                    "value": "EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Constant"
                        ]
                    ]
                },
                "center": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "scale": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gamma_initializer": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ],
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "moments_112": {
                "variable": {
                    "value": "(_, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2] if data_format == 'channels_last' else [2, 3]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_127": {
                "variable": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'moving_variance'",
                            "MethodArgument"
                        ]
                    ]
                },
                "shape": {
                    "value": "var_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1, 1, 1, inputs.shape[3])",
                            "Tuple"
                        ],
                        [
                            "(1, inputs.shape[1], 1, 1)",
                            "Tuple"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.initializers.ones()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "collections": {
                    "value": "[tf.GraphKeys.MOVING_AVERAGE_VARIABLES, tf.GraphKeys.GLOBAL_VARIABLES]",
                    "type": "List",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sqrt_146": {
                "variable": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "variance + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_156": {
                "variable": {
                    "value": "dynamic_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tensor",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sqrt_185": {
                "variable": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "variance + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "broadcast_to_186": {
                "variable": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.broadcast_to(std, _get_shape_list(x))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "_get_shape_list(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "meshgrid_315": {
                "variable": {
                    "value": "(w_i, h_i)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_316": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_322": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_323": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1 if data_format == 'channels_last' else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "cast_329": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_82": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_84": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "relu_103": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                }
            },
            "sqrt_113": {
                "x": {
                    "value": "variance + epsilon",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "moments_138": {
                "variable": {
                    "value": "(_, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 2] if data_format == 'channels_last' else [2, 3]",
                            "IfExp"
                        ]
                    ]
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_139": {
                "variable": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(variance, tf.float32)",
                            "Call"
                        ],
                        [
                            "moving_variance",
                            "Name"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "assign_sub_140": {
                "variable": {
                    "value": "update_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "moving_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=name, shape=var_shape, initializer=tf.initializers.ones(), dtype=tf.float32, collections=[tf.GraphKeys.MOVING_AVERAGE_VARIABLES, tf.GraphKeys.GLOBAL_VARIABLES], trainable=False)",
                            "Call"
                        ]
                    ]
                },
                "value": {
                    "value": "(moving_variance - variance) * (1 - decay)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_147": {
                "x": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.broadcast_to(std, _get_shape_list(x))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_179": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, h, w, num_groups, c // num_groups]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_180": {
                "variable": {
                    "value": "(_, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, h, w, num_groups, c // num_groups])",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, num_groups, c // num_groups, h, w])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[1, 2, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_183": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, num_groups, c // num_groups, h, w]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "moments_184": {
                "variable": {
                    "value": "(_, variance)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(inputs, [-1, h, w, num_groups, c // num_groups])",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, num_groups, c // num_groups, h, w])",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[2, 3, 4]",
                    "type": "List",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_187": {
                "tensor": {
                    "value": "std",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.sqrt(variance + epsilon)",
                            "Call"
                        ],
                        [
                            "tf.broadcast_to(std, _get_shape_list(x))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "_get_shape_list(inputs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_initializer_225": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_227": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_234": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "beta",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "var_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1, 1, 1, inputs.shape[3])",
                            "Tuple"
                        ],
                        [
                            "(1, inputs.shape[1], 1, 1)",
                            "Tuple"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_239": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gamma",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "var_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1, 1, 1, inputs.shape[3])",
                            "Tuple"
                        ],
                        [
                            "(1, inputs.shape[1], 1, 1)",
                            "Tuple"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ],
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "info_299": {
                "msg": {
                    "value": "'Applying DropBlock: dropblock_size {}, net.shape {}'.format(dropblock_size, net.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_332": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2] if data_format == 'channels_last' else [2, 3]",
                    "type": "IfExp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_372": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_375": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_402": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_652": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'moving_variance'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_735": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "average_pooling2d_802": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "pool_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(inputs.shape[1], inputs.shape[2])",
                            "Tuple"
                        ],
                        [
                            "(inputs.shape[2], inputs.shape[3])",
                            "Tuple"
                        ]
                    ]
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_805": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_806": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, 2048 if block_fn is bottleneck_block else 512]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "dense_814": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.01)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_818": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_dense",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_143": {
                "name": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "update_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.assign_sub(moving_variance, (moving_variance - variance) * (1 - decay))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_233": {
                "name_or_scope": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "default_name": {
                    "value": "evonorm",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_245": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "v",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "var_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(1, 1, 1, inputs.shape[3])",
                            "Tuple"
                        ],
                        [
                            "(1, inputs.shape[1], 1, 1)",
                            "Tuple"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.ones_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_317": {
                "x": {
                    "value": "w_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "w_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_and_319": {
                "x": {
                    "value": "h_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "h_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "cast_345": {
                "x": {
                    "value": "tf.size(block_pattern)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_348": {
                "x": {
                    "value": "percent_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(block_pattern), tf.float32) / tf.cast(tf.size(block_pattern), tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "net.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "relu_481": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_591": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "dropout_811": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "dropout_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "ones_130": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "max_pool_341": {
                "input": {
                    "value": "-block_pattern",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "ksize": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, dropblock_size, dropblock_size, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, dropblock_size, dropblock_size]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC if data_format == channels_last else NCHW",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "reduce_sum_345": {
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "size_346": {
                "input": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "info_587": {
                "msg": {
                    "value": "'using drop_connect: {}'.format(drop_connect_rate)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pooling2d_749": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_752": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=bn_momentum, epsilon=EPSILON, center=True, scale=True, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "inputs * tf.nn.sigmoid(v * inputs) / den",
                            "BinOp"
                        ],
                        [
                            "inputs / tf.maximum(left, right)",
                            "BinOp"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, nonlinearity=False, init_zero=True, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "resnet_layers.squeeze_excitation(inputs, in_filters=4 * filters, se_ratio=se_ratio, data_format='channels_last')",
                            "Call"
                        ],
                        [
                            "resnet_layers.drop_connect(inputs, is_training, drop_connect_rate)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size, pre_activation=pre_activation, norm_act_layer=norm_act_layer, se_ratio=se_ratio, resnetd_shortcut=resnetd_shortcut, drop_connect_rate=drop_connect_rate, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=32, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=64, block_fn=block_fn, blocks=layers[0], strides=stride_c2, is_training=is_training, name='block_group1', dropblock_keep_prob=dropblock_keep_probs[0], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 2, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=128, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', dropblock_keep_prob=dropblock_keep_probs[1], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 3, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=256, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', dropblock_keep_prob=dropblock_keep_probs[2], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 4, num_layers))",
                            "Call"
                        ],
                        [
                            "custom_block_group(inputs=inputs, filters=512, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', dropblock_keep_prob=dropblock_keep_probs[3], drop_connect_rate=resnet_layers.get_drop_connect_rate(drop_connect_rate, 5, num_layers))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "norm_activation(inputs, is_training, data_format=data_format, layer=norm_act_layer, bn_momentum=bn_momentum)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs=inputs, pool_size=pool_size, strides=1, padding='VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ],
                        [
                            "tf.reshape(inputs, [-1, 2048 if block_fn is bottleneck_block else 512])",
                            "Call"
                        ],
                        [
                            "tf.layers.dropout(inputs, rate=dropout_rate, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.dense(inputs=inputs, units=num_classes, kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_dense')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_810": {
                "msg": {
                    "value": "using dropout",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_initializer_238": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_327": {
                "x": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "AveragePooling2D_529": {
                "pool_size": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "random_normal_initializer_817": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "ones_initializer_249": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sigmoid_256": {
                "x": {
                    "value": "v * inputs",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_266": {
                "x": {
                    "value": "left",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_batch_std(inputs, decay=decay, epsilon=epsilon, data_format=data_format, training=is_training)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "right",
                    "type": "variable",
                    "possible_values": [
                        [
                            "v * inputs + _instance_std(inputs, epsilon=epsilon, data_format=data_format)",
                            "BinOp"
                        ]
                    ]
                }
            }
        }
    },
    "model_simclr/lars_optimizer.py": {
        "tensorflow": {
            "get_or_create_global_step_85": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_95": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "param_name + '/Momentum'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "param.shape.as_list()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "group_146": {
                "*inputs": {
                    "value": "*assignments",
                    "type": "Starred",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'LARSOptimizer'",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "norm_108": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_109": {
                "variable": {
                    "value": "g_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "grad",
                    "type": "variable",
                    "possible_values": [
                        [
                            "grad + self.weight_decay * param",
                            "BinOp"
                        ]
                    ]
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_110": {
                "variable": {
                    "value": "trust_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(w_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(g_norm, 0), self.eeta * w_norm / g_norm, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "norm_132": {
                "variable": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "param",
                    "type": "variable",
                    "possible_values": []
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "norm_133": {
                "variable": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "update",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, next_v) + grad",
                            "BinOp"
                        ],
                        [
                            "next_v",
                            "Name"
                        ],
                        [
                            "tf.multiply(self.momentum, next_v) + scaled_lr * grad",
                            "BinOp"
                        ],
                        [
                            "next_v",
                            "Name"
                        ]
                    ]
                },
                "ord": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_134": {
                "variable": {
                    "value": "trust_ratio",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.greater(w_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.where(tf.greater(v_norm, 0), self.eeta * w_norm / v_norm, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_initializer_100": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "multiply_117": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=param_name + '/Momentum', shape=param.shape.as_list(), dtype=tf.float32, trainable=False, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "multiply_124": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name=param_name + '/Momentum', shape=param.shape.as_list(), dtype=tf.float32, trainable=False, initializer=tf.zeros_initializer())",
                            "Call"
                        ]
                    ]
                }
            },
            "greater_111": {
                "x": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ],
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_111": {
                "condition": {
                    "value": "tf.greater(g_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.eeta * w_norm / g_norm",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "multiply_119": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "next_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, v) + grad",
                            "BinOp"
                        ],
                        [
                            "tf.multiply(self.momentum, v) + scaled_lr * grad",
                            "BinOp"
                        ]
                    ]
                }
            },
            "multiply_126": {
                "x": {
                    "value": "self.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "y": {
                    "value": "next_v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.multiply(self.momentum, v) + grad",
                            "BinOp"
                        ],
                        [
                            "tf.multiply(self.momentum, v) + scaled_lr * grad",
                            "BinOp"
                        ]
                    ]
                }
            },
            "greater_135": {
                "x": {
                    "value": "w_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ],
                        [
                            "tf.norm(param, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_135": {
                "condition": {
                    "value": "tf.greater(v_norm, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "self.eeta * w_norm / v_norm",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "greater_112": {
                "x": {
                    "value": "g_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(grad, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "greater_136": {
                "x": {
                    "value": "v_norm",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.norm(update, ord=2)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "model_simclr/model.py": {
        "tensorflow": {
            "split_52": {
                "variable": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat(features_list, 0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "num_transforms",
                    "type": "variable",
                    "possible_values": [
                        [
                            "2",
                            "Constant"
                        ],
                        [
                            "1",
                            "Constant"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_57": {
                "variable": {
                    "value": "features",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "features_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(features, num_or_size_splits=num_transforms, axis=-1)",
                            "Call"
                        ],
                        [
                            "data_util.batch_random_blur(features_list, FLAGS.image_size, FLAGS.image_size)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_total_loss_93": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_78": {
                "variable": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], num_classes]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_80": {
                "variable": {
                    "value": "contrast_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_81": {
                "variable": {
                    "value": "logits_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_82": {
                "variable": {
                    "value": "labels_con",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "[params['batch_size'], 10]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "trainable_variables_96": {
                "variable": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_104": {
                "msg": {
                    "value": "===============Variables to train (begin)===============",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_105": {
                "msg": {
                    "value": "variables_to_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "variables_to_train + tf.get_collection(collection_prefix + str(j))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "info_106": {
                "msg": {
                    "value": "================Variables to train (end)================",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_154": {
                "variable": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.UPDATE_OPS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_60": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_114": {
                "variable": {
                    "value": "prob_con",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ]
                    ]
                }
            },
            "create_file_writer_118": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_191": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "train_op": {
                    "value": "train_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "optimizer.minimize(loss, global_step=tf.train.get_or_create_global_step(), var_list=variables_to_train)",
                            "Call"
                        ]
                    ]
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                },
                "scaffold_fn": {
                    "value": "scaffold_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ]
                    ]
                }
            },
            "accuracy_200": {
                "variable": {
                    "value": "metrics[label_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "recall_at_k_203": {
                "variable": {
                    "value": "metrics[label_top_5_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_sup, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ],
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "accuracy_205": {
                "variable": {
                    "value": "metrics[contrastive_top_1_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "tf.argmax(logits_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "recall_at_k_208": {
                "variable": {
                    "value": "metrics[contrastive_top_5_accuracy]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.argmax(labels_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "predictions": {
                    "value": "logits_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "5",
                    "type": "int",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "TPUEstimatorSpec_223": {
                "mode": {
                    "value": "mode",
                    "type": "variable",
                    "possible_values": []
                },
                "loss": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.losses.get_total_loss()",
                            "Call"
                        ]
                    ]
                },
                "eval_metrics": {
                    "value": "(metric_fn, metrics)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "scaffold_fn": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                }
            },
            "get_collection_101": {
                "key": {
                    "value": "collection_prefix + str(j)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "control_dependencies_157": {
                "control_inputs": {
                    "value": "control_deps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.UPDATE_OPS)",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_218": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "contrast_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_219": {
                "dims": {
                    "value": "(params['batch_size'],)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.losses.get_regularization_loss()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_115": {
                "input_tensor": {
                    "value": "tf.reduce_sum(prob_con * tf.math.log(prob_con + 1e-08), -1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_120": {
                "control_inputs": {
                    "value": "[summary_writer.init()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "equal_122": {
                "variable": {
                    "value": "should_record",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.floormod(tf.train.get_global_step(), FLAGS.train_summary_steps)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "all_v2_summary_ops_156": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_165": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_166": {
                "msg": {
                    "value": "'Initializing from checkpoint %s' % FLAGS.checkpoint",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "info_167": {
                "msg": {
                    "value": "'*' * 180",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "init_from_checkpoint_169": {
                "ckpt_dir_or_file": {
                    "value": "FLAGS.checkpoint",
                    "type": "Attribute",
                    "possible_values": []
                },
                "assignment_map": {
                    "value": "{v.op.name: v.op.name for v in tf.global_variables(FLAGS.variable_schema)}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "mean_198": {
                "a": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "argmax_201": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ],
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_204": {
                "input": {
                    "value": "labels_sup",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_206": {
                "input": {
                    "value": "logits_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "argmax_209": {
                "input": {
                    "value": "labels_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_regularization_loss_220": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_116": {
                "input_tensor": {
                    "value": "prob_con * tf.math.log(prob_con + 1e-08)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "equal_126": {
                "variable": {
                    "value": "contrast_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels_con, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_con, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_128": {
                "variable": {
                    "value": "contrast_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(contrast_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "equal_129": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.argmax(labels['labels'], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.argmax(logits_sup, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_131": {
                "variable": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(label_acc, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_or_create_global_step_159": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "info_179": {
                "msg": {
                    "value": "Initializing output layer parameters %s to zero",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "[x.op.name for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "group_182": {
                "variable": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "[tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "Scaffold_185": {
                "init_op": {
                    "value": "init_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.group([tf.assign(x, tf.zeros_like(x)) for x in output_layer_parameters])",
                            "Call"
                        ]
                    ]
                }
            },
            "Scaffold_187": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "floormod_123": {
                "x": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "FLAGS.train_summary_steps",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_132": {
                "name": {
                    "value": "train_contrast_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "contrast_loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([])",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_136": {
                "name": {
                    "value": "train_contrast_acc",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "contrast_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_con, 1), tf.argmax(logits_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_140": {
                "name": {
                    "value": "train_label_accuracy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_144": {
                "name": {
                    "value": "contrast_entropy",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "entropy_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-tf.reduce_mean(tf.reduce_sum(prob_con * tf.math.log(prob_con + 1e-08), -1))",
                            "UnaryOp"
                        ]
                    ]
                },
                "step": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_148": {
                "name": {
                    "value": "learning_rate",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_util.learning_rate_schedule(FLAGS.learning_rate, num_train_examples)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "tf.train.get_global_step()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "control_dependencies_181": {
                "control_inputs": {
                    "value": "[tf.global_variables_initializer()]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_116": {
                "x": {
                    "value": "prob_con + 1e-08",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "get_global_step_123": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "argmax_127": {
                "input": {
                    "value": "logits_con",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], 10])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_128": {
                "x": {
                    "value": "contrast_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels_con, 1), tf.argmax(logits_con, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(contrast_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_130": {
                "input": {
                    "value": "logits_sup",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros([params['batch_size'], num_classes])",
                            "Call"
                        ],
                        [
                            "model_util.supervised_head(hiddens, num_classes, is_training)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_131": {
                "x": {
                    "value": "label_acc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.equal(tf.argmax(labels['labels'], 1), tf.argmax(logits_sup, axis=1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.cast(label_acc, tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "global_variables_172": {
                "scope": {
                    "value": "FLAGS.variable_schema",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_177": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_global_step_135": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_global_step_139": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_global_step_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_global_step_147": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_global_step_150": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "global_variables_initializer_181": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "assign_183": {
                "ref": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.zeros_like(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_183": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "model_simclr/model_util.py": {
        "tensorflow": {
            "get_or_create_global_step_61": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "where_76": {
                "variable": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "global_step < warmup_steps",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_loss_48": {
                "loss": {
                    "value": "FLAGS.weight_decay * tf.add_n(l2_losses)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "MomentumOptimizer_89": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                },
                "momentum": {
                    "value": "FLAGS.momentum",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_nesterov": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "CrossShardOptimizer_105": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "opt": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.MomentumOptimizer(learning_rate, FLAGS.momentum, use_nesterov=True)",
                            "Call"
                        ],
                        [
                            "tf.train.AdamOptimizer(learning_rate)",
                            "Call"
                        ],
                        [
                            "tf.tpu.CrossShardOptimizer(optimizer)",
                            "Call"
                        ],
                        [
                            "LARSOptimizer(learning_rate, momentum=FLAGS.momentum, weight_decay=FLAGS.weight_decay, exclude_from_weight_decay=['batch_normalization', 'bias', 'head_supervised'])",
                            "Call"
                        ]
                    ]
                }
            },
            "dense_130": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs=x, units=num_classes, use_bias=use_bias and (not use_bn), kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "resnet.batch_norm_relu(x, is_training, relu=False, center=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.identity(x, '%s_out' % name)",
                            "Call"
                        ]
                    ]
                },
                "units": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "use_bias and (not use_bn)",
                    "type": "BoolOp",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.random_normal_initializer(stddev=0.01)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "identity_137": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.dense(inputs=x, units=num_classes, use_bias=use_bias and (not use_bn), kernel_initializer=tf.random_normal_initializer(stddev=0.01))",
                            "Call"
                        ],
                        [
                            "resnet.batch_norm_relu(x, is_training, relu=False, center=use_bias)",
                            "Call"
                        ],
                        [
                            "tf.identity(x, '%s_out' % name)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "'%s_out' % name",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "trainable_variables_184": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "l2_loss_46": {
                "t": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cosine_decay_78": {
                "learning_rate": {
                    "value": "scaled_lr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_learning_rate * FLAGS.train_batch_size / 256.0",
                            "BinOp"
                        ],
                        [
                            "base_learning_rate * math.sqrt(FLAGS.train_batch_size)",
                            "BinOp"
                        ]
                    ]
                },
                "global_step": {
                    "value": "global_step - warmup_steps",
                    "type": "BinOp",
                    "possible_values": []
                },
                "decay_steps": {
                    "value": "total_steps - warmup_steps",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "AdamOptimizer_92": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "learning_rate",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.to_float(global_step) / int(warmup_steps) * scaled_lr if warmup_steps else scaled_lr",
                            "IfExp"
                        ],
                        [
                            "tf.where(global_step < warmup_steps, learning_rate, tf.train.cosine_decay(scaled_lr, global_step - warmup_steps, total_steps - warmup_steps))",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_129": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_143": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'linear_layer'",
                            "MethodArgument"
                        ],
                        [
                            "'head_contrastive'",
                            "MethodArgument"
                        ],
                        [
                            "'head_supervised'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "l2_loss_38": {
                "t": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "add_loss_41": {
                "loss": {
                    "value": "FLAGS.weight_decay * tf.add_n(l2_losses)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "loss_collection": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_46": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_n_49": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'head_supervised' in v.name and 'bias' not in v.name]",
                            "ListComp"
                        ],
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "add_to_collection_186": {
                "name": {
                    "value": "trainable_variables_inblock_5",
                    "type": "str",
                    "possible_values": []
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ]
                    ]
                }
            },
            "trainable_variables_38": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "to_float_71": {
                "x": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.train.get_or_create_global_step()",
                            "Call"
                        ]
                    ]
                }
            },
            "random_normal_initializer_134": {
                "stddev": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_n_42": {
                "inputs": {
                    "value": "l2_losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'head_supervised' in v.name and 'bias' not in v.name]",
                            "ListComp"
                        ],
                        [
                            "[tf.nn.l2_loss(v) for v in tf.trainable_variables() if 'batch_normalization' not in v.name]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "relu_165": {
                "features": {
                    "value": "hiddens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "linear_layer(hiddens, is_training, out_dim, use_bias=False, use_bn=True, name='l_0')",
                            "Call"
                        ],
                        [
                            "hiddens_list[-1]",
                            "Subscript"
                        ],
                        [
                            "hiddens_list[FLAGS.ft_proj_selector]",
                            "Subscript"
                        ],
                        [
                            "linear_layer(hiddens, is_training, dim, use_bias=bias_relu, use_bn=True, name='nl_%d' % j)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(hiddens) if bias_relu else hiddens",
                            "IfExp"
                        ]
                    ]
                }
            }
        }
    },
    "model_simclr/objective.py": {
        "tensorflow": {
            "split_60": {
                "variable": {
                    "value": "(hidden1, hidden2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_cross_entropy_86": {
                "variable": {
                    "value": "loss_a",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_ab, logits_aa], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_88": {
                "variable": {
                    "value": "loss_b",
                    "type": "variable",
                    "possible_values": []
                },
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "tf.concat([logits_ba, logits_bb], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "softmax_cross_entropy_35": {
                "onehot_labels": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.one_hot(labels_idx, enlarged_batch_size * 2)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(tf.range(batch_size), batch_size * 2)",
                            "Call"
                        ]
                    ]
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "weights": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "l2_normalize_59": {
                "variable": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "hidden",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.l2_normalize(hidden, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_69": {
                "x": {
                    "value": "xla.replica_id()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.uint32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_71": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_72": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "labels_idx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(batch_size) + replica_id * batch_size",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "enlarged_batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1_large)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "one_hot_76": {
                "variable": {
                    "value": "labels",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size * 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_77": {
                "variable": {
                    "value": "masks",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.range(batch_size)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(hidden1)[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "scatter_nd_116": {
                "variable": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "[[xla.replica_id()]]",
                    "type": "List",
                    "possible_values": []
                },
                "updates": {
                    "value": "[tensor]",
                    "type": "List",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num_replicas] + tensor.shape.as_list()",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cross_replica_sum_123": {
                "variable": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(indices=[[xla.replica_id()]], updates=[tensor], shape=[num_replicas] + tensor.shape.as_list())",
                            "Call"
                        ],
                        [
                            "tf.tpu.cross_replica_sum(ext_tensor)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_61": {
                "input": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_79": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_81": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_83": {
                "a": {
                    "value": "hidden1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden2_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(hidden2, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden2",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_84": {
                "a": {
                    "value": "hidden2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_87": {
                "values": {
                    "value": "[logits_ab, logits_aa]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_89": {
                "values": {
                    "value": "[logits_ba, logits_bb]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "name_scope_111": {
                "name": {
                    "value": "tpu_cross_replica_concat",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_128": {
                "tensor": {
                    "value": "ext_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(indices=[[xla.replica_id()]], updates=[tensor], shape=[num_replicas] + tensor.shape.as_list())",
                            "Call"
                        ],
                        [
                            "tf.tpu.cross_replica_sum(ext_tensor)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1] + ext_tensor.shape.as_list()[2:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_67": {
                "input": {
                    "value": "hidden1_large",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_cross_replica_concat(hidden1, tpu_context)",
                            "Call"
                        ],
                        [
                            "hidden1",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "model_simclr/resnet.py": {
        "tensorflow": {
            "meshgrid_186": {
                "variable": {
                    "value": "(w_i, h_i)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "*args": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "tf.range(width)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_187": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_193": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_194": {
                "variable": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1 if data_format == 'channels_last' else 0",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "cast_200": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_291": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(inputs, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_295": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.reduce_sum(inputs, axis=0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "pooling_axes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "conv2d_297": {
                "variable": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "mid_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max(int(filters * sk_ratio), min_dim)",
                            "Call"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "conv2d_303": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "global_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(tf.reduce_sum(inputs, axis=0), pooling_axes, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=mid_dim, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(global_features, is_training, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "2 * filters",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_307": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "tf.split(mixing, num_or_size_splits=2, axis=channel_axis)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_308": {
                "variable": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Conv2D_317": {
                "variable": {
                    "value": "se_reduce",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "max(1, int(filters * se_ratio))",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2D_325": {
                "variable": {
                    "value": "se_expand",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "inputs.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                },
                "use_bias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_mean_335": {
                "variable": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "spatial_dims",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[2, 3] if data_format == 'channels_first' else [1, 2]",
                            "IfExp"
                        ]
                    ]
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "zeros_initializer_107": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ones_initializer_109": {
                "variable": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "batch_normalization_127": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1",
                            "Constant"
                        ],
                        [
                            "-1",
                            "UnaryOp"
                        ]
                    ]
                },
                "momentum": {
                    "value": "FLAGS.batch_norm_decay",
                    "type": "Attribute",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "BATCH_NORM_EPSILON",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1e-05",
                            "Constant"
                        ]
                    ]
                },
                "center": {
                    "value": "center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "scale": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "training": {
                    "value": "is_training",
                    "type": "variable",
                    "possible_values": [
                        [
                            "True",
                            "MethodArgument"
                        ]
                    ]
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "gamma_initializer": {
                    "value": "gamma_initializer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros_initializer()",
                            "Call"
                        ],
                        [
                            "tf.ones_initializer()",
                            "Call"
                        ]
                    ]
                }
            },
            "relu_139": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "info_170": {
                "msg": {
                    "value": "'Applying DropBlock: dropblock_size {}, net.shape {}'.format(dropblock_size, net.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_min_203": {
                "variable": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2] if data_format == 'channels_last' else [2, 3]",
                    "type": "IfExp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "pad_243": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [0, 0], [pad_beg, pad_end], [pad_beg, pad_end]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "pad_246": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0], [pad_beg, pad_end], [pad_beg, pad_end], [0, 0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "conv2d_273": {
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filters",
                    "type": "variable",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "kernel_size",
                    "type": "variable",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "tf.variance_scaling_initializer()",
                    "type": "Call",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reduce_sum_310": {
                "input_tensor": {
                    "value": "inputs * mixing",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "relu_401": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_489": {
                "features": {
                    "value": "inputs + shortcut",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "identity_528": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "identity_674": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "final_avg_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "square_81": {
                "variable": {
                    "value": "mean_distance",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "group_mean - shard_mean",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "logical_and_188": {
                "x": {
                    "value": "w_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "w_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "logical_and_190": {
                "x": {
                    "value": "h_i >= int(dropblock_size // 2)",
                    "type": "Compare",
                    "possible_values": []
                },
                "y": {
                    "value": "h_i < width - (dropblock_size - 1) // 2",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "cast_216": {
                "x": {
                    "value": "tf.size(block_pattern)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_219": {
                "x": {
                    "value": "percent_ones",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.reduce_sum(block_pattern), tf.float32) / tf.cast(tf.size(block_pattern), tf.float32)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "net.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_291": {
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "reduce_sum_296": {
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_307": {
                "value": {
                    "value": "mixing",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.layers.conv2d(inputs=global_features, filters=2 * filters, kernel_size=1, strides=1, kernel_initializer=tf.variance_scaling_initializer(), use_bias=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(mixing, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(mixing, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "channel_axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 if data_format == 'channels_first' else 3",
                            "IfExp"
                        ]
                    ]
                }
            },
            "relu_337": {
                "features": {
                    "value": "se_reduce(se_tensor)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sigmoid_338": {
                "x": {
                    "value": "se_tensor",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(inputs, spatial_dims, keepdims=True)",
                            "Call"
                        ],
                        [
                            "se_expand(tf.nn.relu(se_reduce(se_tensor)))",
                            "Call"
                        ]
                    ]
                }
            },
            "average_pooling2d_374": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "average_pooling2d_440": {
                "variable": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "shortcut",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(shortcut, is_training, relu=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "dropblock(shortcut, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters_out, kernel_size=1, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "batch_norm_relu(shortcut, is_training, relu=False, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(shortcut, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=shortcut, filters=filters_out, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME if strides == 1 else VALID",
                    "type": "IfExp",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_571": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_573": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "identity_591": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_conv",
                    "type": "str",
                    "possible_values": []
                }
            },
            "max_pooling2d_594": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "pool_size": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                },
                "strides": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "data_format",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ],
                        [
                            "'channels_last'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "identity_597": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "initial_max_pool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "stop_gradient_624": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_635": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_646": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_657": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "stop_gradient_668": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_671": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_673": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bn_foo(inputs, training=is_training)",
                            "Call"
                        ],
                        [
                            "tf.layers.batch_normalization(inputs=inputs, axis=axis, momentum=FLAGS.batch_norm_decay, epsilon=BATCH_NORM_EPSILON, center=center, scale=scale, training=is_training, fused=True, gamma_initializer=gamma_initializer)",
                            "Call"
                        ],
                        [
                            "tf.nn.relu(inputs)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, kernel_size, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=2 * filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stack(tf.split(inputs, num_or_size_splits=2, axis=channel_axis))",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "fixed_padding(inputs, 2, data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.average_pooling2d(inputs, pool_size=2, strides=strides, padding='SAME' if strides == 1 else 'VALID', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "sk_conv2d(inputs, filters, strides, FLAGS.sk_ratio, is_training=is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=filters, kernel_size=3, strides=strides, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=4 * filters, kernel_size=1, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, relu=False, init_zero=True, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "dropblock(inputs, is_training=is_training, data_format=data_format, keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "se_layer(inputs, filters, FLAGS.se_ratio, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, strides, use_projection=True, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "block_fn(inputs, filters, is_training, 1, data_format=data_format, dropblock_keep_prob=dropblock_keep_prob, dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier // 2, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=3, strides=1, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "conv2d_fixed_padding(inputs=inputs, filters=64 * width_multiplier, kernel_size=7, strides=2, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=64 * width_multiplier, block_fn=block_fn, blocks=layers[0], strides=1, is_training=is_training, name='block_group1', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[0], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_conv')",
                            "Call"
                        ],
                        [
                            "batch_norm_relu(inputs, is_training, data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.layers.max_pooling2d(inputs=inputs, pool_size=3, strides=2, padding='SAME', data_format=data_format)",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'initial_max_pool')",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=128 * width_multiplier, block_fn=block_fn, blocks=layers[1], strides=2, is_training=is_training, name='block_group2', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[1], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=256 * width_multiplier, block_fn=block_fn, blocks=layers[2], strides=2, is_training=is_training, name='block_group3', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[2], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "block_group(inputs=inputs, filters=512 * width_multiplier, block_fn=block_fn, blocks=layers[3], strides=2, is_training=is_training, name='block_group4', data_format=data_format, dropblock_keep_prob=dropblock_keep_probs[3], dropblock_size=dropblock_size)",
                            "Call"
                        ],
                        [
                            "tf.stop_gradient(inputs)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [1, 2])",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(inputs, [2, 3])",
                            "Call"
                        ],
                        [
                            "tf.identity(inputs, 'final_avg_pool')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cross_replica_sum_65": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "cast_65": {
                "x": {
                    "value": "num_shards",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ],
                        [
                            "tpu_function.get_tpu_context().number_of_shards",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "t.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "max_pool_212": {
                "input": {
                    "value": "-block_pattern",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "ksize": {
                    "value": "ksize",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, dropblock_size, dropblock_size, 1]",
                            "List"
                        ],
                        [
                            "[1, 1, dropblock_size, dropblock_size]",
                            "List"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "SAME",
                    "type": "str",
                    "possible_values": []
                },
                "data_format": {
                    "value": "NHWC if data_format == channels_last else NCHW",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "reduce_sum_216": {
                "input_tensor": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "size_217": {
                "input": {
                    "value": "block_pattern",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1 - tf.cast(valid_block_center, dtype=tf.float32) + tf.cast(1 - seed_drop_rate, dtype=tf.float32) + randnoise >= 1",
                            "Compare"
                        ],
                        [
                            "tf.cast(block_pattern, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_min(block_pattern, axis=[1, 2] if data_format == 'channels_last' else [2, 3], keepdims=True)",
                            "Call"
                        ],
                        [
                            "-tf.nn.max_pool(-block_pattern, ksize=ksize, strides=[1, 1, 1, 1], padding='SAME', data_format='NHWC' if data_format == 'channels_last' else 'NCHW')",
                            "UnaryOp"
                        ]
                    ]
                }
            },
            "trainable_variables_602": {
                "variable": {
                    "value": "trainable_variables[after_block]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_198": {
                "x": {
                    "value": "valid_block_center",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.logical_and(w_i >= int(dropblock_size // 2), w_i < width - (dropblock_size - 1) // 2), tf.logical_and(h_i >= int(dropblock_size // 2), h_i < width - (dropblock_size - 1) // 2))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, 0)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(valid_block_center, -1 if data_format == 'channels_last' else 0)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_605": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "add_to_collection_619": {
                "name": {
                    "value": "collection",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prefix + str(after_block)",
                            "BinOp"
                        ]
                    ]
                },
                "value": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.trainable_variables()",
                            "Call"
                        ],
                        [
                            "variables",
                            "Name"
                        ]
                    ]
                }
            }
        }
    },
    "run.py": {
        "tensorflow": {
            "DEFINE_string_168": {
                "name": {
                    "value": "tpu_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The Cloud TPU to use for training. This should be either the name used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 url.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_174": {
                "name": {
                    "value": "tpu_zone",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] GCE zone where the Cloud TPU is located in. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_180": {
                "name": {
                    "value": "gcp_project",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] Project name for the Cloud TPU-enabled project. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_522": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode, experimental_host_call_every_n_steps=FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "FLAGS.keep_checkpoint_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "master": {
                    "value": "FLAGS.master",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cluster": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimator_536": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_lib.build_model_fn(model, num_classes, num_train_examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.tpu.RunConfig(tpu_config=tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode, experimental_host_call_every_n_steps=FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1), model_dir=FLAGS.model_dir, save_summary_steps=checkpoint_steps, save_checkpoints_steps=checkpoint_steps, keep_checkpoint_max=FLAGS.keep_checkpoint_max, master=FLAGS.master, cluster=cluster)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_353": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exists_381": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_572": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_383": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "listdir_392": {
                "path": {
                    "value": "hub_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'hub')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_424": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_428": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_431": {
                "name": {
                    "value": "flag_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'flags.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_513": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu_name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_516": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "checkpoints_iterator_544": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_355": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_360": {
                "variable": {
                    "value": "endpoints[v]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_398": {
                "path": {
                    "value": "os.path.join(hub_export_dir, str(step_to_delete))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_517": {
                "cluster_spec_or_resolver": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_518": {
                "enable_coordination_service": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUConfig_523": {
                "iterations_per_loop": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "eval_training_input_configuration": {
                    "value": "sliced_eval_mode if FLAGS.use_tpu else default_eval_mode",
                    "type": "IfExp",
                    "possible_values": []
                },
                "experimental_host_call_every_n_steps": {
                    "value": "FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "run_hmax.py": {
        "tensorflow": {
            "DEFINE_string_169": {
                "name": {
                    "value": "tpu_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The Cloud TPU to use for training. This should be either the name used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 url.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_175": {
                "name": {
                    "value": "tpu_zone",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] GCE zone where the Cloud TPU is located in. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_181": {
                "name": {
                    "value": "gcp_project",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] Project name for the Cloud TPU-enabled project. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_521": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode, experimental_host_call_every_n_steps=FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "FLAGS.keep_checkpoint_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "master": {
                    "value": "FLAGS.master",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cluster": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimator_535": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_lib.build_model_fn(model, num_classes, num_train_examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.tpu.RunConfig(tpu_config=tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode, experimental_host_call_every_n_steps=FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1), model_dir=FLAGS.model_dir, save_summary_steps=checkpoint_steps, save_checkpoints_steps=checkpoint_steps, keep_checkpoint_max=FLAGS.keep_checkpoint_max, master=FLAGS.master, cluster=cluster)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_354": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exists_382": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_571": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_384": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "listdir_393": {
                "path": {
                    "value": "hub_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'hub')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_425": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_429": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_432": {
                "name": {
                    "value": "flag_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'flags.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_512": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu_name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_515": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "checkpoints_iterator_543": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_356": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_361": {
                "variable": {
                    "value": "endpoints[v]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_399": {
                "path": {
                    "value": "os.path.join(hub_export_dir, str(step_to_delete))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_516": {
                "cluster_spec_or_resolver": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_517": {
                "enable_coordination_service": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUConfig_522": {
                "iterations_per_loop": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "eval_training_input_configuration": {
                    "value": "sliced_eval_mode if FLAGS.use_tpu else default_eval_mode",
                    "type": "IfExp",
                    "possible_values": []
                },
                "experimental_host_call_every_n_steps": {
                    "value": "FLAGS.train_summary_steps if FLAGS.train_summary_steps else 1",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "run_imagenet.py": {
        "tensorflow": {
            "DEFINE_string_171": {
                "name": {
                    "value": "tpu_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The Cloud TPU to use for training. This should be either the name used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 url.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_177": {
                "name": {
                    "value": "tpu_zone",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] GCE zone where the Cloud TPU is located in. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_183": {
                "name": {
                    "value": "gcp_project",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] Project name for the Cloud TPU-enabled project. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_514": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode)",
                    "type": "Call",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "FLAGS.keep_checkpoint_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "master": {
                    "value": "FLAGS.master",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cluster": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimator_525": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_lib.build_model_fn(model, num_classes, num_train_examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.tpu.RunConfig(tpu_config=tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode), model_dir=FLAGS.model_dir, save_summary_steps=checkpoint_steps, save_checkpoints_steps=checkpoint_steps, keep_checkpoint_max=FLAGS.keep_checkpoint_max, master=FLAGS.master, cluster=cluster)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_337": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exists_362": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_564": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_364": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "listdir_373": {
                "path": {
                    "value": "hub_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'hub')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_405": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_409": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_412": {
                "name": {
                    "value": "flag_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'flags.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_464": {
                "msg": {
                    "value": "Using fake dataset.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_466": {
                "msg": {
                    "value": "Using dataset: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.data_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_505": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu_name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_508": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "checkpoints_iterator_532": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_339": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_344": {
                "variable": {
                    "value": "endpoints[v]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_379": {
                "path": {
                    "value": "os.path.join(hub_export_dir, str(step_to_delete))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_509": {
                "cluster_spec_or_resolver": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_510": {
                "enable_coordination_service": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUConfig_515": {
                "iterations_per_loop": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "eval_training_input_configuration": {
                    "value": "sliced_eval_mode if FLAGS.use_tpu else default_eval_mode",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "run_old.py": {
        "tensorflow": {
            "DEFINE_string_151": {
                "name": {
                    "value": "tpu_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The Cloud TPU to use for training. This should be either the name used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 url.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_157": {
                "name": {
                    "value": "tpu_zone",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] GCE zone where the Cloud TPU is located in. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_163": {
                "name": {
                    "value": "gcp_project",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] Project name for the Cloud TPU-enabled project. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_399": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode)",
                    "type": "Call",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "FLAGS.keep_checkpoint_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "master": {
                    "value": "FLAGS.master",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cluster": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimator_410": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_lib.build_model_fn(model, num_classes, num_train_examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.tpu.RunConfig(tpu_config=tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode), model_dir=FLAGS.model_dir, save_summary_steps=checkpoint_steps, save_checkpoints_steps=checkpoint_steps, keep_checkpoint_max=FLAGS.keep_checkpoint_max, master=FLAGS.master, cluster=cluster)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_273": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exists_298": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_445": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_300": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "listdir_309": {
                "path": {
                    "value": "hub_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'hub')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_341": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_345": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_348": {
                "name": {
                    "value": "flag_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'flags.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_365": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_390": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu_name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_393": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "checkpoints_iterator_418": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_275": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_280": {
                "variable": {
                    "value": "endpoints[v]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_315": {
                "path": {
                    "value": "os.path.join(hub_export_dir, str(step_to_delete))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_394": {
                "cluster_spec_or_resolver": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_395": {
                "enable_coordination_service": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUConfig_400": {
                "iterations_per_loop": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "eval_training_input_configuration": {
                    "value": "sliced_eval_mode if FLAGS.use_tpu else default_eval_mode",
                    "type": "IfExp",
                    "possible_values": []
                }
            }
        }
    },
    "run_old_imagenet.py": {
        "tensorflow": {
            "DEFINE_string_160": {
                "name": {
                    "value": "tpu_name",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "The Cloud TPU to use for training. This should be either the name used when creating the Cloud TPU, or a grpc://ip.address.of.tpu:8470 url.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_166": {
                "name": {
                    "value": "tpu_zone",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] GCE zone where the Cloud TPU is located in. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "DEFINE_string_172": {
                "name": {
                    "value": "gcp_project",
                    "type": "str",
                    "possible_values": []
                },
                "default": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "help": {
                    "value": "[Optional] Project name for the Cloud TPU-enabled project. If not specified, we will attempt to automatically detect the GCE project from metadata.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "RunConfig_445": {
                "variable": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu_config": {
                    "value": "tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode)",
                    "type": "Call",
                    "possible_values": []
                },
                "model_dir": {
                    "value": "FLAGS.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_summary_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "save_checkpoints_steps": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "keep_checkpoint_max": {
                    "value": "FLAGS.keep_checkpoint_max",
                    "type": "Attribute",
                    "possible_values": []
                },
                "master": {
                    "value": "FLAGS.master",
                    "type": "Attribute",
                    "possible_values": []
                },
                "cluster": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUEstimator_456": {
                "variable": {
                    "value": "estimator",
                    "type": "variable",
                    "possible_values": []
                },
                "model_fn": {
                    "value": "model_lib.build_model_fn(model, num_classes, num_train_examples)",
                    "type": "Call",
                    "possible_values": []
                },
                "config": {
                    "value": "run_config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.estimator.tpu.RunConfig(tpu_config=tf.estimator.tpu.TPUConfig(iterations_per_loop=checkpoint_steps, eval_training_input_configuration=sliced_eval_mode if FLAGS.use_tpu else default_eval_mode), model_dir=FLAGS.model_dir, save_summary_steps=checkpoint_steps, save_checkpoints_steps=checkpoint_steps, keep_checkpoint_max=FLAGS.keep_checkpoint_max, master=FLAGS.master, cluster=cluster)",
                            "Call"
                        ]
                    ]
                },
                "train_batch_size": {
                    "value": "FLAGS.train_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "eval_batch_size": {
                    "value": "FLAGS.eval_batch_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_tpu": {
                    "value": "FLAGS.use_tpu",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "placeholder_284": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, None, None, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "exists_309": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "disable_v2_behavior_521": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_311": {
                "path": {
                    "value": "checkpoint_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(hub_export_dir, str(global_step))",
                            "Call"
                        ]
                    ]
                }
            },
            "listdir_320": {
                "path": {
                    "value": "hub_export_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'hub')",
                            "Call"
                        ]
                    ]
                }
            },
            "GFile_352": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_356": {
                "name": {
                    "value": "result_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'result.json')",
                            "Call"
                        ],
                        [
                            "os.path.join(FLAGS.model_dir, 'result_%d.json' % result['global_step'])",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "GFile_359": {
                "name": {
                    "value": "flag_json_path",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(FLAGS.model_dir, 'flags.json')",
                            "Call"
                        ]
                    ]
                },
                "mode": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_soft_device_placement_386": {
                "enabled": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "info_399": {
                "msg": {
                    "value": "Using fake dataset.",
                    "type": "str",
                    "possible_values": []
                }
            },
            "info_401": {
                "msg": {
                    "value": "Using dataset: %s",
                    "type": "str",
                    "possible_values": []
                },
                "*args": {
                    "value": "FLAGS.data_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_436": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "tpu": {
                    "value": "FLAGS.tpu_name",
                    "type": "Attribute",
                    "possible_values": []
                },
                "zone": {
                    "value": "FLAGS.tpu_zone",
                    "type": "Attribute",
                    "possible_values": []
                },
                "project": {
                    "value": "FLAGS.gcp_project",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TPUClusterResolver_439": {
                "variable": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_286": {
                "name_or_scope": {
                    "value": "base_model",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "tf.AUTO_REUSE",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_291": {
                "variable": {
                    "value": "endpoints[v]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "rmtree_326": {
                "path": {
                    "value": "os.path.join(hub_export_dir, str(step_to_delete))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "experimental_connect_to_cluster_440": {
                "cluster_spec_or_resolver": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "initialize_tpu_system_441": {
                "enable_coordination_service": {
                    "value": "cluster",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Constant"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver(FLAGS.tpu_name, zone=FLAGS.tpu_zone, project=FLAGS.gcp_project)",
                            "Call"
                        ],
                        [
                            "tf.distribute.cluster_resolver.TPUClusterResolver()",
                            "Call"
                        ]
                    ]
                }
            },
            "TPUConfig_446": {
                "iterations_per_loop": {
                    "value": "checkpoint_steps",
                    "type": "variable",
                    "possible_values": [
                        [
                            "FLAGS.checkpoint_steps or FLAGS.checkpoint_epochs * epoch_steps",
                            "BoolOp"
                        ]
                    ]
                },
                "eval_training_input_configuration": {
                    "value": "sliced_eval_mode if FLAGS.use_tpu else default_eval_mode",
                    "type": "IfExp",
                    "possible_values": []
                }
            },
            "checkpoints_iterator_494": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            },
            "checkpoints_iterator_467": {
                "checkpoint_dir": {
                    "value": "run_config.model_dir",
                    "type": "Attribute",
                    "possible_values": []
                },
                "min_interval_secs": {
                    "value": "15",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    }
}