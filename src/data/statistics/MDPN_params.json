{
    "BatchLoaders/DepthBatchLoader.py": {
        "tensorflow": {
            "create_file_writer_47": {
                "variable": {
                    "value": "self.depth_summary_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "depth_log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.logging_dir, 'depth')",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_113": {
                "value": {
                    "value": "batch[i].image",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_114": {
                "input": {
                    "value": "tf.convert_to_tensor(batch[i].depth, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_116": {
                "value": {
                    "value": "batch[i].mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_114": {
                "value": {
                    "value": "batch[i].depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_70": {
                "initial_value": {
                    "value": "np.zeros(self.shape_size, dtype=np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_75": {
                "initial_value": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "BatchLoaders/SFMBatchLoader2.py": {
        "tensorflow": {
            "create_file_writer_52": {
                "variable": {
                    "value": "self.sfm_summary_writer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logdir": {
                    "value": "sfm_log_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(self.logging_dir, 'sfm')",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_125": {
                "value": {
                    "value": "image.getImage()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_129": {
                "value": {
                    "value": "T1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.getTransformations()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_130": {
                "value": {
                    "value": "Tinv1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.getTransformations()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_72": {
                "initial_value": {
                    "value": "np.zeros(self.shape_size, dtype=np.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_77": {
                "initial_value": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "BatchLoaders/Sfm_loader_thread.py": {
        "tensorflow": {}
    },
    "Converters/KeyFrame.py": {
        "tensorflow": {
            "stack_50": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.tf_image_i, tf_image_j]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_51": {
                "variable": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.tf_image_depth_i, tf_image_depth_j]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_52": {
                "variable": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.T_i, T_j]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_53": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.Tinv_i, Tinv_j]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "stack_54": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[self.calib_i, calib_j]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_56": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([self.tf_image_depth_i, tf_image_depth_j])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_61": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([self.tf_image_depth_i, tf_image_depth_j])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_65": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.unproject(D_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(X[:, :, 0:3], shape=[shape[0], shape[1], shape[2], 3])",
                            "Call"
                        ],
                        [
                            "g.unproject(tf.expand_dims(self.tf_image_depth_i, axis=0), tf.expand_dims(self.Tinv_i, axis=0))",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_67": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X[:, :, 0:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[shape[0], shape[1], shape[2], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_73": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_overlap(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_75": {
                "variable": {
                    "value": "overlap_ji",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask[0, 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_76": {
                "variable": {
                    "value": "overlap_ij",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask[1, 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "convert_to_tensor_82": {
                "variable": {
                    "value": "tf_image",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image.getImage()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_84": {
                "variable": {
                    "value": "tf_image_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image.getDepth()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_87": {
                "variable": {
                    "value": "tf_image_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf_image_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(image.getDepth(), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf_image_depth, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_91": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.getTransformations()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(T, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_92": {
                "variable": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image.getTransformations()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(Tinv, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_94": {
                "variable": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image.getCalibVec()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_97": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.transpose(image.getCameraCenter())",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_104": {
                "input": {
                    "value": "self.tf_image_depth_i",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_105": {
                "input": {
                    "value": "self.Tinv_i",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "Converters/VoxelMap.py": {
        "tensorflow": {
            "constant_29": {
                "variable": {
                    "value": "self.cell_width",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_30": {
                "variable": {
                    "value": "self.primes",
                    "type": "Attribute",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.constant([3259, 1487, 1093], dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_40": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "voxel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.voxelize2(X, self.cell_width, self.primes)",
                            "Call"
                        ],
                        [
                            "g.voxelize2(X, self.cell_width, self.primes)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_64": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "voxel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.voxelize2(X, self.cell_width, self.primes)",
                            "Call"
                        ],
                        [
                            "g.voxelize2(X, self.cell_width, self.primes)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_30": {
                "value": {
                    "value": "[3259, 1487, 1093]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Converters/convert_rgbd_to_sfm.py": {
        "tensorflow": {
            "list_physical_devices_447": {
                "variable": {
                    "value": "gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "convert_to_tensor_97": {
                "variable": {
                    "value": "tf_image_i",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image_i.getImage()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_99": {
                "variable": {
                    "value": "tf_image_depth_i",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image_i.getDepth()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_102": {
                "variable": {
                    "value": "tf_image_depth_i",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf_image_depth_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(image_i.getDepth(), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(tf_image_depth_i, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_106": {
                "variable": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "T_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_i.getTransformations()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(T_i, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_107": {
                "variable": {
                    "value": "Tinv_i",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "Tinv_i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "image_i.getTransformations()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(Tinv_i, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_109": {
                "variable": {
                    "value": "calib_i",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "image_i.getCalibVec()",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_129": {
                "variable": {
                    "value": "angle",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.cos(80.0 * np.pi / 180.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "set_memory_growth_452": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpus",
                            "variable"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "Converters/rgbd_converter.py": {
        "tensorflow": {}
    },
    "Converters/sub_sample_sfm.py": {
        "tensorflow": {}
    },
    "Converters/subsample_depth.py": {
        "tensorflow": {}
    },
    "Graphics/Graphics3.py": {
        "tensorflow": {
            "shape_37": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(I_vec, shape=[shape[0], shape[1], h, w, shape[-1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(I, shape=[shape[0], shape[1] * shape[2], 3])",
                            "Call"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "meshgrid_41": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "*args": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[2])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe, coeffs[0:1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(T, X)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(x, d)",
                            "Call"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[1])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe - x * coeffs[0:1], coeffs[1:2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, shape=[shape[0], shape[1] * shape[2], shape[3]])",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_43": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.cast(tf.expand_dims(grid[0], 2), dtype=tf.float32), tf.cast(tf.expand_dims(grid[1], 2), dtype=tf.float32), tf.ones([shape[1], shape[2], 1], dtype=tf.float32)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_48": {
                "variable": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "grid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.meshgrid(x, y)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.cast(tf.expand_dims(grid[0], 2), dtype=tf.float32), tf.cast(tf.expand_dims(grid[1], 2), dtype=tf.float32), tf.ones([shape[1], shape[2], 1], dtype=tf.float32)], 2)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(grid, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "function_34": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "split_55": {
                "variable": {
                    "value": "(fx, fy, x0, y0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_57": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfa.image.gaussian_filter2d(D)",
                            "Call"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_61": {
                "variable": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(x0, y0, tf.zeros_like(x0))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_64": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_68": {
                "variable": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(fx, fy, tf.ones_like(x0))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_70": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_72": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "function_52": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "normalize_87": {
                "variable": {
                    "value": "(d1, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C1 - X",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.normalize(d1, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "normalize_88": {
                "variable": {
                    "value": "(d2, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "C2 - X",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.normalize(d2, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "is_nan_92": {
                "variable": {
                    "value": "mask_nan",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "cos_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(tf.reduce_sum(d1 * d2, axis=-1)) * 180.0 / 3.14",
                            "BinOp"
                        ]
                    ]
                }
            },
            "logical_and_94": {
                "variable": {
                    "value": "maks",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.squeeze(mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.logical_not(mask_nan)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "boolean_mask_96": {
                "variable": {
                    "value": "masked_angles",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "cos_angle",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.acos(tf.reduce_sum(d1 * d2, axis=-1)) * 180.0 / 3.14",
                            "BinOp"
                        ]
                    ]
                },
                "mask": {
                    "value": "maks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.squeeze(mask), tf.logical_not(mask_nan))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_98": {
                "variable": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "masked_angles",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.boolean_mask(cos_angle, maks)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_105": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floordiv_107": {
                "variable": {
                    "value": "X2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "X[:, :, 0:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "width",
                            "Method Argument"
                        ],
                        [
                            "width",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_109": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2 * primes",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_102": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_116": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_118": {
                "variable": {
                    "value": "X2",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.floordiv(X[:, :, 0:3], width)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_min_120": {
                "variable": {
                    "value": "min_val_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 0:1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_121": {
                "variable": {
                    "value": "min_val_y",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 1:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_min_122": {
                "variable": {
                    "value": "min_val_z",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 2:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_124": {
                "variable": {
                    "value": "max_val_x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 0:1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_125": {
                "variable": {
                    "value": "max_val_y",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 1:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_126": {
                "variable": {
                    "value": "max_val_z",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2[:, :, 2:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_128": {
                "variable": {
                    "value": "min_point",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(min_val_x, min_val_y, min_val_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_132": {
                "variable": {
                    "value": "max_point",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(max_val_x, max_val_y, max_val_z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_136": {
                "variable": {
                    "value": "min_point",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "min_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((min_val_x, min_val_y, min_val_z), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(min_point, shape=[1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_137": {
                "variable": {
                    "value": "max_point",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "max_point",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((max_val_x, max_val_y, max_val_z), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(max_point, shape=[1, 1, 3])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_143": {
                "variable": {
                    "value": "coeffs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(coeffs[:, :, 1:2] * coeffs[:, :, 2:3], coeffs[:, :, 2:3], tf.ones_like(coeffs[:, :, 0:1]))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_147": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2_n * coeffs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_148": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(X2 * primes, axis=-1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(X2_n * coeffs, axis=-1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(index)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(X2_n_u * primes, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_149": {
                "variable": {
                    "value": "coeffs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "coeffs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "max_point - min_point + 1",
                            "BinOp"
                        ],
                        [
                            "tf.concat((coeffs[:, :, 1:2] * coeffs[:, :, 2:3], coeffs[:, :, 2:3], tf.ones_like(coeffs[:, :, 0:1])), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(coeffs)",
                            "Call"
                        ]
                    ]
                }
            },
            "unique_152": {
                "variable": {
                    "value": "(index_uniqe, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(X2 * primes, axis=-1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(X2_n * coeffs, axis=-1, keepdims=True)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(index)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(X2_n_u * primes, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "floordiv_156": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "index_uniqe",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.unique(index)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "coeffs[0:1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "floordiv_157": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "index_uniqe - x * coeffs[0:1]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "coeffs[1:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_160": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[2])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe, coeffs[0:1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(T, X)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(x, d)",
                            "Call"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_161": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[1])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe - x * coeffs[0:1], coeffs[1:2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, shape=[shape[0], shape[1] * shape[2], shape[3]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_162": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "index_uniqe - x * coeffs[0:1] - y * coeffs[1:2]",
                            "BinOp"
                        ],
                        [
                            "tf.expand_dims(z, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_167": {
                "variable": {
                    "value": "primes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "primes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(primes, dtype=tf.int32)",
                            "Call"
                        ],
                        [
                            "primes",
                            "Method Argument"
                        ],
                        [
                            "primes",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_169": {
                "variable": {
                    "value": "index",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "X2_n_u * primes",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_185": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfa.image.gaussian_filter2d(D)",
                            "Call"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_189": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(X, tf.ones(shape))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_191": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_193": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_195": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "function_182": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_202": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "N",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floordiv(el, 3)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "self.unprojectNormals(N, P)",
                            "Call"
                        ],
                        [
                            "N",
                            "Method Argument"
                        ],
                        [
                            "N",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_204": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(N, tf.zeros((shape[0], shape[1], shape[2], 1)))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_207": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_209": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_211": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.linalg.matrix_transpose(P)",
                    "type": "Call",
                    "possible_values": []
                },
                "b": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_213": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "normalize_215": {
                "variable": {
                    "value": "(X, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X[:, :, 0:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "function_199": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_222": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_224": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_225": {
                "variable": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(T, axis=1)",
                            "Call"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_233": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(T, axis=1)",
                            "Call"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "divide_no_nan_237": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[2])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe, coeffs[0:1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(T, X)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(x, d)",
                            "Call"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 2:3, :]",
                            "Subscript"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "function_219": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "transpose_244": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[2])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe, coeffs[0:1])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(x, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.matmul(T, X)",
                            "Call"
                        ],
                        [
                            "tf.math.divide_no_nan(x, d)",
                            "Call"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_246": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[1])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe - x * coeffs[0:1], coeffs[1:2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, shape=[shape[0], shape[1] * shape[2], shape[3]])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_247": {
                "variable": {
                    "value": "shape_I",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(I_vec, shape=[shape[0], shape[1], h, w, shape[-1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(I, shape=[shape[0], shape[1] * shape[2], 3])",
                            "Call"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_249": {
                "variable": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "y",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(0, shape[1])",
                            "Call"
                        ],
                        [
                            "tf.math.floordiv(index_uniqe - x * coeffs[0:1], coeffs[1:2])",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(y, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "tf.reshape(y, shape=[shape[0], shape[1] * shape[2], shape[3]])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_253": {
                "variable": {
                    "value": "I_int",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I_int",
                    "type": "variable",
                    "possible_values": [
                        [
                            "interpolate_bilinear(I, y, indexing='xy')",
                            "Call"
                        ],
                        [
                            "tf.reshape(I_int, shape=[shape[0], shape[1], shape[2], shape_I[-1]])",
                            "Call"
                        ],
                        [
                            "self.interpolate(I, x)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], shape[2], shape_I[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_241": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_260": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I_vec",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_262": {
                "variable": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I_vec",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], h, w, shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_258": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_269": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(w, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "shape[2]",
                            "Subscript"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_270": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(h, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "shape[1]",
                            "Subscript"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "greater_272": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 2:3, :]",
                            "Subscript"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "logical_and_277": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.greater(xx, -1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_278": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.greater(yy, -1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_280": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.less(xx, w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_and_281": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.less(yy, h)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "function_266": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_285": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "split_295": {
                "variable": {
                    "value": "(fx, fy, x0, y0)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_299": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfa.image.gaussian_filter2d(D)",
                            "Call"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_303": {
                "variable": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(x0, y0, tf.zeros_like(x0))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_306": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_310": {
                "variable": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(fx, fy, tf.ones_like(x0))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_312": {
                "variable": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "CC",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((x0, y0, tf.zeros_like(x0)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat((fx, fy, tf.ones_like(x0)), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_314": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "C",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ],
                        [
                            "tf.reshape(CC, [shape[0], 1, 1, 3])",
                            "Call"
                        ]
                    ]
                }
            },
            "normalize_325": {
                "variable": {
                    "value": "(n, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D * tf.concat((-dx, -dy, X[:, :, :, 0:1] * dx + X[:, :, :, 1:2] * dy + D), axis=-1)",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.normalize(n, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "normalize_326": {
                "variable": {
                    "value": "(X, _)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D) * D",
                            "BinOp"
                        ],
                        [
                            "tf.concat((X, tf.ones(shape)), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(Tinv, X)",
                            "Call"
                        ],
                        [
                            "tf.concat((N, tf.zeros((shape[0], shape[1], shape[2], 1))), axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(X, shape=[shape[0], shape[1] * shape[2], 4])",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.matmul(tf.linalg.matrix_transpose(P), X)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X, perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X[:, :, 0:3], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(X, axis=0)",
                            "Call"
                        ],
                        [
                            "self.generate_homogeneous_points(D)",
                            "Call"
                        ],
                        [
                            "X - C",
                            "BinOp"
                        ],
                        [
                            "tf.math.divide(X, C)",
                            "Call"
                        ],
                        [
                            "tf.linalg.normalize(X, axis=-1)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "self.unproject(D, Tinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(X[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ],
                        [
                            "X",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_328": {
                "variable": {
                    "value": "prod",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "n * X",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_292": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_335": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(I_vec, shape=[shape[0], shape[1], h, w, shape[-1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(I, shape=[shape[0], shape[1] * shape[2], 3])",
                            "Call"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_350": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_365": {
                "variable": {
                    "value": "d_projected_warp",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 2:3, :]",
                            "Subscript"
                        ],
                        [
                            "self.project(X, T)",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_332": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "diag_374": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "diagonal": {
                    "value": "tf.ones((1, N), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "function_371": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_382": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(alpha_batch, shape=[shape[0], 1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_384": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(alpha_batch, shape=[shape[0], 1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "divide_no_nan_386": {
                "variable": {
                    "value": "relative_error",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "deph_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D_warp - d_projected_warp",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(alpha_batch, shape=[shape[0], 1, 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "function_378": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_393": {
                "variable": {
                    "value": "relative_error",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "relative_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.divide_no_nan(deph_error, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_error, np.inf * tf.ones_like(relative_error))",
                            "Call"
                        ],
                        [
                            "relative_error",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "np.inf * tf.ones_like(relative_error)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_398": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "median_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_mad(relative_error, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(median_error, shape=[shape[0], shape[1], 1, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_400": {
                "variable": {
                    "value": "median_error",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "median_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_mad(relative_error, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(median_error, shape=[shape[0], shape[1], 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_407": {
                "variable": {
                    "value": "median_variance",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "median_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_mad(tf.square(e_rel), mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(median_variance, shape=[shape[0], shape[1], 1, 1, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_410": {
                "variable": {
                    "value": "mask_g",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "e_rel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "relative_error - median_error",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "-4.44 * tf.sqrt(median_variance)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "function_390": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_417": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_418": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "[2, 3, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_420": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_422": {
                "variable": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], shape[2] * shape[3] * shape[4]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_426": {
                "variable": {
                    "value": "mid",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "el - tf.math.floordiv(mask_count, 2) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_430": {
                "variable": {
                    "value": "values_median",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(V, el).values",
                            "Attribute"
                        ],
                        [
                            "tf.nn.top_k(rinput, N).values",
                            "Attribute"
                        ]
                    ]
                },
                "indices": {
                    "value": "mid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(el - tf.math.floordiv(mask_count, 2) - 1, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(N - tf.math.floordiv(mask_count, 2) - 1, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "batch_dims": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "function_414": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_437": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_439": {
                "variable": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1], shape[2] * shape[3] * shape[4]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floordiv_443": {
                "variable": {
                    "value": "N",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "el",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[2] * shape[3] * shape[4]",
                            "BinOp"
                        ],
                        [
                            "shape[2] * shape[3] * shape[4]",
                            "BinOp"
                        ]
                    ]
                },
                "y": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_447": {
                "variable": {
                    "value": "rinput",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                },
                "indices": {
                    "value": "ridxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random.shuffle(idxs)[:N]",
                            "Subscript"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "is_finite_449": {
                "variable": {
                    "value": "no_nan_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "rinput",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(V, ridxs, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_451": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "no_nan_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.is_finite(rinput)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_452": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_454": {
                "variable": {
                    "value": "mid",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "N - tf.math.floordiv(mask_count, 2) - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_458": {
                "variable": {
                    "value": "values_median",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.top_k(V, el).values",
                            "Attribute"
                        ],
                        [
                            "tf.nn.top_k(rinput, N).values",
                            "Attribute"
                        ]
                    ]
                },
                "indices": {
                    "value": "mid",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(el - tf.math.floordiv(mask_count, 2) - 1, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(N - tf.math.floordiv(mask_count, 2) - 1, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "batch_dims": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "function_434": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_465": {
                "variable": {
                    "value": "mask_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.greater(D, 0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_469": {
                "variable": {
                    "value": "mask_normal",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_normal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask_normal, axis=0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_471": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(tf.greater(D, 0.0), axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_472": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_normal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(mask_normal, axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "function_462": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_481": {
                "variable": {
                    "value": "abs_error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(error)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "minimum_482": {
                "variable": {
                    "value": "quadratic",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "abs_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.math.abs(error), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "delta",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "subtract_483": {
                "variable": {
                    "value": "linear",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "abs_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.math.abs(error), axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "quadratic",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(abs_error, delta)",
                            "Call"
                        ]
                    ]
                }
            },
            "function_476": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "concat_495": {
                "variable": {
                    "value": "dy",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dy, dy[:, -1:, :, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_497": {
                "variable": {
                    "value": "dx",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[dx, dx[:, :, -1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_514": {
                "variable": {
                    "value": "shape_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_and_519": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_523": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(e_rel, -4.44 * tf.sqrt(median_variance))",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_525": {
                "variable": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(relative_depth_error)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_528": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_529": {
                "variable": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_or_540": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.logical_not(mask_I)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_542": {
                "variable": {
                    "value": "I_warp",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "I_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transform_to_image(I_int, w, h)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, I_warp, tf.zeros_like(I_warp))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(I_warp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "function_501": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_560": {
                "variable": {
                    "value": "shape_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_and_565": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_569": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(e_rel, -4.44 * tf.sqrt(median_variance))",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "function_547": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_588": {
                "variable": {
                    "value": "shape_d",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_and_593": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_597": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(e_rel, -4.44 * tf.sqrt(median_variance))",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ],
                        [
                            "self.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "function_573": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "where_611": {
                "variable": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(error_image)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_614": {
                "variable": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "x": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(relative_depth_error)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "function_601": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_638": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_642": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_646": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_652": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfa.image.gaussian_filter2d(D)",
                            "Call"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "transpose_656": {
                "variable": {
                    "value": "X",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X[:, 0:3, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_660": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_665": {
                "variable": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(I_vec, shape=[shape[0], shape[1], h, w, shape[-1]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(I, shape=[shape[0], shape[1] * shape[2], 3])",
                            "Call"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_111": {
                "x": {
                    "value": "tf.concat((X2, index), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_180": {
                "x": {
                    "value": "tf.concat((X2_n_u, index), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_376": {
                "tensor": {
                    "value": "tf.less(mask, 1.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[N, N, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_484": {
                "x": {
                    "value": "tf.math.multiply(tf.convert_to_tensor(0.5, dtype=quadratic.dtype), tf.math.multiply(quadratic, quadratic))",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.multiply(delta, linear)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_640": {
                "input_tensor": {
                    "value": "0.5 * (tf.square(x - mu) * tf.math.exp(-logvar) + logvar) + tf.math.log(2 * np.pi)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_663": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_671": {
                "variable": {
                    "value": "X_i",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "X[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "boolean_mask_672": {
                "variable": {
                    "value": "I_i",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "boolean_mask_673": {
                "variable": {
                    "value": "N_i",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "N[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "range_39": {},
            "squeeze_94": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_not_94": {
                "x": {
                    "value": "mask_nan",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.is_nan(cos_angle)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_111": {
                "values": {
                    "value": "(X2, index)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "floordiv_118": {
                "x": {
                    "value": "X[:, :, 0:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "y": {
                    "value": "width",
                    "type": "variable",
                    "possible_values": [
                        [
                            "width",
                            "Method Argument"
                        ],
                        [
                            "width",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_164": {
                "tensor": {
                    "value": "tf.concat((x, y, z), axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, -1, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_180": {
                "values": {
                    "value": "(X2_n_u, index)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "matrix_transpose_211": {
                "a": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P",
                            "Method Argument"
                        ],
                        [
                            "P",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "greater_277": {
                "x": {
                    "value": "xx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 0:1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_278": {
                "x": {
                    "value": "yy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 1:2, :]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "less_280": {
                "x": {
                    "value": "xx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 0:1, :]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(w, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "shape[2]",
                            "Subscript"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ],
                        [
                            "w",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "less_281": {
                "x": {
                    "value": "yy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x[:, :, 1:2, :]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(h, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "shape[1]",
                            "Subscript"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ],
                        [
                            "h",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_288": {
                "input": {
                    "value": "Ir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Ir",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_318": {
                "tensor": {
                    "value": "fx",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_320": {
                "tensor": {
                    "value": "fy",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_322": {
                "values": {
                    "value": "(-dx, -dy, X[:, :, :, 0:1] * dx + X[:, :, :, 1:2] * dy + D)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "greater_330": {
                "x": {
                    "value": "prod",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(n * X, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "cos_theta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cos_theta",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_374": {
                "shape": {
                    "value": "(1, N)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "less_376": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater(d, 0.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(xx, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.greater(yy, -1.0))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(xx, w))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, tf.less(yy, h))",
                            "Call"
                        ],
                        [
                            "self.mask_projections(x, d, w, h)",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[0, 1, 3, 2])",
                            "Call"
                        ],
                        [
                            "self.transform_to_image(mask, w, h)",
                            "Call"
                        ],
                        [
                            "tf.linalg.diag(tf.ones((1, N), dtype=tf.float32))",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_d)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_normal)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "tf.logical_or(mask, tf.logical_not(mask_I))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, shape=[shape[0], shape[1] * shape[2]])",
                            "Call"
                        ],
                        [
                            "tf.ones_like(mask)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "square_405": {
                "x": {
                    "value": "e_rel",
                    "type": "variable",
                    "possible_values": [
                        [
                            "relative_error - median_error",
                            "BinOp"
                        ]
                    ]
                }
            },
            "top_k_428": {
                "input": {
                    "value": "V",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "tf.reshape(V, [shape[0], shape[1], shape[2] * shape[3] * shape[4]])",
                            "Call"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ],
                        [
                            "V",
                            "Method Argument"
                        ]
                    ]
                },
                "k": {
                    "value": "el",
                    "type": "variable",
                    "possible_values": [
                        [
                            "shape[2] * shape[3] * shape[4]",
                            "BinOp"
                        ],
                        [
                            "shape[2] * shape[3] * shape[4]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "shuffle_446": {
                "value": {
                    "value": "idxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.range(el)",
                            "Call"
                        ]
                    ]
                }
            },
            "top_k_456": {
                "input": {
                    "value": "rinput",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(V, ridxs, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "k": {
                    "value": "N",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floordiv(el, 3)",
                            "Call"
                        ],
                        [
                            "self.mask_normals(D, calib, angle)",
                            "Call"
                        ],
                        [
                            "self.unprojectNormals(N, P)",
                            "Call"
                        ],
                        [
                            "N",
                            "Method Argument"
                        ],
                        [
                            "N",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "greater_465": {
                "x": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfa.image.gaussian_filter2d(D)",
                            "Call"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "abs_481": {
                "x": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "error",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "multiply_485": {
                "x": {
                    "value": "tf.convert_to_tensor(0.5, dtype=quadratic.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.math.multiply(quadratic, quadratic)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "multiply_488": {
                "x": {
                    "value": "delta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "delta",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "linear",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.subtract(abs_error, quadratic)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_526": {
                "input": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_537": {
                "input_tensor": {
                    "value": "self.Huber(relative_depth_error, 0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "logical_not_540": {
                "x": {
                    "value": "mask_I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ],
                        [
                            "self.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_543": {
                "input": {
                    "value": "I_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.transform_to_image(I_int, w, h)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, I_warp, tf.zeros_like(I_warp))",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "self.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_612": {
                "input": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_615": {
                "input": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_relative_depth_error(D_warp, d_projected_warp, alpha_batch)",
                            "Call"
                        ],
                        [
                            "self.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_628": {
                "input_tensor": {
                    "value": "self.Huber(error_image, 0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_631": {
                "input_tensor": {
                    "value": "self.Huber(relative_depth_error, 0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_644": {
                "x": {
                    "value": "2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_648": {
                "input_tensor": {
                    "value": "tf.math.exp(logvar) + tf.square(mu) - 1.0 - logvar",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_44": {
                "x": {
                    "value": "tf.expand_dims(grid[0], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_45": {
                "x": {
                    "value": "tf.expand_dims(grid[1], 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_46": {
                "shape": {
                    "value": "[shape[1], shape[2], 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_like_61": {
                "input": {
                    "value": "x0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_68": {
                "input": {
                    "value": "x0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "acos_90": {
                "x": {
                    "value": "tf.reduce_sum(d1 * d2, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_like_145": {
                "input": {
                    "value": "coeffs[:, :, 0:1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_164": {
                "values": {
                    "value": "(x, y, z)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_189": {
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(I)",
                            "Call"
                        ],
                        [
                            "tf.shape(D)",
                            "Call"
                        ],
                        [
                            "tf.shape(D)",
                            "Call"
                        ],
                        [
                            "tf.shape(N)",
                            "Call"
                        ],
                        [
                            "tf.shape(X)",
                            "Call"
                        ],
                        [
                            "tf.shape(y)",
                            "Call"
                        ],
                        [
                            "tf.shape(I_vec)",
                            "Call"
                        ],
                        [
                            "tf.shape(D)",
                            "Call"
                        ],
                        [
                            "tf.shape(I)",
                            "Call"
                        ],
                        [
                            "tf.shape(alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.shape(median_error)",
                            "Call"
                        ],
                        [
                            "tf.shape(V)",
                            "Call"
                        ],
                        [
                            "tf.shape(V)",
                            "Call"
                        ],
                        [
                            "tf.shape(D)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_205": {
                "shape": {
                    "value": "(shape[0], shape[1], shape[2], 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_like_303": {
                "input": {
                    "value": "x0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_310": {
                "input": {
                    "value": "x0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.split(calib, 4, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_394": {
                "input": {
                    "value": "relative_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.divide_no_nan(deph_error, alpha_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_error, np.inf * tf.ones_like(relative_error))",
                            "Call"
                        ],
                        [
                            "relative_error",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "sqrt_410": {
                "x": {
                    "value": "median_variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_mad(tf.square(e_rel), mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(median_variance, shape=[shape[0], shape[1], 1, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_486": {
                "value": {
                    "value": "0.5",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "quadratic.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_487": {
                "x": {
                    "value": "quadratic",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(abs_error, delta)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "quadratic",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.minimum(abs_error, delta)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_640": {
                "x": {
                    "value": "2 * np.pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_44": {
                "input": {
                    "value": "grid[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_45": {
                "input": {
                    "value": "grid[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_90": {
                "input_tensor": {
                    "value": "d1 * d2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "floordiv_426": {
                "x": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "floordiv_454": {
                "x": {
                    "value": "mask_count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask_count, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=[2, 3, 4])",
                            "Call"
                        ],
                        [
                            "tf.cast(no_nan_mask, tf.int32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(mask_count)",
                            "Call"
                        ],
                        [
                            "mask_count",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "square_644": {
                "x": {
                    "value": "x - mu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_644": {
                "x": {
                    "value": "-logvar",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "square_640": {
                "x": {
                    "value": "x - mu",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "exp_640": {
                "x": {
                    "value": "-logvar",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "exp_648": {
                "x": {
                    "value": "logvar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logvar",
                            "Method Argument"
                        ],
                        [
                            "logvar",
                            "Method Argument"
                        ],
                        [
                            "logvar",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_648": {
                "x": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mu",
                            "Method Argument"
                        ],
                        [
                            "mu",
                            "Method Argument"
                        ],
                        [
                            "mu",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "Networks/ShapeNetwork.py": {
        "tensorflow": {
            "Input_52": {
                "variable": {
                    "value": "input_img",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(config['dataset']['image_height'], config['dataset']['image_width'], 6)",
                            "Tuple"
                        ],
                        [
                            "tf.shape(P)",
                            "Call"
                        ],
                        [
                            "tf.shape(out[0])",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "image_input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_94": {
                "variable": {
                    "value": "input_z",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape_size,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "latent_varaible",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_101": {
                "variable": {
                    "value": "input_decode_1",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0] // 16, shape[1] // 16, 64)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "decode_input_1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_109": {
                "variable": {
                    "value": "input_decode_2",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0] // 8, shape[1] // 8, 32)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "decode_input_2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_126": {
                "variable": {
                    "value": "input_decode_3",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0] // 4, shape[1] // 4, 32)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "decode_input_3",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_143": {
                "variable": {
                    "value": "input_decode_4",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0] // 2, shape[1] // 2, 16)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "decode_input_4",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_160": {
                "variable": {
                    "value": "input_decode_5",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0], shape[1], 8)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "decode_input_5",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Model_174": {
                "variable": {
                    "value": "self.encode_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "input_img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Input(shape, name='image_input')",
                            "Call"
                        ]
                    ]
                },
                "outputs": {
                    "value": "[x1, x2, x3, x4, x5_cnn]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Model_177": {
                "variable": {
                    "value": "self.decode_model",
                    "type": "Attribute",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[input_decode_5, input_decode_4, input_decode_3, input_decode_2, input_decode_1, input_z]",
                    "type": "List",
                    "possible_values": []
                },
                "outputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Reshape((z_dim[0], z_dim[1], layer_depth))(input_z)",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Concatenate(axis=-1)([x, input_decode_1])",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose(32, (5, 5), strides=(2, 2), padding='same', use_bias=False)(x)",
                            "Call"
                        ],
                        [
                            "Concatenate(axis=-1)([input_decode_2, x])",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose(32, (5, 5), strides=(2, 2), padding='same', use_bias=False)(x)",
                            "Call"
                        ],
                        [
                            "Concatenate(axis=-1)([input_decode_3, x])",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(32, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose(32, (5, 5), strides=(2, 2), padding='same', use_bias=False)(x)",
                            "Call"
                        ],
                        [
                            "Concatenate(axis=-1)([input_decode_4, x])",
                            "Call"
                        ],
                        [
                            "Conv2D(16, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(16, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(16, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2DTranspose(16, (5, 5), strides=(2, 2), padding='same', use_bias=False)(x)",
                            "Call"
                        ],
                        [
                            "Concatenate(axis=-1)([input_decode_5, x])",
                            "Call"
                        ],
                        [
                            "Conv2D(8, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(8, (3, 3), activation=LeakyReLU(alpha=alpha), padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "Conv2D(1, (3, 3), activation='tanh', padding='same', kernel_regularizer=self.regularization, bias_regularizer=self.regularization)(x)",
                            "Call"
                        ],
                        [
                            "x",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_185": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_187": {
                "variable": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(A, shape=[shape[0], 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "A",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "normal_193": {
                "variable": {
                    "value": "eps",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "mu.shape",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_191": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_196": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_210": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "out[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_212": {
                "variable": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0], self.shape_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_214": {
                "variable": {
                    "value": "logvar",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(shape[0], self.shape_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "function_203": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "function_218": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_n_238": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "self.decode_model.losses",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "function_236": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "divide_no_nan_189": {
                "x": {
                    "value": "A * (tf.ones_like(P) - P)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "add_n_239": {
                "inputs": {
                    "value": "self.encode_model.losses",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_54": {
                "filters": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_56": {
                "filters": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_59": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_62": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_64": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_67": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_70": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_73": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_76": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_79": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_82": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_85": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_88": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_91": {
                "filters": {
                    "value": "64",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Reshape_96": {
                "target_shape": {
                    "value": "(z_dim[0], z_dim[1], layer_depth)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "Conv2D_98": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Concatenate_104": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_106": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Concatenate_112": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Conv2D_114": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_117": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_120": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_123": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Concatenate_129": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Conv2D_131": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_134": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_137": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_140": {
                "filters": {
                    "value": "32",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Concatenate_146": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Conv2D_148": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_151": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_154": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_157": {
                "filters": {
                    "value": "16",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(5, 5)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Concatenate_163": {
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Conv2D_165": {
                "filters": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_168": {
                "filters": {
                    "value": "8",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "LeakyReLU(alpha=alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Conv2D_171": {
                "filters": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "tanh",
                    "type": "str",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "kernel_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                },
                "bias_regularizer": {
                    "value": "self.regularization",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_194": {
                "x": {
                    "value": "logvar * 0.5",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ones_like_222": {
                "input": {
                    "value": "D_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.decode_model([*e, z])",
                            "Call"
                        ],
                        [
                            "0.5 * (D_dist + tf.ones_like(D_dist))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "LeakyReLU_54": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_56": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_59": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_62": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_64": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_67": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_70": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_73": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_76": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_79": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_82": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_85": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_88": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_91": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_98": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_114": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_117": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_120": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_131": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_134": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_137": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_148": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_151": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_154": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_165": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "LeakyReLU_168": {
                "alpha": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0.3",
                            "float"
                        ]
                    ]
                }
            },
            "ones_like_189": {
                "input": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "P",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "Optimizers/DepthOptimizer.py": {
        "tensorflow": {
            "Adamax_30": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "stack_47": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_48": {
                "variable": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_49": {
                "variable": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_50": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_54": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_59": {
                "variable": {
                    "value": "rel_error",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_95": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(D)",
                            "Call"
                        ],
                        [
                            "tf.stack(D)",
                            "Call"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ],
                        [
                            "D_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "function_92": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_105": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_106": {
                "variable": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D",
                            "Method Argument"
                        ],
                        [
                            "D",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_107": {
                "variable": {
                    "value": "mask_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_108": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_110": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_121": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_123": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_127": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "function_118": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_142": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Dinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Dinv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_144": {
                "variable": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "A",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(A, shape=[shape[0], 1, 1, 1])",
                            "Call"
                        ],
                        [
                            "A",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "function_148": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "shape_157": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "Diff",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y_true - y_pred",
                            "BinOp"
                        ],
                        [
                            "Diff / tf.reshape(alpha_batch, shape=[shape[0], 1, 1, 1])",
                            "BinOp"
                        ]
                    ]
                }
            },
            "boolean_mask_161": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "self.g.Huber(Diff, 0.1)",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "function_152": {
                "experimental_compile": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "divide_no_nan_146": {
                "x": {
                    "value": "A * tf.ones_like(Dinv)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "Dinv + A * tf.ones_like(Dinv)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_66": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_68": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_150": {
                "input_tensor": {
                    "value": "tf.boolean_mask(tf.math.square(y_true - y_pred), mask)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_159": {
                "tensor": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_163": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(self.g.Huber(Diff, 0.1), mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "GradientTape_63": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ones_like_146": {
                "input": {
                    "value": "Dinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Dinv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_150": {
                "tensor": {
                    "value": "tf.math.square(y_true - y_pred)",
                    "type": "Call",
                    "possible_values": []
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "square_150": {
                "x": {
                    "value": "y_true - y_pred",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_82": {
                "x": {
                    "value": "loss_prev - loss_next",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "Optimizers/PhotometricOptimizer2.py": {
        "tensorflow": {
            "Adamax_39": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_45": {
                "variable": {
                    "value": "self.angle_th",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "self.angle_th",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_62": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_63": {
                "variable": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_64": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_65": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_66": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_72": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_78": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_80": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_82": {
                "variable": {
                    "value": "loss_val",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "-10.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "unstack_84": {
                "variable": {
                    "value": "mu_unstacked",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "mu",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "unstack_85": {
                "variable": {
                    "value": "sig_unstacked",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.math.exp(logvar)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_177": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "cast_179": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "shape[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_180": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "shape[2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_182": {
                "variable": {
                    "value": "s_dinv",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.linalg.diag([s, s, 1.0, 1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 4, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_185": {
                "variable": {
                    "value": "s_d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.linalg.diag([1.0 / s, 1.0 / s, 1.0, 1.0])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 4, 4]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_188": {
                "variable": {
                    "value": "T_batch_s",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "s_d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.linalg.diag([1.0 / s, 1.0 / s, 1.0, 1.0]), shape=[1, 4, 4])",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(T)",
                            "Call"
                        ],
                        [
                            "tf.stack(T)",
                            "Call"
                        ],
                        [
                            "T_batch",
                            "Method Argument"
                        ],
                        [
                            "T_batch",
                            "Method Argument"
                        ],
                        [
                            "T_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "matmul_189": {
                "variable": {
                    "value": "Tinv_batch_s",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(Tinv)",
                            "Call"
                        ],
                        [
                            "tf.stack(Tinv)",
                            "Call"
                        ],
                        [
                            "Tinv_batch",
                            "Method Argument"
                        ],
                        [
                            "Tinv_batch",
                            "Method Argument"
                        ],
                        [
                            "Tinv_batch",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "s_dinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.linalg.diag([s, s, 1.0, 1.0]), shape=[1, 4, 4])",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_191": {
                "variable": {
                    "value": "h_s",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.floordiv(h, s)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_193": {
                "variable": {
                    "value": "w_s",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.math.floordiv(w, s)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "resize_196": {
                "variable": {
                    "value": "I_batch_s",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "tf.stack(I)",
                            "Call"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ],
                        [
                            "I_batch",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "[h_s, w_s]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "resize_197": {
                "variable": {
                    "value": "D_batch_s",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, network.decode(q, z_batch))",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "[h_s, w_s]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "greater_equal_219": {
                "variable": {
                    "value": "flag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "self.calculate_gradients(s, T_batch, Tinv_batch, calib_batch, I_batch, alpha_batch, z_batch, q, mu, logvar, network, loss_val, count)",
                            "Call"
                        ],
                        [
                            "self.evaluate_rel_error(rel_e, s, count)",
                            "Call"
                        ],
                        [
                            "count + 1.0",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "tf.zeros_like(count)",
                            "Call"
                        ],
                        [
                            "count",
                            "Method Argument"
                        ],
                        [
                            "count",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "5.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "function_210": {
                "experimental_compile": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_236": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_237": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_241": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "unstack_245": {
                "variable": {
                    "value": "mu_unstacked",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "mu",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_254": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ],
                        [
                            "I",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_255": {
                "variable": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ],
                        [
                            "T",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_256": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ],
                        [
                            "Tinv",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_257": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ],
                        [
                            "calib",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_258": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "concat_262": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_264": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_96": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": [
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ],
                        [
                            "z",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_166": {
                "input_tensor": {
                    "value": "tf.square(tf.reduce_mean(network.mapToDepth(tf.ones_like(alpha_batch), P), axis=[1, 2, 3]) - 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "zeros_like_224": {
                "variable": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "count",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(0.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "self.calculate_gradients(s, T_batch, Tinv_batch, calib_batch, I_batch, alpha_batch, z_batch, q, mu, logvar, network, loss_val, count)",
                            "Call"
                        ],
                        [
                            "self.evaluate_rel_error(rel_e, s, count)",
                            "Call"
                        ],
                        [
                            "count + 1.0",
                            "BinOp"
                        ],
                        [
                            "0.0",
                            "float"
                        ],
                        [
                            "tf.zeros_like(count)",
                            "Call"
                        ],
                        [
                            "count",
                            "Method Argument"
                        ],
                        [
                            "count",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_not_226": {
                "variable": {
                    "value": "flag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "flag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(count, 5.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_not(flag)",
                            "Call"
                        ],
                        [
                            "tf.logical_not(flag)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_278": {
                "input_tensor": {
                    "value": "tf.square(tf.reduce_mean(network.mapToDepth(tf.ones_like(alpha_batch), P), axis=[1, 2, 3]) - 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_85": {
                "x": {
                    "value": "logvar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network.encode(IR)",
                            "Call"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "logvar",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "GradientTape_134": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "abs_144": {
                "x": {
                    "value": "prev_loss - loss_val",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "square_166": {
                "x": {
                    "value": "tf.reduce_mean(network.mapToDepth(tf.ones_like(alpha_batch), P), axis=[1, 2, 3]) - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "diag_182": {
                "diagonal": {
                    "value": "[s, s, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "diag_185": {
                "diagonal": {
                    "value": "[1.0 / s, 1.0 / s, 1.0, 1.0]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "floordiv_191": {
                "x": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(shape[1], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(1.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "self.calculate_gradients(s, T_batch, Tinv_batch, calib_batch, I_batch, alpha_batch, z_batch, q, mu, logvar, network, loss_val, count)",
                            "Call"
                        ],
                        [
                            "self.evaluate_rel_error(rel_e, s, count)",
                            "Call"
                        ],
                        [
                            "s / 2.0",
                            "BinOp"
                        ],
                        [
                            "tf.ones_like(s)",
                            "Call"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "floordiv_193": {
                "x": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(shape[2], dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(1.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "self.calculate_gradients(s, T_batch, Tinv_batch, calib_batch, I_batch, alpha_batch, z_batch, q, mu, logvar, network, loss_val, count)",
                            "Call"
                        ],
                        [
                            "self.evaluate_rel_error(rel_e, s, count)",
                            "Call"
                        ],
                        [
                            "s / 2.0",
                            "BinOp"
                        ],
                        [
                            "tf.ones_like(s)",
                            "Call"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_229": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(1.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "self.calculate_gradients(s, T_batch, Tinv_batch, calib_batch, I_batch, alpha_batch, z_batch, q, mu, logvar, network, loss_val, count)",
                            "Call"
                        ],
                        [
                            "self.evaluate_rel_error(rel_e, s, count)",
                            "Call"
                        ],
                        [
                            "s / 2.0",
                            "BinOp"
                        ],
                        [
                            "tf.ones_like(s)",
                            "Call"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ],
                        [
                            "s",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "logical_not_230": {
                "variable": {
                    "value": "flag",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "flag",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.greater_equal(count, 5.0)",
                            "Call"
                        ],
                        [
                            "tf.logical_not(flag)",
                            "Call"
                        ],
                        [
                            "tf.logical_not(flag)",
                            "Call"
                        ]
                    ]
                }
            },
            "square_278": {
                "x": {
                    "value": "tf.reduce_mean(network.mapToDepth(tf.ones_like(alpha_batch), P), axis=[1, 2, 3]) - 1.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_91": {
                "input_tensor": {
                    "value": "tf.abs(z[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "unstack_107": {
                "value": {
                    "value": "gradient",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_249": {
                "input_tensor": {
                    "value": "tf.abs(z[i])",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_91": {
                "x": {
                    "value": "z[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_166": {
                "input_tensor": {
                    "value": "network.mapToDepth(tf.ones_like(alpha_batch), P)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "abs_249": {
                "x": {
                    "value": "z[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_278": {
                "input_tensor": {
                    "value": "network.mapToDepth(tf.ones_like(alpha_batch), P)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1, 2, 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "ones_like_167": {
                "input": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "ones_like_279": {
                "input": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(alpha)",
                            "Call"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ],
                        [
                            "alpha_batch",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "Sample/DepthSample.py": {
        "tensorflow": {
            "stack_48": {
                "variable": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_49": {
                "variable": {
                    "value": "self.Kinv",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "self.Kinv",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_85": {
                "variable": {
                    "value": "D_batch_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.D",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_89": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_90": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_91": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.z",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_92": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_96": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_103": {
                "variable": {
                    "value": "d_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_110": {
                "variable": {
                    "value": "d_max_z0",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch_z0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch_z0, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch_z0[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_112": {
                "variable": {
                    "value": "d_max_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.D)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.D)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch_gt, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch_gt[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_124": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_125": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_126": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.z",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_127": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_131": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_143": {
                "variable": {
                    "value": "D_batch_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.D",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_145": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_147": {
                "variable": {
                    "value": "I_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], shape[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_152": {
                "variable": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "D_batch[:, 0:3, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_154": {
                "variable": {
                    "value": "D_batch_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_159": {
                "variable": {
                    "value": "D_batch_z0",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "D_batch_z0[:, 0:3, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_161": {
                "variable": {
                    "value": "D_batch_z0_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "D_batch_z0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch_z0, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch_z0[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_166": {
                "variable": {
                    "value": "D_batch_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "D_batch_gt[:, 0:3, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_168": {
                "variable": {
                    "value": "D_batch_gt_flat",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "D_batch_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.D)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.D)",
                            "Call"
                        ],
                        [
                            "g.unproject(D_batch_gt, self.Kinv)",
                            "Call"
                        ],
                        [
                            "tf.transpose(D_batch_gt[:, 0:3, :], perm=[0, 2, 1])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape[0], shape[1] * shape[2], 3]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_65": {
                "x": {
                    "value": "np.array([[1.0 / K[0, 0], 0, -K[0, 2] / K[0, 0], 0.0], [0.0, 1.0 / K[1, 1], -K[1, 2] / K[1, 1], 0.0], [0.0, 0.0, 1.0, 0.0], [0.0, 0.0, 0.0, 1.0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "image_114": {
                "name": {
                    "value": "input_image",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_115": {
                "name": {
                    "value": "D",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "D_batch / d_max",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_116": {
                "name": {
                    "value": "D_batch_gt",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "D_batch_gt / d_max_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_117": {
                "name": {
                    "value": "D_z0",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "D_batch_z0 / d_max_z0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "histogram_118": {
                "name": {
                    "value": "hist_z",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "zeros_like_105": {
                "input": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_138": {
                "input": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_44": {
                "value": {
                    "value": "self.getCalibVec(k)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_53": {
                "input_tensor": {
                    "value": "self.D[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "Sample/PhotometricSample.py": {
        "tensorflow": {
            "stack_88": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_89": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_90": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.z",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_91": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_95": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_102": {
                "variable": {
                    "value": "d_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(tf.ones_like(alpha_batch[0:1]), P)",
                            "Call"
                        ],
                        [
                            "network.mapToDepth(tf.ones_like(alpha_batch), P)",
                            "Call"
                        ],
                        [
                            "tf.reshape(alpha_batch[0:1], shape=[1, 1, 1, 1]) * D_batch",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_max_109": {
                "variable": {
                    "value": "d_max_z0",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_batch_z0",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network.mapToDepth(alpha_batch, P)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_126": {
                "variable": {
                    "value": "angle_th",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "angle_th",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(angle_th, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.constant(85.0 * 3.14 / 180.0, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "angle_th",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_128": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_129": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.Tinv",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_130": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_131": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.z",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_132": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_141": {
                "variable": {
                    "value": "P_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR, tf.zeros_like(z_batch))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*P, image.getP_Homogeneous()]",
                            "List"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR, tf.zeros_like(z_batch))",
                            "Call"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*P, image.getP_Homogeneous()]",
                            "List"
                        ],
                        [
                            "network(IR[0:1], z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR[0:1], z_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_145": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_237": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_238": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_239": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.z",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_240": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_244": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "constant_324": {
                "variable": {
                    "value": "angle_th",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "85.0 * 3.14 / 180.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_326": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.Tinv",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_335": {
                "variable": {
                    "value": "P_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "P",
                    "type": "variable",
                    "possible_values": [
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR, tf.zeros_like(z_batch))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*P, image.getP_Homogeneous()]",
                            "List"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR, tf.zeros_like(z_batch))",
                            "Call"
                        ],
                        [
                            "network(IR, z_batch)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*P, image.getP_Homogeneous()]",
                            "List"
                        ],
                        [
                            "network(IR[0:1], z_batch)",
                            "Call"
                        ],
                        [
                            "network(IR[0:1], z_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_337": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.calib",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_338": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.I",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_339": {
                "variable": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "self.alpha",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_343": {
                "variable": {
                    "value": "IR",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "(I_batch, R)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Variable_345": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.z[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stack_347": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_111": {
                "name": {
                    "value": "input_image",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.I)",
                            "Call"
                        ],
                        [
                            "I_batch[0:1]",
                            "Subscript"
                        ]
                    ]
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_112": {
                "name": {
                    "value": "D",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "D_batch / d_max",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "image_113": {
                "name": {
                    "value": "D_z0",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "D_batch_z0 / d_max_z0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "histogram_114": {
                "name": {
                    "value": "hist_z",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ]
                    ]
                },
                "step": {
                    "value": "step",
                    "type": "variable",
                    "possible_values": [
                        [
                            "step",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "stack_188": {
                "variable": {
                    "value": "D_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "D_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(D_gt)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_208": {
                "variable": {
                    "value": "sp_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.convert_to_tensor(sp_depth, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "transpose_211": {
                "variable": {
                    "value": "red_pt",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tf.convert_to_tensor(red_pt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_372": {
                "variable": {
                    "value": "pertb",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "pertb",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(192)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(pertb, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Variable_374": {
                "variable": {
                    "value": "z",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "self.z[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "stack_378": {
                "variable": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[z]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "abs_386": {
                "variable": {
                    "value": "diff",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "depth_optimal - depth_prediction",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_401": {
                "variable": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.convert_to_tensor(ar, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_404": {
                "variable": {
                    "value": "color",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.convert_to_tensor(np.array(col).reshape((1, 1, 3)), dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_like_104": {
                "input": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_162": {
                "input": {
                    "value": "z_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.z)",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ],
                        [
                            "tf.stack([z])",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_180": {
                "variable": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getDepth()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(depth, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_182": {
                "variable": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getDepth()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(depth, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "ones_like_351": {
                "input": {
                    "value": "alpha_batch[0:1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reshape_435": {
                "tensor": {
                    "value": "alpha_batch[0:1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_436": {
                "input": {
                    "value": "depth_optimal",
                    "type": "variable",
                    "possible_values": [
                        [
                            "D_batch[0, :, :, 0:1]",
                            "Subscript"
                        ],
                        [
                            "tf.reshape(alpha_batch[0:1], shape=[1, 1, 1, 1]) * tf.expand_dims(depth_optimal, 0)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_438": {
                "input": {
                    "value": "tf.convert_to_tensor(image)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_209": {
                "value": {
                    "value": "sp_depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getSparseDepth()",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.convert_to_tensor(sp_depth, dtype=tf.float32))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_211": {
                "value": {
                    "value": "red_pt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(sp_depth.shape, dtype=np.float32)",
                            "Call"
                        ],
                        [
                            "tf.transpose(tf.convert_to_tensor(red_pt))",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_382": {
                "input": {
                    "value": "alpha_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(self.alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.alpha)",
                            "Call"
                        ],
                        [
                            "tf.stack(self.alpha)",
                            "Call"
                        ],
                        [
                            "alpha_batch[0:1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reshape_398": {
                "tensor": {
                    "value": "alpha_batch[0:1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_402": {
                "value": {
                    "value": "ar",
                    "type": "variable",
                    "possible_values": [
                        [
                            "depth_prediction.numpy()",
                            "Call"
                        ],
                        [
                            "ar * 1000",
                            "BinOp"
                        ],
                        [
                            "ar.astype(np.uint32)",
                            "Call"
                        ],
                        [
                            "depth_gt * 1000",
                            "BinOp"
                        ],
                        [
                            "ar.astype(np.uint32)",
                            "Call"
                        ],
                        [
                            "diff.numpy()",
                            "Call"
                        ],
                        [
                            "ar / max_val",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_404": {
                "value": {
                    "value": "np.array(col).reshape((1, 1, 3))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_438": {
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sfm_images",
                            "Attribute"
                        ],
                        [
                            "self.sfm_images",
                            "Attribute"
                        ],
                        [
                            "self.sfm_images",
                            "Attribute"
                        ],
                        [
                            "np.zeros((192, 256, 3))",
                            "Call"
                        ],
                        [
                            "image + 1.0 / 192.0 * ar * np.array(col).reshape((1, 1, 3))",
                            "BinOp"
                        ],
                        [
                            "image / max_val",
                            "BinOp"
                        ]
                    ]
                }
            },
            "constant_44": {
                "value": {
                    "value": "U_mean[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Sample/metrics.py": {
        "tensorflow": {
            "convert_to_tensor_12": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_13": {
                "variable": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_14": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(mask, dtype=tf.bool)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "boolean_mask_16": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(mask, dtype=tf.bool)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "boolean_mask_17": {
                "variable": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                },
                "mask": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(mask, dtype=tf.bool)",
                            "Call"
                        ],
                        [
                            "mask",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reshape_19": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_20": {
                "variable": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "convert_to_tensor_23": {
                "variable": {
                    "value": "e_vec",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[AbsRel(d, d_gt), SqRel(d, d_gt), RMSE(d, d_gt), log_scale_inv_RMSE(d, d_gt), accuracy_under_thres(d, d_gt), accuracy_under_thres2(d, d_gt), accuracy_under_thres3(d, d_gt)]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_28": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / tf.math.reduce_prod(tf.shape(d))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_33": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / tf.math.reduce_prod(tf.shape(d))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_38": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / tf.math.reduce_prod(tf.shape(d))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_43": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / tf.math.reduce_prod(tf.shape(d))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_45": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(1 / tf.math.reduce_prod(tf.shape(d)), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "e * tf.reduce_sum(tf.math.divide(tf.math.abs(d - d_gt), d_gt))",
                            "BinOp"
                        ],
                        [
                            "tf.cast(1 / tf.math.reduce_prod(tf.shape(d)), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "e * tf.reduce_sum(tf.math.abs(d - d_gt))",
                            "BinOp"
                        ],
                        [
                            "tf.cast(1 / tf.math.reduce_prod(tf.shape(d)), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "e * tf.reduce_sum(tf.math.divide(tf.math.pow(d - d_gt, 2), d_gt))",
                            "BinOp"
                        ],
                        [
                            "tf.cast(1 / tf.math.reduce_prod(tf.shape(d)), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "e * tf.reduce_sum(tf.math.pow(d - d_gt, 2))",
                            "BinOp"
                        ],
                        [
                            "tf.math.sqrt(e)",
                            "Call"
                        ],
                        [
                            "tf.cast(1 / (2 * tf.math.reduce_prod(tf.shape(d))), dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "e * tf.reduce_sum(tf.math.pow(tf.math.log(d + EPS) - tf.math.log(d_gt) + alpha, 2))",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)) / tf.cast(tf.reduce_prod(tf.shape(d)), dtype=tf.float32) * 100",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)) / tf.cast(tf.reduce_prod(tf.shape(d)), dtype=tf.float32) * 100",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)) / tf.cast(tf.reduce_prod(tf.shape(d)), dtype=tf.float32) * 100",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_51": {
                "variable": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / (2 * tf.math.reduce_prod(tf.shape(d)))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_53": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "1 / (2 * tf.math.reduce_prod(tf.shape(d)))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_29": {
                "input_tensor": {
                    "value": "tf.math.divide(tf.math.abs(d - d_gt), d_gt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_34": {
                "input_tensor": {
                    "value": "tf.math.abs(d - d_gt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_39": {
                "input_tensor": {
                    "value": "tf.math.divide(tf.math.pow(d - d_gt, 2), d_gt)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_44": {
                "input_tensor": {
                    "value": "tf.math.pow(d - d_gt, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_52": {
                "input_tensor": {
                    "value": "tf.math.log(d_gt) - tf.math.log(d + EPS)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_55": {
                "input_tensor": {
                    "value": "tf.math.pow(tf.math.log(d + EPS) - tf.math.log(d_gt) + alpha, 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_prod_28": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_29": {
                "x": {
                    "value": "tf.math.abs(d - d_gt)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_prod_33": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_34": {
                "x": {
                    "value": "d - d_gt",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_prod_38": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "divide_39": {
                "x": {
                    "value": "tf.math.pow(d - d_gt, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_prod_43": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "pow_44": {
                "x": {
                    "value": "d - d_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "pow_55": {
                "x": {
                    "value": "tf.math.log(d + EPS) - tf.math.log(d_gt) + alpha",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_60": {
                "input_tensor": {
                    "value": "tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_60": {
                "x": {
                    "value": "tf.math.maximum(d / d_gt, d_gt / d) < thres",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_65": {
                "input_tensor": {
                    "value": "tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_65": {
                "x": {
                    "value": "tf.math.maximum(d / d_gt, d_gt / d) < thres",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_70": {
                "input_tensor": {
                    "value": "tf.cast(tf.math.maximum(d / d_gt, d_gt / d) < thres, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_70": {
                "x": {
                    "value": "tf.math.maximum(d / d_gt, d_gt / d) < thres",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_28": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "abs_29": {
                "x": {
                    "value": "d - d_gt",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_33": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_38": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "pow_39": {
                "x": {
                    "value": "d - d_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_43": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_prod_51": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_52": {
                "x": {
                    "value": "d + EPS",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_prod_53": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_prod_60": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_prod_65": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_prod_70": {
                "input_tensor": {
                    "value": "tf.shape(d)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_51": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_53": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_60": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_65": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_70": {
                "input": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d, [-1])",
                            "Call"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ],
                        [
                            "d",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "log_55": {
                "x": {
                    "value": "d_gt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(d_gt, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.boolean_mask(d_gt, mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(d_gt, [-1])",
                            "Call"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ],
                        [
                            "d_gt",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "maximum_60": {
                "x": {
                    "value": "d / d_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "d_gt / d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_65": {
                "x": {
                    "value": "d / d_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "d_gt / d",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "maximum_70": {
                "x": {
                    "value": "d / d_gt",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "d_gt / d",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "Sfm/sfm_image.py": {
        "tensorflow": {
            "reduce_mean_120": {
                "variable": {
                    "value": "self.depth_mean",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.depth",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "Trainer/Manager.py": {
        "tensorflow": {
            "Checkpoint_128": {
                "variable": {
                    "value": "self.root",
                    "type": "Attribute",
                    "possible_values": []
                },
                "encoder": {
                    "value": "self.network.getEncoder()",
                    "type": "Call",
                    "possible_values": []
                },
                "decoder": {
                    "value": "self.network.getDecoder()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_340": {
                "variable": {
                    "value": "e",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "e_vec",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Progbar_221": {
                "variable": {
                    "value": "progbar",
                    "type": "variable",
                    "possible_values": []
                },
                "target": {
                    "value": "nbr_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.calculate_epoch_samples(epoch)",
                            "Call"
                        ],
                        [
                            "self.photometric_batch_loader.getNbrBatches()",
                            "Call"
                        ],
                        [
                            "self.depth_batch_loader.getNbrBatches()",
                            "Call"
                        ]
                    ]
                }
            },
            "latest_checkpoint_152": {
                "checkpoint_dir": {
                    "value": "checkpoint_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_dir",
                            "variable"
                        ]
                    ]
                }
            },
            "scalar_392": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "np.mean(loss_avg[batch_loader.getName()])",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "epoch in range(self.epochs)",
                            "Call"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_396": {
                "name": {
                    "value": "recon_loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "np.mean(recon_loss_avg[batch_loader.getName()])",
                    "type": "Call",
                    "possible_values": []
                },
                "step": {
                    "value": "epoch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "epoch in range(self.epochs)",
                            "Call"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ],
                        [
                            "epoch",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "Trainer/Trainer.py": {
        "tensorflow": {
            "Adamax_31": {
                "variable": {
                    "value": "self.optimizer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "lr": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                }
            },
            "constant_37": {
                "value": {
                    "value": "float('Inf')",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_38": {
                "value": {
                    "value": "float('Inf')",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_71": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_72": {
                "variable": {
                    "value": "recon_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GradientTape_68": {
                "watch_accessed_variables": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "main.py": {
        "tensorflow": {
            "list_physical_devices_32": {
                "variable": {
                    "value": "gpus",
                    "type": "variable",
                    "possible_values": []
                },
                "device_type": {
                    "value": "GPU",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_memory_growth_37": {
                "device": {
                    "value": "gpu",
                    "type": "variable",
                    "possible_values": [
                        [
                            "gpus",
                            "variable"
                        ]
                    ]
                },
                "enable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "unittest/GTAReader.py": {
        "tensorflow": {}
    },
    "unittest/test.py": {
        "tensorflow": {
            "ConfigProto_35": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_37": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.compat.v1.ConfigProto()",
                            "Call"
                        ],
                        [
                            "yaml.safe_load(stream)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_95": {
                "variable": {
                    "value": "I",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "images",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*images, tf.convert_to_tensor(image.getImage())]",
                            "List"
                        ],
                        [
                            "g.warp_images(transformed_points, mask, I)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_96": {
                "variable": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "depths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*depths, tf.ones([240, 320, 1])]",
                            "List"
                        ],
                        [
                            "g.transformBatch(D, M, grid, alpha)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_97": {
                "variable": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*scale, tf.constant(5.0, dtype=tf.float32)]",
                            "List"
                        ]
                    ]
                }
            },
            "create_file_writer_114": {
                "variable": {
                    "value": "file_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "logdir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'/data/logs/train_data/' + datetime.now().strftime('%Y%m%d-%H%M%S')",
                            "BinOp"
                        ]
                    ]
                }
            },
            "image_129": {
                "name": {
                    "value": "Training data",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "images[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "step": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "convert_to_tensor_84": {
                "value": {
                    "value": "image.getImage()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ones_85": {
                "shape": {
                    "value": "[240, 320, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "constant_92": {
                "value": {
                    "value": "5.0",
                    "type": "float",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "unittest/unit_test2.py": {
        "tensorflow": {
            "stack_102": {
                "variable": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "T_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*T_batch, tf.constant(T, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(T_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_103": {
                "variable": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "Tinv_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*Tinv_batch, tf.constant(Tinv, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(Tinv_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_104": {
                "variable": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "D_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*D_batch, tf.constant(D, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(D_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_105": {
                "variable": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*I_batch, tf.constant(image, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(I_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_106": {
                "variable": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "calib_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*calib_batch, tf.constant([fx, fy, x0, y0], dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(calib_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_113": {
                "variable": {
                    "value": "shape_i",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*I_batch, tf.constant(image, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(I_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_117": {
                "variable": {
                    "value": "XX",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "X[:, 0:3, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "perm": {
                    "value": "[0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_119": {
                "variable": {
                    "value": "II",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "I_batch",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[*I_batch, tf.constant(image, dtype=tf.float32)]",
                            "List"
                        ],
                        [
                            "tf.stack(I_batch)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[shape_i[0], shape_i[1] * shape_i[2], shape_i[3]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "logical_and_146": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_I",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_Identity_mask(shape_d[2], shape_d[1], shape_d[0])",
                            "Call"
                        ]
                    ]
                }
            },
            "logical_and_150": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "mask_g",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_occlusion_mask(relative_depth_error, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_152": {
                "variable": {
                    "value": "I_warp_masked",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "I_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(I_warp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_153": {
                "variable": {
                    "value": "error_image_masked",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(error_image)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_155": {
                "variable": {
                    "value": "D_warp_masked",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "D_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(D_warp)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_194": {
                "variable": {
                    "value": "mask_s",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                }
            },
            "where_196": {
                "variable": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(error_image)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_199": {
                "variable": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ],
                        [
                            "g.calculate_masks(D_batch, calib_batch, mask, angle)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_I)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(mask, mask_g)",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "x": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_relative_depth_error(D_warp, d_projected_warp)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(relative_depth_error)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_202": {
                "variable": {
                    "value": "error_photometric",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "g.Huber(error_image, 0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_204": {
                "variable": {
                    "value": "error_depth",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "g.Huber(relative_depth_error, 0.1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "convert_to_tensor_71": {
                "variable": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(depth), depth, tf.zeros_like(depth))",
                            "Call"
                        ]
                    ]
                }
            },
            "where_73": {
                "variable": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "tf.math.is_finite(depth)",
                    "type": "Call",
                    "possible_values": []
                },
                "x": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(depth), depth, tf.zeros_like(depth))",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.zeros_like(depth)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_76": {
                "variable": {
                    "value": "sfm_image.depth",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(depth), depth, tf.zeros_like(depth))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "zeros_like_152": {
                "input": {
                    "value": "I_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_154": {
                "input": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_155": {
                "input": {
                    "value": "D_warp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.warp(I_batch, D_batch, T_batch, Tinv_batch)",
                            "Call"
                        ]
                    ]
                }
            },
            "abs_175": {
                "variable": {
                    "value": "Ie_ij",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "error_image_masked[i, j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_max_182": {
                "variable": {
                    "value": "d_max",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "D_warp_masked[i, j]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_like_197": {
                "input": {
                    "value": "error_image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_error_image(I_warp, I_batch)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, error_image, tf.zeros_like(error_image))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_200": {
                "input": {
                    "value": "relative_depth_error",
                    "type": "variable",
                    "possible_values": [
                        [
                            "g.calculate_relative_depth_error(D_warp, d_projected_warp)",
                            "Call"
                        ],
                        [
                            "tf.where(mask, relative_depth_error, tf.zeros_like(relative_depth_error))",
                            "Call"
                        ],
                        [
                            "g.calculate_error_image_depth(I_batch, D_batch, T_batch, Tinv_batch, calib_batch, angle, w, h)",
                            "Call"
                        ]
                    ]
                }
            },
            "is_finite_73": {
                "x": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(depth), depth, tf.zeros_like(depth))",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_like_74": {
                "input": {
                    "value": "depth",
                    "type": "variable",
                    "possible_values": [
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "reader.next()",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(depth)",
                            "Call"
                        ],
                        [
                            "tf.where(tf.math.is_finite(depth), depth, tf.zeros_like(depth))",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_95": {
                "value": {
                    "value": "T",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getTransformations()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_96": {
                "value": {
                    "value": "Tinv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getTransformations()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_97": {
                "value": {
                    "value": "D",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getDepth()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_98": {
                "value": {
                    "value": "image",
                    "type": "variable",
                    "possible_values": [
                        [
                            "im.getImage()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_100": {
                "value": {
                    "value": "[fx, fy, x0, y0]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    }
}