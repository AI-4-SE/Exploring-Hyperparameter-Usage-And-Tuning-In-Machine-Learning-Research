{
    "docqa/configurable.py": {
        "sklearn": {}
    },
    "docqa/data_analysis/show_sampling.py": {
        "sklearn": {}
    },
    "docqa/data_processing/document_splitter.py": {
        "sklearn": {
            "TfidfVectorizer_105": {
                "variable": {
                    "value": "tfidf",
                    "type": "variable",
                    "possible_values": []
                },
                "strip_accents": {
                    "value": "unicode",
                    "type": "str",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "self.stop.words",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pairwise_distances_115": {
                "variable": {
                    "value": "dists",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "q_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ]
                    ]
                },
                "Y": {
                    "value": "para_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ]
                    ]
                },
                "metric": {
                    "value": "cosine",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TfidfVectorizer_124": {
                "variable": {
                    "value": "tfidf",
                    "type": "variable",
                    "possible_values": []
                },
                "strip_accents": {
                    "value": "unicode",
                    "type": "str",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "self.stop.words",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pairwise_distances_134": {
                "variable": {
                    "value": "dists",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "q_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ]
                    ]
                },
                "Y": {
                    "value": "para_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ]
                    ]
                },
                "metric": {
                    "value": "cosine",
                    "type": "str",
                    "possible_values": []
                }
            },
            "TfidfVectorizer_154": {
                "variable": {
                    "value": "self._tfidf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strip_accents": {
                    "value": "unicode",
                    "type": "str",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "self._stop",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pairwise_distances_190": {
                "variable": {
                    "value": "tfidf",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "q_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ],
                        [
                            "tfidf.transform([' '.join(question)])",
                            "Call"
                        ]
                    ]
                },
                "Y": {
                    "value": "para_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ],
                        [
                            "tfidf.fit_transform(text)",
                            "Call"
                        ]
                    ]
                },
                "metric": {
                    "value": "cosine",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/squad/squad_document_qa.py": {
        "sklearn": {
            "TfidfVectorizer_94": {
                "variable": {
                    "value": "self._tfidf",
                    "type": "Attribute",
                    "possible_values": []
                },
                "strip_accents": {
                    "value": "unicode",
                    "type": "str",
                    "possible_values": []
                },
                "stop_words": {
                    "value": "self.stop.words",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "pairwise_distances_103": {
                "variable": {
                    "value": "scores",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "q_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.transform([' '.join(q) for q in questions])",
                            "Call"
                        ]
                    ]
                },
                "Y": {
                    "value": "para_features",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tfidf.fit_transform([' '.join((' '.join(s) for s in x)) for x in paragraphs])",
                            "Call"
                        ]
                    ]
                },
                "metric": {
                    "value": "cosine",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/doc_qa_models.py": {
        "tensorflow": {
            "placeholder_69": {
                "variable": {
                    "value": "self._is_train_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_109": {
                "variable": {
                    "value": "q_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "q_embed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(q_embed, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_110": {
                "variable": {
                    "value": "c_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "c_embed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(c_embed, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_154": {
                "name_or_scope": {
                    "value": "encode",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_157": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_205": {
                "name_or_scope": {
                    "value": "buid_memories",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_208": {
                "name_or_scope": {
                    "value": "apply_attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_215": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_268": {
                "name_or_scope": {
                    "value": "build_memories",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_271": {
                "name_or_scope": {
                    "value": "apply_attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_278": {
                "name_or_scope": {
                    "value": "encode_question",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_281": {
                "name_or_scope": {
                    "value": "map_with_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_288": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_85": {
                "name_or_scope": {
                    "value": "char-embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_93": {
                "name_or_scope": {
                    "value": "word-embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_192": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_194": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_198": {
                "name_or_scope": {
                    "value": "map_question",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_202": {
                "name_or_scope": {
                    "value": "map_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_212": {
                "name_or_scope": {
                    "value": "process_attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_255": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_257": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_261": {
                "name_or_scope": {
                    "value": "map_question",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_265": {
                "name_or_scope": {
                    "value": "map_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_275": {
                "name_or_scope": {
                    "value": "process_attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_285": {
                "name_or_scope": {
                    "value": "process_context_mapped",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_98": {
                "name_or_scope": {
                    "value": "embed-map",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/ablate_elmo_model.py": {
        "tensorflow": {
            "TruncatedNormal_36": {
                "stddev": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/elmo.py": {
        "tensorflow": {
            "sequence_mask_14": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, tf.shape(x)[1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(x)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_74": {
                "variable": {
                    "value": "mask_float",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, tf.shape(x)[1])",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_75": {
                "variable": {
                    "value": "broadcast_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_float",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask, 'float32')",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "control_dependencies_72": {
                "control_inputs": {
                    "value": "[lm_embeddings, mask]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_134": {
                "variable": {
                    "value": "gamma",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'ELMo_gamma_{}'.format(k)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.ones_initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "regularizer": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_57": {
                "input_tensor": {
                    "value": "tf.square(weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_scope_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "batch_normalization_84": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "mean": {
                    "value": "mean",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(x_masked) / N",
                            "BinOp"
                        ]
                    ]
                },
                "variance": {
                    "value": "variance",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(((x_masked - mean) * broadcast_mask) ** 2) / N",
                            "BinOp"
                        ]
                    ]
                },
                "offset": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "scale": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "variance_epsilon": {
                    "value": "1e-12",
                    "type": "float",
                    "possible_values": []
                }
            },
            "split_91": {
                "variable": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "lm_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "n_lm_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(lm_embeddings.get_shape()[1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_93": {
                "variable": {
                    "value": "sum_pieces",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layers[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_97": {
                "variable": {
                    "value": "W",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'ELMo_W_{}'.format(k)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "(n_lm_layers,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer",
                    "type": "Attribute",
                    "possible_values": []
                },
                "regularizer": {
                    "value": "_l2_regularizer",
                    "type": "variable",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "split_111": {
                "variable": {
                    "value": "normed_weights",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.nn.softmax(W + 1.0 / n_lm_layers)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "n_lm_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(lm_embeddings.get_shape()[1])",
                            "Call"
                        ]
                    ]
                }
            },
            "split_115": {
                "variable": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "lm_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "n_lm_layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "int(lm_embeddings.get_shape()[1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_n_124": {
                "variable": {
                    "value": "sum_pieces",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "pieces",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "shape_14": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "square_57": {
                "x": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_scope_65": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_80": {
                "input_tensor": {
                    "value": "mask_float",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(mask, 'float32')",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_81": {
                "input_tensor": {
                    "value": "x_masked",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * broadcast_mask",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_82": {
                "input_tensor": {
                    "value": "((x_masked - mean) * broadcast_mask) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_to_collection_143": {
                "name": {
                    "value": "prefix + 'gamma'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "value": {
                    "value": "gamma[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "softmax_112": {
                "logits": {
                    "value": "W + 1.0 / n_lm_layers",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "add_to_collection_108": {
                "name": {
                    "value": "prefix + '%d/' % i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "value": {
                    "value": "W[i]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "get_collection_128": {
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "squeeze_123": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_121": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/eval_elmo_minimal.py": {
        "tensorflow": {
            "Session_55": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_73": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x for x in all_vars if x.name not in dont_restore_names]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "ExponentialMovingAverage_77": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_78": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "{ema.average_name(x): x for x in tf.trainable_variables()}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "global_variables_60": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_60": {
                "key": {
                    "value": "tf.GraphKeys.SAVEABLE_OBJECTS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variables_initializer_81": {
                "var_list": {
                    "value": "[x for x in all_vars if x.name in dont_restore_names]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "trainable_variables_78": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/lm_model.py": {
        "tensorflow": {
            "placeholder_590": {
                "variable": {
                    "value": "ids_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None, max_word_length)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ConfigProto_604": {
                "variable": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": []
                },
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_472": {
                "variable": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.cast(mask, tf.int32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "group_574": {
                "variable": {
                    "value": "self.update_state_op",
                    "type": "Attribute",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "*update_ops",
                    "type": "Starred",
                    "possible_values": []
                }
            },
            "concat_145": {
                "variable": {
                    "value": "lm_embeddings",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.expand_dims(t, axis=1) for t in layers_without_bos_eos]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_153": {
                "variable": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._lm_graph.mask[:, 1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reverse_sequence_154": {
                "variable": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(self._lm_graph.mask[:, 1:], 'int32')",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, self._lm_graph.sequence_lengths - 1, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "mask_wo_bos_eos[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, sequence_length_wo_bos_eos, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask_wo_bos_eos, 'bool')",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "self._lm_graph.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reverse_sequence_161": {
                "variable": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(self._lm_graph.mask[:, 1:], 'int32')",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, self._lm_graph.sequence_lengths - 1, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "mask_wo_bos_eos[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, sequence_length_wo_bos_eos, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask_wo_bos_eos, 'bool')",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "sequence_length_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._lm_graph.sequence_lengths - 2",
                            "BinOp"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_167": {
                "variable": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(self._lm_graph.mask[:, 1:], 'int32')",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, self._lm_graph.sequence_lengths - 1, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "mask_wo_bos_eos[:, 1:]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(mask_wo_bos_eos, sequence_length_wo_bos_eos, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask_wo_bos_eos, 'bool')",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_308": {
                "variable": {
                    "value": "self.embedding_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "char_embed",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_chars, char_embed_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-1.0, 1.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "embedding_lookup_314": {
                "variable": {
                    "value": "self.char_embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.embedding_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_375": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "make_convolutions(self.char_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [-1, n_filters])",
                            "Call"
                        ],
                        [
                            "tf.matmul(embedding, W_proj_cnn) + b_proj_cnn",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(embedding, shp)",
                            "Call"
                        ],
                        [
                            "high(embedding, W_carry, b_carry, W_transform, b_transform)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, n_filters]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "sigmoid_393": {
                "variable": {
                    "value": "carry_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.matmul(x, ww_carry) + bb_carry",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "relu_394": {
                "variable": {
                    "value": "transform_gate",
                    "type": "variable",
                    "possible_values": []
                },
                "features": {
                    "value": "tf.matmul(x, ww_tr) + bb_tr",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_431": {
                "variable": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[batch_size_n_tokens, [projection_dim]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_432": {
                "variable": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "make_convolutions(self.char_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [-1, n_filters])",
                            "Call"
                        ],
                        [
                            "tf.matmul(embedding, W_proj_cnn) + b_proj_cnn",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(embedding, shp)",
                            "Call"
                        ],
                        [
                            "high(embedding, W_carry, b_carry, W_transform, b_transform)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([batch_size_n_tokens, [projection_dim]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_444": {
                "variable": {
                    "value": "self.embedding_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_tokens_vocab, projection_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "embedding_lookup_448": {
                "variable": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "self.embedding_weights",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "self.ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_any_469": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.ids_placeholder > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Session_605": {
                "config": {
                    "value": "config",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ConfigProto(allow_soft_placement=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_107": {
                "control_inputs": {
                    "value": "[self._lm_graph.update_state_op]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reverse_sequence_129": {
                "variable": {
                    "value": "layer_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer[:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(layer_wo_bos_eos, self._lm_graph.sequence_lengths - 1, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "layer_wo_bos_eos[:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(layer_wo_bos_eos, sequence_length_wo_bos_eos, seq_axis=1, batch_axis=0)",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "self._lm_graph.sequence_lengths - 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reverse_sequence_136": {
                "variable": {
                    "value": "layer_wo_bos_eos",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "layer_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "layer[:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(layer_wo_bos_eos, self._lm_graph.sequence_lengths - 1, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "layer_wo_bos_eos[:, 1:, :]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(layer_wo_bos_eos, sequence_length_wo_bos_eos, seq_axis=1, batch_axis=0)",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "sequence_length_wo_bos_eos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._lm_graph.sequence_lengths - 2",
                            "BinOp"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_260": {
                "name_or_scope": {
                    "value": "bilm",
                    "type": "str",
                    "possible_values": []
                },
                "custom_getter": {
                    "value": "custom_getter",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "device_307": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_363": {
                "values": {
                    "value": "convolutions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_381": {
                "variable": {
                    "value": "W_proj_cnn",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[n_filters, projection_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(mean=0.0, stddev=np.sqrt(1.0 / n_filters))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "get_variable_386": {
                "variable": {
                    "value": "b_proj_cnn",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[projection_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "device_443": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_472": {
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_any(self.ids_placeholder > 0, axis=2)",
                            "Call"
                        ],
                        [
                            "self.ids_placeholder > 0",
                            "Compare"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_473": {
                "input": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(mask, tf.int32), axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reverse_sequence_486": {
                "variable": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.embedding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(mask, tf.int32), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "global_variables_initializer_606": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_111": {
                "values": {
                    "value": "[token_embeddings, token_embeddings]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_319": {
                "name_or_scope": {
                    "value": "CNN",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_339": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'W_cnn_%s' % i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, width, char_embed_dim, num]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.random_uniform_initializer(minval=-0.05, maxval=0.05)",
                            "Call"
                        ],
                        [
                            "tf.random_normal_initializer(mean=0.0, stddev=np.sqrt(1.0 / (width * char_embed_dim)))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "get_variable_344": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'b_cnn_%s' % i",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[num]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "max_pool_353": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID') + b",
                            "BinOp"
                        ],
                        [
                            "tf.nn.max_pool(conv, [1, 1, max_chars - width + 1, 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "activation(conv)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(conv, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "ksize": {
                    "value": "[1, 1, max_chars - width + 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "squeeze_359": {
                "variable": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "conv",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.conv2d(inp, w, strides=[1, 1, 1, 1], padding='VALID') + b",
                            "BinOp"
                        ],
                        [
                            "tf.nn.max_pool(conv, [1, 1, max_chars - width + 1, 1], [1, 1, 1, 1], 'VALID')",
                            "Call"
                        ],
                        [
                            "activation(conv)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(conv, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_374": {
                "input": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "make_convolutions(self.char_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [-1, n_filters])",
                            "Call"
                        ],
                        [
                            "tf.matmul(embedding, W_proj_cnn) + b_proj_cnn",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(embedding, shp)",
                            "Call"
                        ],
                        [
                            "high(embedding, W_carry, b_carry, W_transform, b_transform)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_380": {
                "name_or_scope": {
                    "value": "CNN_proj",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_402": {
                "variable": {
                    "value": "W_carry",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_carry",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[highway_dim, highway_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(mean=0.0, stddev=np.sqrt(1.0 / highway_dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "get_variable_408": {
                "variable": {
                    "value": "b_carry",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b_carry",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[highway_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(-2.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "get_variable_412": {
                "variable": {
                    "value": "W_transform",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "W_transform",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[highway_dim, highway_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_normal_initializer(mean=0.0, stddev=np.sqrt(1.0 / highway_dim))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "get_variable_417": {
                "variable": {
                    "value": "b_transform",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b_transform",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[highway_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0.0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "DTYPE",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'float32'",
                            "str"
                        ]
                    ]
                }
            },
            "matmul_427": {
                "a": {
                    "value": "embedding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "make_convolutions(self.char_embedding)",
                            "Call"
                        ],
                        [
                            "tf.reshape(embedding, [-1, n_filters])",
                            "Call"
                        ],
                        [
                            "tf.matmul(embedding, W_proj_cnn) + b_proj_cnn",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(embedding, shp)",
                            "Call"
                        ],
                        [
                            "high(embedding, W_carry, b_carry, W_transform, b_transform)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "W_proj_cnn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W_proj', [n_filters, projection_dim], initializer=tf.random_normal_initializer(mean=0.0, stddev=np.sqrt(1.0 / n_filters)), dtype=DTYPE)",
                            "Call"
                        ]
                    ]
                }
            },
            "LSTMCell_496": {
                "variable": {
                    "value": "lstm_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "lstm_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm']['dim']",
                            "Subscript"
                        ]
                    ]
                },
                "num_proj": {
                    "value": "projection_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm']['projection_dim']",
                            "Subscript"
                        ],
                        [
                            "self.options['lstm']['projection_dim']",
                            "Subscript"
                        ],
                        [
                            "self.options['lstm']['projection_dim']",
                            "Subscript"
                        ]
                    ]
                },
                "cell_clip": {
                    "value": "cell_clip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm'].get('cell_clip')",
                            "Call"
                        ]
                    ]
                },
                "proj_clip": {
                    "value": "proj_clip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm'].get('proj_clip')",
                            "Call"
                        ]
                    ]
                }
            },
            "LSTMCell_500": {
                "variable": {
                    "value": "lstm_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "lstm_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm']['dim']",
                            "Subscript"
                        ]
                    ]
                },
                "cell_clip": {
                    "value": "cell_clip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm'].get('cell_clip')",
                            "Call"
                        ]
                    ]
                },
                "proj_clip": {
                    "value": "proj_clip",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.options['lstm'].get('proj_clip')",
                            "Call"
                        ]
                    ]
                }
            },
            "dynamic_rnn_538": {
                "variable": {
                    "value": "(layer_output, final_state)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cell": {
                    "value": "lstm_cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(lstm_dim, num_proj=projection_dim, cell_clip=cell_clip, proj_clip=proj_clip)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(lstm_dim, cell_clip=cell_clip, proj_clip=proj_clip)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.ResidualWrapper(lstm_cell)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "layer_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.embedding",
                            "Attribute"
                        ],
                        [
                            "tf.reverse_sequence(self.embedding, sequence_lengths, seq_axis=1, batch_axis=0)",
                            "Call"
                        ],
                        [
                            "layer_output",
                            "variable"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(mask, tf.int32), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "tf.nn.rnn_cell.LSTMStateTuple(*batch_init_states)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_117": {
                "values": {
                    "value": "[self._lm_graph.lstm_outputs['forward'][i], self._lm_graph.lstm_outputs['backward'][i]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "expand_dims_146": {
                "input": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_311": {
                "minval": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_331": {
                "variable": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": []
                },
                "minval": {
                    "value": "-0.05",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "matmul_393": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "ww_carry",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_394": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "ww_tr",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_401": {
                "name_or_scope": {
                    "value": "'CNN_high_%s' % i",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ResidualWrapper_512": {
                "variable": {
                    "value": "lstm_cell",
                    "type": "variable",
                    "possible_values": []
                },
                "cell": {
                    "value": "lstm_cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.rnn_cell.LSTMCell(lstm_dim, num_proj=projection_dim, cell_clip=cell_clip, proj_clip=proj_clip)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.LSTMCell(lstm_dim, cell_clip=cell_clip, proj_clip=proj_clip)",
                            "Call"
                        ],
                        [
                            "tf.nn.rnn_cell.ResidualWrapper(lstm_cell)",
                            "Call"
                        ]
                    ]
                }
            },
            "Variable_521": {
                "initial_value": {
                    "value": "tf.zeros([self._max_batch_size, dim])",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_537": {
                "name_or_scope": {
                    "value": "variable_scope_name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'RNN_{0}/RNN/MultiRNNCell/Cell{1}'.format(i_direction, i)",
                            "Call"
                        ]
                    ]
                }
            },
            "control_dependencies_561": {
                "control_inputs": {
                    "value": "[layer_output]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_564": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[final_state[i][:batch_size, :], init_states[i][batch_size:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "assign_567": {
                "variable": {
                    "value": "state_update_op",
                    "type": "variable",
                    "possible_values": []
                },
                "ref": {
                    "value": "init_states[i]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "value": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([final_state[i][:batch_size, :], init_states[i][batch_size:, :]], axis=0)",
                            "Call"
                        ]
                    ]
                }
            },
            "random_normal_initializer_335": {
                "variable": {
                    "value": "w_init",
                    "type": "variable",
                    "possible_values": []
                },
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / (width * char_embed_dim))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "conv2d_348": {
                "input": {
                    "value": "inp",
                    "type": "variable",
                    "possible_values": []
                },
                "filters": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('W_cnn_%s' % i, [1, width, char_embed_dim, num], initializer=w_init, dtype=DTYPE)",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "[1, 1, 1, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_normal_initializer_383": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / n_filters)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_388": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "zeros_522": {
                "shape": {
                    "value": "[self._max_batch_size, dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reverse_sequence_553": {
                "input": {
                    "value": "layer_output",
                    "type": "variable",
                    "possible_values": []
                },
                "seq_lengths": {
                    "value": "sequence_lengths",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.cast(mask, tf.int32), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "constant_initializer_346": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "random_normal_initializer_405": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / highway_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_410": {
                "value": {
                    "value": "-2.0",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "random_normal_initializer_414": {
                "mean": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                },
                "stddev": {
                    "value": "np.sqrt(1.0 / highway_dim)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_initializer_419": {
                "value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_542": {
                "c": {
                    "value": "*batch_init_states",
                    "type": "Starred",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/lm_qa_models.py": {
        "tensorflow": {
            "placeholder_113": {
                "variable": {
                    "value": "self._is_train_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_193": {
                "variable": {
                    "value": "q_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "q_embed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(q_embed, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_194": {
                "variable": {
                    "value": "c_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "c_embed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(c_embed, axis=2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_117": {
                "variable": {
                    "value": "self._question_char_ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, None)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_118": {
                "variable": {
                    "value": "self._context_char_ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, None)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_125": {
                "variable": {
                    "value": "self._question_char_ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, None, self._max_word_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "gather_nd_165": {
                "variable": {
                    "value": "c_lm_encoding",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "c_lm_encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c_lm_model.get_ops()['lm_embeddings']",
                            "Subscript"
                        ],
                        [
                            "tf.gather_nd(c_lm_encoding, input_tensors[self._context_sentence_ixs])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "input_tensors[self._context_sentence_ixs]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_289": {
                "values": {
                    "value": "[embed, context_lm_r]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "placeholder_128": {
                "variable": {
                    "value": "self._context_char_ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None, self._max_word_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_130": {
                "variable": {
                    "value": "self._context_sentence_ixs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, 3, None, 3)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_132": {
                "variable": {
                    "value": "self._context_char_ids_placeholder",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_size, None, self._max_word_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "variable_scope_156": {
                "name_or_scope": {
                    "value": "tf.get_variable_scope()",
                    "type": "Call",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_311": {
                "name_or_scope": {
                    "value": "build_memories",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_314": {
                "name_or_scope": {
                    "value": "apply_attention",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_321": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_scope_156": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_174": {
                "name_or_scope": {
                    "value": "char-embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "word-embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_281": {
                "name_or_scope": {
                    "value": "prefix + '_lm'",
                    "type": "BinOp",
                    "possible_values": []
                },
                "reuse": {
                    "value": "question",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_287": {
                "name_or_scope": {
                    "value": "prefix + '_' + kind_name + '_lm'",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_302": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_304": {
                "name_or_scope": {
                    "value": "map_embed",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_318": {
                "name_or_scope": {
                    "value": "process_attention",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/run_on_user_text.py": {
        "tensorflow": {
            "Session_52": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_59": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_collection_59": {
                "key": {
                    "value": "tf.GraphKeys.SAVEABLE_OBJECTS",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variables_initializer_65": {
                "var_list": {
                    "value": "[x for x in all_vars if x.name in lm_var_names]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "ConfigProto_52": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/elmo/show_weights.py": {
        "tensorflow": {
            "NewCheckpointReader_19": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_dir.get_best_weights()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/encoder.py": {
        "tensorflow": {
            "placeholder_42": {
                "variable": {
                    "value": "self.answer_spans",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, 2]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "answer_spans",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_93": {
                "variable": {
                    "value": "self.answer_starts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, context_word_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "answer_starts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_94": {
                "variable": {
                    "value": "self.answer_ends",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, context_word_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "answer_ends",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_128": {
                "variable": {
                    "value": "self.answer_starts",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, context_word_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "answer_starts",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_129": {
                "variable": {
                    "value": "self.answer_ends",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, context_word_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "answer_ends",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_130": {
                "variable": {
                    "value": "self.group_ids",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "group_ids",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_170": {
                "variable": {
                    "value": "self.correct_spans",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "bool",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, None]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "correct_span",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_260": {
                "variable": {
                    "value": "self.context_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_context_words]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "context_words",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_261": {
                "variable": {
                    "value": "self.context_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "context_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_263": {
                "variable": {
                    "value": "self.question_words",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_question_words]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "question_words",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_264": {
                "variable": {
                    "value": "self.question_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "question_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_267": {
                "variable": {
                    "value": "self.context_chars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_context_words, self.max_char_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "context_chars",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_268": {
                "variable": {
                    "value": "self.question_chars",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_question_words, self.max_char_dim]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "question_chars",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_269": {
                "variable": {
                    "value": "self.question_word_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_question_words]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "question_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_270": {
                "variable": {
                    "value": "self.context_word_len",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_context_words]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "context_len",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_278": {
                "variable": {
                    "value": "self.question_features",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_question_words, self.word_featurizer.n_question_features()]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "question_features",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_282": {
                "variable": {
                    "value": "self.context_features",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[batch_size, n_context_words, self.word_featurizer.n_context_features()]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "context_features",
                    "type": "str",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/eval/eval_squad_minimal.py": {
        "tensorflow": {
            "Session_39": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_46": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_48": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Saver_49": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "{ema.average_name(x): x for x in tf.trainable_variables()}",
                    "type": "DictComp",
                    "possible_values": []
                }
            },
            "trainable_variables_49": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "docqa/evaluator.py": {
        "tensorflow": {
            "get_collection_83": {
                "variable": {
                    "value": "regularizers",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FIFOQueue_455": {
                "variable": {
                    "value": "self.eval_queue",
                    "type": "Attribute",
                    "possible_values": []
                },
                "capacity": {
                    "value": "queue_size",
                    "type": "variable",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[x.dtype for x in placeholders]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "name": {
                    "value": "eval_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Summary_49": {
                "value": {
                    "value": "[tf.Summary.Value(tag=prefix + k, simple_value=v)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_74": {
                "inputs": {
                    "value": "tf.get_collection(tf.GraphKeys.LOSSES)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_collection_74": {
                "key": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_87": {
                "inputs": {
                    "value": "regularizers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/model.py": {
        "tensorflow": {}
    },
    "docqa/model_dir.py": {
        "tensorflow": {
            "Saver_88": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "var_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES) + tf.get_collection(tf.GraphKeys.SAVEABLE_OBJECTS)",
                            "BinOp"
                        ],
                        [
                            "{v.op.name: v for v in var_list if v not in ema_vars}",
                            "DictComp"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "latest_checkpoint_46": {
                "checkpoint_dir": {
                    "value": "self.save_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "NewCheckpointReader_78": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.get_best_weights()",
                            "Call"
                        ],
                        [
                            "self.get_latest_checkpoint()",
                            "Call"
                        ]
                    ]
                }
            },
            "ExponentialMovingAverage_79": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "latest_checkpoint_54": {
                "checkpoint_dir": {
                    "value": "self.best_weight_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_74": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_collection_75": {
                "key": {
                    "value": "tf.GraphKeys.SAVEABLE_OBJECTS",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/attention.py": {
        "tensorflow": {
            "matmul_43": {
                "variable": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "memories",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, mem_proj, [[2], [0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_87": {
                "variable": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "softmax_123": {
                "variable": {
                    "value": "query_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_126": {
                "variable": {
                    "value": "select_query",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "query_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "memories",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, mem_proj, [[2], [0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_max_135": {
                "variable": {
                    "value": "context_dist",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_136": {
                "variable": {
                    "value": "context_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "context_dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_max(dist_matrix, axis=2)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_137": {
                "variable": {
                    "value": "select_context",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ai,aik->ak",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "context_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(context_dist)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_138": {
                "variable": {
                    "value": "select_context",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "select_context",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('ai,aik->ak', context_probs, x)",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(select_context, 1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "matmul_180": {
                "variable": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "memories",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, mem_proj, [[2], [0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_218": {
                "variable": {
                    "value": "query_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "query_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x_feature_dim, self.n_heads, project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_223": {
                "variable": {
                    "value": "mem_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "mem_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x_feature_dim, self.n_heads, mem_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tensordot_225": {
                "variable": {
                    "value": "queries",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "query_proj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('query_proj', (x_feature_dim, self.n_heads, project_size), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_226": {
                "variable": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "key_proj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "query_proj",
                            "variable"
                        ],
                        [
                            "tf.get_variable('key_proj', (x_feature_dim, self.n_heads, project_size), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_235": {
                "variable": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bwhd,bkhd->bwkh",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "queries",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, query_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "queries + tf.get_variable('query_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_255": {
                "variable": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "tensordot_257": {
                "variable": {
                    "value": "memories",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "mem_proj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('mem_proj', (x_feature_dim, self.n_heads, mem_size), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_258": {
                "variable": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "bwhk,bkhd->bwhd",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ],
                        [
                            "dist_matrix / (tf.reduce_sum(dist_matrix, axis=2, keep_dims=True) + bias)",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist_matrix)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "memories",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, mem_proj, [[2], [0]])",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_260": {
                "variable": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "response",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(select_probs, memories)",
                            "Call"
                        ],
                        [
                            "self.merge.apply(is_train, response, x)",
                            "Call"
                        ],
                        [
                            "tf.matmul(select_probs, x)",
                            "Call"
                        ],
                        [
                            "self.merge.apply(is_train, response, x)",
                            "Call"
                        ],
                        [
                            "tf.matmul(select_probs, memories)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhk,bkhd->bwhd', select_probs, memories)",
                            "Call"
                        ],
                        [
                            "tf.reshape(response, (batch_size, x_word_dim, self.n_heads * mem_size))",
                            "Call"
                        ],
                        [
                            "self.merge.apply(is_train, x, response)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_size, x_word_dim, self.n_heads * mem_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_283": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "keys.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "get_keras_initialization(self.init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_285": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', keys.shape.as_list()[-1], dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', (keys.shape.as_list()[-1], self.n_encodings), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_287": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "exp_mask(dist, mask)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(dist)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "dist + tf.get_variable('bias', (1, 1, self.n_encodings), dtype=tf.float32, initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "bool_mask * bool_mask + (1 - bool_mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist, dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_289": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ajk,aj->ak",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "exp_mask(dist, mask)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(dist)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "dist + tf.get_variable('bias', (1, 1, self.n_encodings), dtype=tf.float32, initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "bool_mask * bool_mask + (1 - bool_mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist, dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_314": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(keys.shape.as_list()[-1], self.n_encodings)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "get_keras_initialization(self.init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_316": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', keys.shape.as_list()[-1], dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('weights', (keys.shape.as_list()[-1], self.n_encodings), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "softmax_324": {
                "variable": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "exp_mask(dist, mask)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(dist)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "dist + tf.get_variable('bias', (1, 1, self.n_encodings), dtype=tf.float32, initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "bool_mask * bool_mask + (1 - bool_mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist, dim=1)",
                            "Call"
                        ]
                    ]
                },
                "dim": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "einsum_326": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ajk,ajn->ank",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "dist",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "exp_mask(dist, mask)",
                            "Call"
                        ],
                        [
                            "tf.nn.softmax(dist)",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, weights, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "dist + tf.get_variable('bias', (1, 1, self.n_encodings), dtype=tf.float32, initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "bool_mask * bool_mask + (1 - bool_mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.nn.softmax(dist, dim=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_34": {
                "variable": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_38": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.get_variable('no-alignment-bias', initializer=tf.constant(-1.0, dtype=tf.float32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_39": {
                "variable": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_73": {
                "input": {
                    "value": "tf.eye(x_word_dim) * VERY_NEGATIVE_NUMBER",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_80": {
                "variable": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_83": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.get_variable('no-alignment-bias', initializer=tf.constant(-1.0, dtype=tf.float32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_84": {
                "variable": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_173": {
                "variable": {
                    "value": "select_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_175": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.get_variable('no-alignment-bias', initializer=tf.constant(-1.0, dtype=tf.float32))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "exp_176": {
                "variable": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_185": {
                "values": {
                    "value": "[x, response, x * response, x * tf.expand_dims(encoded, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_222": {
                "variable": {
                    "value": "key_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "key_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x_feature_dim, self.n_heads, project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_241": {
                "variable": {
                    "value": "query_bias_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "query_bias_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x_feature_dim, self.n_heads)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_242": {
                "variable": {
                    "value": "key_bias_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "query_bias_proj",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x_feature_dim, self.n_heads)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "expand_dims_249": {
                "input": {
                    "value": "tf.eye(x_word_dim) * VERY_NEGATIVE_NUMBER",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_252": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.n_heads, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_321": {
                "variable": {
                    "value": "bool_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(tf.sequence_mask(mask, tf.shape(x)[1]), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_24": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_25": {
                "input": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_69": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_116": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_117": {
                "input": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_141": {
                "values": {
                    "value": "[x, select_query, x * select_query, x * select_context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_143": {
                "values": {
                    "value": "[x, select_query, x * select_context]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_163": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_164": {
                "input": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x, key_proj, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "keys + tf.get_variable('key_bias', (1, 1, self.n_heads, project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x",
                            "variable"
                        ],
                        [
                            "self.key_mapper.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_182": {
                "name_or_scope": {
                    "value": "encode_keys",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_204": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_205": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_229": {
                "name": {
                    "value": "query_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.n_heads, project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_231": {
                "name": {
                    "value": "key_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.n_heads, project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_238": {
                "x": {
                    "value": "float(project_size)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_243": {
                "input": {
                    "value": "tf.tensordot(x, query_bias_proj, [[2], [0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_244": {
                "input": {
                    "value": "tf.tensordot(x, key_bias_proj, [[2], [0]])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_248": {
                "input": {
                    "value": "VERY_NEGATIVE_NUMBER * (1 - tf.cast(joint_mask, dist_matrix.dtype))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_318": {
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.n_encodings)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_31": {
                "x": {
                    "value": "joint_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, x_mask, x_word_dim, x_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(mask, mask, x_word_dim, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dist_matrix.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_38": {
                "name": {
                    "value": "no-alignment-bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(-1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_46": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "eye_73": {
                "num_rows": {
                    "value": "x_word_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "get_variable_83": {
                "name": {
                    "value": "no-alignment-bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(-1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variable_scope_90": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_130": {
                "values": {
                    "value": "[x, select_query, x * select_query]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_132": {
                "values": {
                    "value": "[x, select_query]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_170": {
                "x": {
                    "value": "joint_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, x_mask, x_word_dim, x_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(mask, mask, x_word_dim, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dist_matrix.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_175": {
                "name": {
                    "value": "no-alignment-bias",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant(-1.0, dtype=tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_243": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "query_bias_proj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('query_bias_proj', (x_feature_dim, self.n_heads), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_244": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "key_bias_proj",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('query_bias_proj', (x_feature_dim, self.n_heads), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_263": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_278": {
                "name_or_scope": {
                    "value": "map_keys",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_292": {
                "name_or_scope": {
                    "value": "post_process",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_309": {
                "name_or_scope": {
                    "value": "map_keys",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_321": {
                "x": {
                    "value": "tf.sequence_mask(mask, tf.shape(x)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_329": {
                "name_or_scope": {
                    "value": "post_process",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_40": {
                "input_tensor": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_77": {
                "x": {
                    "value": "joint_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, x_mask, x_word_dim, x_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(mask, mask, x_word_dim, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dist_matrix.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_85": {
                "input_tensor": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_122": {
                "x": {
                    "value": "joint_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, x_mask, x_word_dim, x_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(mask, mask, x_word_dim, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dist_matrix.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_177": {
                "input_tensor": {
                    "value": "dist_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "dist_matrix + bias",
                            "BinOp"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, x)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "self.sim.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "self.attention.get_scores(x, keys)",
                            "Call"
                        ],
                        [
                            "tf.exp(dist_matrix)",
                            "Call"
                        ],
                        [
                            "tf.einsum('bwhd,bkhd->bwkh', queries, keys)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_185": {
                "input": {
                    "value": "encoded",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder_layer.apply(is_train, keys, mem_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_230": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_232": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "eye_249": {
                "num_rows": {
                    "value": "x_word_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(x)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "zeros_initializer_252": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_319": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sequence_mask_321": {
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(x)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "constant_38": {
                "value": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_83": {
                "value": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_175": {
                "value": {
                    "value": "-1.0",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_248": {
                "x": {
                    "value": "joint_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, x_mask, x_word_dim, x_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(x_mask, mem_mask, x_word_dim, key_word_dim)",
                            "Call"
                        ],
                        [
                            "compute_attention_mask(mask, mask, x_word_dim, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dist_matrix.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_321": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/embedder.py": {
        "tensorflow": {
            "unique_169": {
                "variable": {
                    "value": "(all_words, out_id)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.concat([tf.reshape(x, (-1,)) for x in word_ixs], axis=0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "gather_170": {
                "variable": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(mat, all_words)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_emb_mat', (len(self._char_to_ix) + 1, self.char_dim), tf.float32, initializer=tf.random_uniform_initializer(-self.init_scale, self.init_scale))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self._word_emb_mat",
                            "Attribute"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_probs), lambda : mat)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_word, (mat.shape.as_list()[0], 1)), lambda : mat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.vstack(mat)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat, np.zeros((len(mat), 1), dtype=np.float32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "all_words",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "split_171": {
                "variable": {
                    "value": "partitions",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "out_id",
                    "type": "variable",
                    "possible_values": []
                },
                "num_or_size_splits": {
                    "value": "[tf.reduce_prod(tf.shape(x)) for x in word_ixs]",
                    "type": "ListComp",
                    "possible_values": []
                }
            },
            "zeros_111": {
                "variable": {
                    "value": "zero",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, self.char_dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_112": {
                "variable": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "char_emb_mat",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(len(self._char_to_ix) + 1, self.char_dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-self.init_scale, self.init_scale)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_114": {
                "variable": {
                    "value": "emb_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[zero, mat]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_245": {
                "variable": {
                    "value": "null_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_246": {
                "variable": {
                    "value": "unk_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "unk_embed",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "self.learn_unk",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-self.word_vec_init_scale, self.word_vec_init_scale)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_283": {
                "variable": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "matrix_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[null_embed, unk_embed]",
                            "List"
                        ],
                        [
                            "[null_embed]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_399": {
                "variable": {
                    "value": "null_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_450": {
                "variable": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "matrix_list",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[null_embed, unk_embed]",
                            "List"
                        ],
                        [
                            "[null_embed]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "embedding_lookup_117": {
                "params": {
                    "value": "emb_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([zero, mat], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_169": {
                "values": {
                    "value": "[tf.reshape(x, (-1,)) for x in word_ixs]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_172": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "char_ix[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "tf.shape(o)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_255": {
                "variable": {
                    "value": "tok_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(len(self._special_tokens), dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "token_embed",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-self.word_vec_init_scale, self.word_vec_init_scale)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cond_291": {
                "variable": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(mat, self.keep_probs)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : mat",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "cond_295": {
                "variable": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(mat, self.keep_word, (mat.shape.as_list()[0], 1))",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : mat",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "get_variable_405": {
                "variable": {
                    "value": "tok_embed",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(len(self._special_tokens), dim)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "token_embed",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.random_uniform_initializer(-self.word_vec_init_scale, self.word_vec_init_scale)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "random_normal_initializer_444": {
                "variable": {
                    "value": "init_fn",
                    "type": "variable",
                    "possible_values": []
                },
                "stddev": {
                    "value": "self.placeholder_stddev",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "embedding_lookup_119": {
                "params": {
                    "value": "emb_mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([zero, mat], axis=0)",
                            "Call"
                        ]
                    ]
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_prod_171": {
                "input_tensor": {
                    "value": "tf.shape(x)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_172": {
                "input": {
                    "value": "o",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "constant_281": {
                "value": {
                    "value": "np.vstack(mat)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_434": {
                "value": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(mat, all_words)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_emb_mat', (len(self._char_to_ix) + 1, self.char_dim), tf.float32, initializer=tf.random_uniform_initializer(-self.init_scale, self.init_scale))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self._word_emb_mat",
                            "Attribute"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_probs), lambda : mat)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_word, (mat.shape.as_list()[0], 1)), lambda : mat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.vstack(mat)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat, np.zeros((len(mat), 1), dtype=np.float32)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_446": {
                "name": {
                    "value": "placeholders",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_placeholders, mat.shape[1])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init_fn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "init",
                            "variable"
                        ],
                        [
                            "tf.random_normal_initializer(stddev=self.placeholder_stddev)",
                            "Call"
                        ]
                    ]
                }
            },
            "device_105": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_113": {
                "minval": {
                    "value": "-self.init_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.init_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_141": {
                "name_or_scope": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_143": {
                "name_or_scope": {
                    "value": "embedding",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reshape_169": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "char_ix[0]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "shape_171": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "char_ix[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "device_228": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_248": {
                "minval": {
                    "value": "-self.word_vec_init_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.word_vec_init_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "device_299": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "embedding_lookup_302": {
                "params": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "device_380": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_441": {
                "values": {
                    "value": "[out, tf.ones((self.n_placeholders, 1))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "device_456": {
                "device_name": {
                    "value": "/cpu:0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "embedding_lookup_459": {
                "params": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "variable_scope_149": {
                "name_or_scope": {
                    "value": "'embedding%d_%s' % (i, emb.name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_257": {
                "minval": {
                    "value": "-self.word_vec_init_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.word_vec_init_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_292": {
                "x": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(mat, all_words)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_emb_mat', (len(self._char_to_ix) + 1, self.char_dim), tf.float32, initializer=tf.random_uniform_initializer(-self.init_scale, self.init_scale))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self._word_emb_mat",
                            "Attribute"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_probs), lambda : mat)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_word, (mat.shape.as_list()[0], 1)), lambda : mat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.vstack(mat)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat, np.zeros((len(mat), 1), dtype=np.float32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_probs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dropout_296": {
                "x": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(mat, all_words)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('char_emb_mat', (len(self._char_to_ix) + 1, self.char_dim), tf.float32, initializer=tf.random_uniform_initializer(-self.init_scale, self.init_scale))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self._word_emb_mat",
                            "Attribute"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_probs), lambda : mat)",
                            "Call"
                        ],
                        [
                            "tf.cond(is_train, lambda : tf.nn.dropout(mat, self.keep_word, (mat.shape.as_list()[0], 1)), lambda : mat)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "np.vstack(mat)",
                            "Call"
                        ],
                        [
                            "np.concatenate([mat, np.zeros((len(mat), 1), dtype=np.float32)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "rate": {
                    "value": "self.keep_word",
                    "type": "Attribute",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "(mat.shape.as_list()[0], 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "embedding_lookup_300": {
                "params": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "random_uniform_initializer_407": {
                "minval": {
                    "value": "-self.word_vec_init_scale",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "maxval": {
                    "value": "self.word_vec_init_scale",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "embedding_lookup_457": {
                "params": {
                    "value": "self._word_emb_mat",
                    "type": "Attribute",
                    "possible_values": []
                },
                "ids": {
                    "value": "x[0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_441": {
                "shape": {
                    "value": "(self.n_placeholders, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/layers.py": {
        "tensorflow": {
            "get_29": {
                "identifier": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_variable_167": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "project_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x.shape.as_list()[-1], out.shape.as_list()[-1])",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_200": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "prelu",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(self.init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_226": {
                "variable": {
                    "value": "w1",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(tensor1.shape.as_list()[-1], self.n_project)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tensordot_227": {
                "variable": {
                    "value": "project1",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tensor1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w1', (tensor1.shape.as_list()[-1], self.n_project), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w1', (tensor1.shape.as_list()[-1], tensor2.shape.as_list()[-1]), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[len(tensor1.shape) - 1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_231": {
                "variable": {
                    "value": "w2",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(tensor2.shape.as_list()[-1], self.n_project)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tensordot_232": {
                "variable": {
                    "value": "project2",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tensor2",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w2', (tensor2.shape.as_list()[-1], self.n_project), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[len(tensor1.shape) - 1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_251": {
                "variable": {
                    "value": "w1",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(tensor1.shape.as_list()[-1], tensor2.shape.as_list()[-1])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tensordot_252": {
                "variable": {
                    "value": "project1",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tensor1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "w1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('w1', (tensor1.shape.as_list()[-1], self.n_project), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w1', (tensor1.shape.as_list()[-1], tensor2.shape.as_list()[-1]), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[len(tensor1.shape) - 1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_418": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(s,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(s / 3.0)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_420": {
                "variable": {
                    "value": "b",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "b",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_436": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(d1, d2, self.n_out)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_503": {
                "variable": {
                    "value": "tiled_c",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(c, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(x)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_522": {
                "variable": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "merge_x_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x.shape.as_list()[-1], self.output_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_523": {
                "variable": {
                    "value": "c_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "merge_context_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(c.shape.as_list()[-1], self.output_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_530": {
                "variable": {
                    "value": "bais",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "merge_bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.output_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "get_variable_543": {
                "variable": {
                    "value": "c_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "context_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(c.shape.as_list()[-1], self.n_out)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "get_keras_initialization(self.init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_545": {
                "variable": {
                    "value": "c_projected",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dropout(c, self.context_keep_probs, is_train)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "c_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('merge_context_weights', (c.shape.as_list()[-1], self.output_size), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('context_weights', shape=(c.shape.as_list()[-1], self.n_out), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_547": {
                "variable": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "input_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x.shape.as_list()[-1], self.n_out)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "get_keras_initialization(self.init)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_549": {
                "variable": {
                    "value": "x_proj",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('merge_x_weights', (x.shape.as_list()[-1], self.output_size), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('input_weights', shape=(x.shape.as_list()[-1], self.n_out), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_578": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_588": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_607": {
                "variable": {
                    "value": "filter_",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1d/filters",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, self.filter_size, num_channels, self.num_filters]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_variable_608": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "conv1d/bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[self.num_filters]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tile_788": {
                "variable": {
                    "value": "tiled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tensor2, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(tensor1)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_799": {
                "variable": {
                    "value": "project_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "project_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(tensor1.shape.as_list()[-1], context_size)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "tensordot_800": {
                "variable": {
                    "value": "projected",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tensor1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "project_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project_w', (tensor1.shape.as_list()[-1], context_size))",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_25": {
                "identifier": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "where_192": {
                "condition": {
                    "value": "x > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "x * self.reduce_factor",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "expand_dims_203": {
                "variable": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project_w', (x.shape.as_list()[-1], out.shape.as_list()[-1]))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('prelu', x.shape.as_list()[-1], initializer=tf.constant_initializer(self.init))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(w, 0)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (s,), dtype=tf.float32, initializer=tf.constant_initializer(s / 3.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (d1, d2, self.n_out), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_204": {
                "condition": {
                    "value": "x > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "x * w",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_209": {
                "values": {
                    "value": "[tensor1, tensor2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(tensor1.shape) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_214": {
                "values": {
                    "value": "[tensor1, tensor2, tensor1 * tensor2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "len(tensor1.shape) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_240": {
                "values": {
                    "value": "elements",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tensor1, tensor2, project1 * project2]",
                            "List"
                        ],
                        [
                            "[tensor1, project1]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "len(tensor1.shape) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_261": {
                "values": {
                    "value": "elements",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[tensor1, tensor2, project1 * project2]",
                            "List"
                        ],
                        [
                            "[tensor1, project1]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "len(tensor1.shape) - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_427": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensordot_437": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project_w', (x.shape.as_list()[-1], out.shape.as_list()[-1]))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('prelu', x.shape.as_list()[-1], initializer=tf.constant_initializer(self.init))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(w, 0)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (s,), dtype=tf.float32, initializer=tf.constant_initializer(s / 3.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (d1, d2, self.n_out), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[1, 3], [0, 1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_526": {
                "variable": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "aij,aj->aij",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dropout(c, self.context_keep_probs, is_train)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_527": {
                "variable": {
                    "value": "dot_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "dot_weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(c.shape.as_list()[-1], self.output_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "0",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_553": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_out",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_627": {
                "variable": {
                    "value": "shape",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_628": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "tf.reshape(mask, (-1,))",
                    "type": "Call",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "shape[-2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_629": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reshape(mask, (shape[0], shape[1], shape[2], 1))",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_660": {
                "variable": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.cast(tf.sequence_mask(mask, tf.shape(x)[1]), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_706": {
                "variable": {
                    "value": "prediction1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_logits1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(tf.squeeze(logits1, squeeze_dims=[2]), context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "einsum_714": {
                "variable": {
                    "value": "soft_select",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ai,aik->ak",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "prediction1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.softmax(masked_logits1)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.first_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "self.first_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "self.start_layer.apply(is_train, context_embed, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_715": {
                "variable": {
                    "value": "soft_select_tiled",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(soft_select, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(m1)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_746": {
                "variable": {
                    "value": "valid_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(mask, tf.shape(x)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_783": {
                "values": {
                    "value": "[tensor1, tf.expand_dims(tensor2, 1) * tensor1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_789": {
                "values": {
                    "value": "[tensor1, tiled]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_805": {
                "values": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.other.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "fully_connected(x, self.n_out, use_bias=bias, activation=None, kernel_initializer=get_keras_initialization(self.w_init))",
                            "Call"
                        ],
                        [
                            "fully_connected(x, x.shape.as_list()[-1], use_bias=bias, activation=get_keras_activation(self.activation), kernel_initializer=get_keras_initialization(self.w_init))",
                            "Call"
                        ],
                        [
                            "out + x",
                            "BinOp"
                        ],
                        [
                            "[tensor1, projected * tf.expand_dims(tensor2, 1)]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensordot_168": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project_w', (x.shape.as_list()[-1], out.shape.as_list()[-1]))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('prelu', x.shape.as_list()[-1], initializer=tf.constant_initializer(self.init))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(w, 0)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (s,), dtype=tf.float32, initializer=tf.constant_initializer(s / 3.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (d1, d2, self.n_out), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[len(x.shape) - 1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_178": {
                "name_or_scope": {
                    "value": "map",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_181": {
                "values": {
                    "value": "[x, mapped]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_334": {
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, x.shape.as_list()[-1])",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tensordot_422": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project_w', (x.shape.as_list()[-1], out.shape.as_list()[-1]))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('prelu', x.shape.as_list()[-1], initializer=tf.constant_initializer(self.init))",
                            "Call"
                        ],
                        [
                            "tf.expand_dims(w, 0)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (s,), dtype=tf.float32, initializer=tf.constant_initializer(s / 3.0))",
                            "Call"
                        ],
                        [
                            "tf.get_variable('w', (d1, d2, self.n_out), dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[1], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "variable_scope_446": {
                "name_or_scope": {
                    "value": "part1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_448": {
                "name_or_scope": {
                    "value": "part2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_459": {
                "name_or_scope": {
                    "value": "out",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_461": {
                "name_or_scope": {
                    "value": "chained-out",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_493": {
                "name_or_scope": {
                    "value": "build-memories",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_503": {
                "input": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dropout(c, self.context_keep_probs, is_train)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_504": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "tensordot_524": {
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('merge_x_weights', (x.shape.as_list()[-1], self.output_size), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('input_weights', shape=(x.shape.as_list()[-1], self.n_out), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_524": {
                "input": {
                    "value": "tf.matmul(c, c_w)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tensordot_528": {
                "a": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('aij,aj->aij', x, c)",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "b": {
                    "value": "dot_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('dot_weights', (c.shape.as_list()[-1], self.output_size), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_550": {
                "input": {
                    "value": "c_projected",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(c, c_w)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_555": {
                "input": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.bias is None or self.bias",
                            "BoolOp"
                        ],
                        [
                            "self.bias is None or self.bias",
                            "BoolOp"
                        ],
                        [
                            "self.bias is None or self.bias",
                            "BoolOp"
                        ],
                        [
                            "tf.get_variable('bias', shape=self.n_out, dtype=tf.float32, initializer=tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.get_variable('conv1d/bias', shape=[self.num_filters], dtype='float')",
                            "Call"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "maximum_639": {
                "x": {
                    "value": "tf.reduce_max(x, axis=rank)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.fill([1] * (len(x.shape) - 1), float(self.min_val))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_642": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_max_669": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_699": {
                "name_or_scope": {
                    "value": "start_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_702": {
                "name_or_scope": {
                    "value": "start_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_718": {
                "name_or_scope": {
                    "value": "end_layer",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_721": {
                "name_or_scope": {
                    "value": "end_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "expand_dims_788": {
                "input": {
                    "value": "tensor2",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_183": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_201": {
                "value": {
                    "value": "self.init",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_281": {
                "name_or_scope": {
                    "value": "activation",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_347": {
                "identifier": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_383": {
                "name_or_scope": {
                    "value": "'layer_' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "variable_scope_397": {
                "name_or_scope": {
                    "value": "'layer_' + str(i)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "constant_initializer_419": {
                "value": {
                    "value": "s / 3.0",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "zeros_initializer_421": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "concat_462": {
                "values": {
                    "value": "[x, m1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_475": {
                "name_or_scope": {
                    "value": "map",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_477": {
                "name_or_scope": {
                    "value": "map",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "matmul_524": {
                "a": {
                    "value": "c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dropout(c, self.context_keep_probs, is_train)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "c_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('merge_context_weights', (c.shape.as_list()[-1], self.output_size), initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('context_weights', shape=(c.shape.as_list()[-1], self.n_out), dtype=tf.float32, initializer=get_keras_initialization(self.init))",
                            "Call"
                        ]
                    ]
                }
            },
            "conv2d_613": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "filters": {
                    "value": "filter_",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('conv1d/filters', shape=[1, self.filter_size, num_channels, self.num_filters], dtype='float')",
                            "Call"
                        ]
                    ]
                },
                "strides": {
                    "value": "strides",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1, 1, 1, 1]",
                            "List"
                        ]
                    ]
                },
                "padding": {
                    "value": "VALID",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reshape_628": {
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reshape_629": {
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(shape[0], shape[1], shape[2], 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_max_639": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "fill_639": {
                "dims": {
                    "value": "[1] * (len(x.shape) - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "value": {
                    "value": "float(self.min_val)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_660": {
                "x": {
                    "value": "tf.sequence_mask(mask, tf.shape(x)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_703": {
                "values": {
                    "value": "[m1, context_embed]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_705": {
                "input": {
                    "value": "logits1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fully_connected(tf.concat([m1, context_embed], axis=2), 1, activation=None, kernel_initializer=init_fn)",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_715": {
                "input": {
                    "value": "soft_select",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('ai,aik->ak', prediction1, m1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_719": {
                "values": {
                    "value": "m2_input",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "m2_input + [soft_select_tiled, soft_select_tiled * m1]",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_722": {
                "values": {
                    "value": "[m2, context_embed]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_746": {
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(x)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "expand_dims_748": {
                "input": {
                    "value": "valid_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(mask, tf.shape(x)[1]), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "axis": {
                    "value": "len(valid_mask.shape)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_760": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_801": {
                "input": {
                    "value": "tensor2",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_803": {
                "input": {
                    "value": "tf.expand_dims(tensor2, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, tf.shape(tensor1)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_304": {
                "identifier": {
                    "value": "self.w_init",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_334": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_348": {
                "identifier": {
                    "value": "self.w_init",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_initializer_358": {
                "value": {
                    "value": "self.bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_483": {
                "name_or_scope": {
                    "value": "'map%d_%s' % (i, x.name)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_503": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "zeros_initializer_554": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "sequence_mask_660": {
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(x)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_674": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_766": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_sum_770": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "expand_dims_783": {
                "input": {
                    "value": "tensor2",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_788": {
                "input": {
                    "value": "tensor1",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "expand_dims_803": {
                "input": {
                    "value": "tensor2",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_672": {
                "input_tensor": {
                    "value": "x * answer_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_672": {
                "x": {
                    "value": "tf.expand_dims(mask, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_677": {
                "input_tensor": {
                    "value": "x * answer_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_679": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_715": {
                "input": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.first_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "self.first_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "self.start_layer.apply(is_train, context_embed, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_746": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_764": {
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "rank",
                    "type": "variable",
                    "possible_values": [
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ],
                        [
                            "len(x.shape) - 2",
                            "BinOp"
                        ]
                    ]
                }
            },
            "cast_764": {
                "x": {
                    "value": "tf.expand_dims(mask, 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "shape_660": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * valid_mask",
                            "BinOp"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "dropout(x, self.keep_probs, is_train)",
                            "Call"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ],
                        [
                            "x * mask + self.min_val * (1 - mask)",
                            "BinOp"
                        ],
                        [
                            "self.map_layer.apply(is_train, x, mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_672": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_764": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(tf.reshape(mask, (-1,)), shape[-2])",
                            "Call"
                        ],
                        [
                            "tf.cast(tf.reshape(mask, (shape[0], shape[1], shape[2], 1)), tf.float32)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_803": {
                "input": {
                    "value": "tensor1",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/ops.py": {
        "tensorflow": {
            "stop_gradient_15": {
                "variable": {
                    "value": "maxs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.reduce_max(xs, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "segment_max_16": {
                "variable": {
                    "value": "segment_maxes",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "maxs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stop_gradient(tf.reduce_max(xs, axis=1))",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segments",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_sum_18": {
                "variable": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.exp(xs)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_23": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.sequence_mask(mask, tf.shape(val)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cond_9": {
                "pred": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "true_fn": {
                    "value": "lambda : tf.nn.dropout(x, keep_prob, noise_shape=noise_shape, seed=seed)",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : x",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "expand_dims_17": {
                "input": {
                    "value": "tf.gather(segment_maxes, segments)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_15": {
                "input_tensor": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xs - tf.expand_dims(tf.gather(segment_maxes, segments), 1)",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_17": {
                "params": {
                    "value": "segment_maxes",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.segment_max(maxs, segments)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "segments",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "exp_18": {
                "x": {
                    "value": "xs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "xs - tf.expand_dims(tf.gather(segment_maxes, segments), 1)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_19": {
                "x": {
                    "value": "tf.segment_sum(sums, segments)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sequence_mask_23": {
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(tf.sequence_mask(mask, tf.shape(val)[1]), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(val)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "dropout_9": {
                "x": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "rate": {
                    "value": "keep_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "noise_shape": {
                    "value": "noise_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seed": {
                    "value": "seed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "segment_sum_19": {
                "data": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.exp(xs), axis=1)",
                            "Call"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "segments",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_23": {
                "input": {
                    "value": "val",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/recurrent_layers.py": {
        "tensorflow": {
            "get_variable_scope_276": {
                "variable": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_variable_90": {
                "variable": {
                    "value": "parameters",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "gru_parameters",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "n_params",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell.params_size().eval()",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_128": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_139": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell(x, initial_state_h, initial_state_c, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell(x, initial_state, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell.canonical_to_params(init_weights, init_biases)",
                            "Call"
                        ],
                        [
                            "self._apply_transposed(is_train, x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "out * tf.expand_dims(tf.cast(tf.sequence_mask(mask, tf.shape(out)[1]), tf.float32), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_205": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "transpose_232": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(inputs, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_241": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fw, bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "transpose_242": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell(x, initial_state_h, initial_state_c, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell(x, initial_state, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell.canonical_to_params(init_weights, init_biases)",
                            "Call"
                        ],
                        [
                            "self._apply_transposed(is_train, x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "out * tf.expand_dims(tf.cast(tf.sequence_mask(mask, tf.shape(out)[1]), tf.float32), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "perm": {
                    "value": "[1, 0, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_254": {
                "variable": {
                    "value": "flattened",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[-1, lst[-2], lst[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_264": {
                "variable": {
                    "value": "enc",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "encoding",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.enc.apply(is_train, flattened, mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[batch, -1, encoding.shape.as_list()[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_278": {
                "variable": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "weights",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[args.shape.as_list()[-1], output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "weight_init",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "matmul_280": {
                "variable": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "args",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "weights",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('weights', [args.shape.as_list()[-1], output_size], dtype=dtype, initializer=weight_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_428": {
                "variable": {
                    "value": "tile_arr",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "[batch_size, 1]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TruncatedNormal_28": {
                "stddev": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "cond_103": {
                "variable": {
                    "value": "parameters",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : tf.floor(tf.random_uniform((n_params,)) + recurrent_mask) * parameters",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : parameters",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "concat_136": {
                "variable": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[fw, bw]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "TruncatedNormal_150": {
                "stddev": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "TruncatedNormal_178": {
                "stddev": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            },
            "concat_208": {
                "variable": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "LSTMBlockFusedCell(self.n_units)(x, dtype=tf.float32, sequence_length=mask)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.concat(state, 1)",
                            "Call"
                        ],
                        [
                            "state.h",
                            "Attribute"
                        ],
                        [
                            "state.c",
                            "Attribute"
                        ],
                        [
                            "dynamic_rnn(self.cell_spec(is_train), x, mask, dtype=tf.float32)[1]",
                            "Subscript"
                        ],
                        [
                            "states",
                            "variable"
                        ],
                        [
                            "False",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reverse_sequence_238": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(inputs, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reverse_sequence_240": {
                "variable": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, tf.reverse_sequence(x, mask, 0, 1))[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, 0, 1)",
                            "Call"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ],
                        [
                            "bw_spec(is_train)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reshape_259": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "variable_scope_277": {
                "name_or_scope": {
                    "value": "scope",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable_scope()",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_285": {
                "variable": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "biases",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[output_size]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "args.dtype",
                            "Attribute"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initializer": {
                    "value": "bias_init",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "bias_add_289": {
                "value": {
                    "value": "res",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(args, weights)",
                            "Call"
                        ]
                    ]
                },
                "bias": {
                    "value": "biases",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('biases', [output_size], dtype=dtype, initializer=bias_init)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_304": {
                "values": {
                    "value": "[kernel_init(kernal_shape, dtype), recurrent_init(recurrent_shape, dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_314": {
                "values": {
                    "value": "[i(shape, dtype) for i in inits]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_316": {
                "values": {
                    "value": "[input, hidden]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "split_322": {
                "value": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_linear(tf.concat([input, hidden], axis=1), 4 * num_units, True, bias_init=_init_stacked_bias, weight_init=_init_stacked_weights)",
                            "Call"
                        ],
                        [
                            "_compute_gates(inputs, h, self.num_units, self.forget_bias, self.kernel_initializer, self.recurrent_initializer, True)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_355": {
                "c": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "h": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "split_369": {
                "variable": {
                    "value": "(i, j, f, o)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "mat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "_linear(tf.concat([input, hidden], axis=1), 4 * num_units, True, bias_init=_init_stacked_bias, weight_init=_init_stacked_weights)",
                            "Call"
                        ],
                        [
                            "_compute_gates(inputs, h, self.num_units, self.forget_bias, self.kernel_initializer, self.recurrent_initializer, True)",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "4",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_375": {
                "variable": {
                    "value": "new_state",
                    "type": "variable",
                    "possible_values": []
                },
                "c": {
                    "value": "new_c",
                    "type": "variable",
                    "possible_values": [
                        [
                            "c * self.recurrent_activation(f) + self.recurrent_activation(i) * self.activation(j)",
                            "BinOp"
                        ]
                    ]
                },
                "h": {
                    "value": "new_h",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.activation(new_c) * self.recurrent_activation(o)",
                            "BinOp"
                        ],
                        [
                            "u * state + (1 - u) * c",
                            "BinOp"
                        ]
                    ]
                }
            },
            "sigmoid_409": {
                "variable": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "_linear(tf.concat([inputs, state], axis=1), self.num_units * 2, True, self.bias_init, _init_stacked_weights)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "split_411": {
                "variable": {
                    "value": "(r, u)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "value",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sigmoid(_linear(tf.concat([inputs, state], axis=1), self.num_units * 2, True, self.bias_init, _init_stacked_weights))",
                            "Call"
                        ]
                    ]
                },
                "num_or_size_splits": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_variable_436": {
                "variable": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "'initial_state_%s' % state_size._fields[i]",
                            "BinOp"
                        ],
                        [
                            "'initial_state_%d' % i",
                            "BinOp"
                        ]
                    ]
                },
                "shape": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_467": {
                "c": {
                    "value": "variables[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "h": {
                    "value": "variables[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_499": {
                "c": {
                    "value": "variables[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "h": {
                    "value": "variables[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "GRUBlockCell_502": {
                "x": {
                    "value": "self.num_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "LSTMStateTuple_523": {
                "c": {
                    "value": "variables[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "h": {
                    "value": "variables[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "zeros_63": {
                "shape": {
                    "value": "[n_params]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_111": {
                "variable": {
                    "value": "initial_state_h",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_layers, tf.shape(x)[1], self.n_units)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_112": {
                "variable": {
                    "value": "initial_state_c",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_layers, tf.shape(x)[1], self.n_units)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_116": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "initial_state",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.n_units",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "tile_118": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(tf.expand_dims(initial_state, 0), 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[self.n_layers, tf.shape(x)[1], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_121": {
                "variable": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_layers, tf.shape(x)[1], self.n_units)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reverse_sequence_135": {
                "variable": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, tf.reverse_sequence(x, mask, 0, 1))[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, 0, 1)",
                            "Call"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ],
                        [
                            "bw_spec(is_train)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_141": {
                "input": {
                    "value": "tf.cast(tf.sequence_mask(mask, tf.shape(out)[1]), tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_233": {
                "name_or_scope": {
                    "value": "forward",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_236": {
                "name_or_scope": {
                    "value": "backward",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_253": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_283": {
                "name_or_scope": {
                    "value": "outer_scope",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_initializer_313": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_313": {
                "value": {
                    "value": "forget_bias",
                    "type": "variable",
                    "possible_values": [
                        [
                            "1.0",
                            "Method Argument"
                        ],
                        [
                            "1.0",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "variable_scope_362": {
                "name_or_scope": {
                    "value": "self.scope",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "variable_scope_400": {
                "name_or_scope": {
                    "value": "gru",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_412": {
                "name_or_scope": {
                    "value": "candidate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "constant_initializer_530": {
                "value": {
                    "value": "self.bais_init",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "dynamic_rnn_549": {
                "cell": {
                    "value": "self.cell_spec(is_train)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_570": {
                "cell_fw": {
                    "value": "self.cell_spec(is_train)",
                    "type": "Call",
                    "possible_values": []
                },
                "cell_bw": {
                    "value": "self.cell_spec(is_train)",
                    "type": "Call",
                    "possible_values": []
                },
                "inputs": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_579": {
                "values": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "dynamic_rnn_597": {
                "cell": {
                    "value": "cell",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cudnn_rnn_ops.CudnnGRU(self.n_layers, self.n_units, x_size, input_mode='linear_input')",
                            "Call"
                        ],
                        [
                            "cudnn_rnn_ops.CudnnLSTM(self.n_layers, self.n_units, x_size, input_mode='linear_input')",
                            "Call"
                        ],
                        [
                            "LSTMBlockFusedCell(self.n_units, use_peephole=self.use_peepholes)",
                            "Call"
                        ],
                        [
                            "LSTMBlockFusedCell(self.n_units, use_peephole=self.use_peepholes)",
                            "Call"
                        ],
                        [
                            "InitializedLSTMCell(self.num_units, kernel_initializer, recurrent_initializer, activation, recurrent_activation, self.forget_bias, self.keep_recurrent_probs, is_train, scope)",
                            "Call"
                        ],
                        [
                            "self.cell_spec(is_train)",
                            "Call"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(inputs, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "initial_state": {
                    "value": "initial",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "self.cell_spec.build_initial_state_var(batch_size, cell)",
                            "Call"
                        ],
                        [
                            "None",
                            "NoneType"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_613": {
                "values": {
                    "value": "bidirectional_dynamic_rnn(fw, bw, inputs, mask, swap_memory=self.swap_memory, dtype=tf.float32)[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_131": {
                "name_or_scope": {
                    "value": "forward",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_133": {
                "name_or_scope": {
                    "value": "backward",
                    "type": "str",
                    "possible_values": []
                }
            },
            "cast_141": {
                "x": {
                    "value": "tf.sequence_mask(mask, tf.shape(out)[1])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_407": {
                "values": {
                    "value": "[self.kernal_init(kernal_shape, dtype), self.recurrent_init(recurrent_shape, dtype)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_437": {
                "input": {
                    "value": "tf.expand_dims(var, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "tile_arr",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant([batch_size, 1], dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "bidirectional_dynamic_rnn_616": {
                "cell_fw": {
                    "value": "fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, x)[0]",
                            "Subscript"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "self.fw(is_train)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, tf.reverse_sequence(x, mask, 0, 1))[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, 0, 1)",
                            "Call"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ],
                        [
                            "bw_spec(is_train)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(inputs, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "self.swap_memory",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_76": {
                "value": {
                    "value": "self.lstm_bias / 2.0",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(self.n_units,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "zeros_76": {
                "shape": {
                    "value": "self.n_units",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "ones_like_100": {
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "zeros_initializer_117": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_118": {
                "input": {
                    "value": "initial_state",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('initial_state', self.n_units, tf.float32, tf.zeros_initializer())",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(tf.expand_dims(initial_state, 0), 0), [self.n_layers, tf.shape(x)[1], 1])",
                            "Call"
                        ],
                        [
                            "tf.zeros((self.n_layers, tf.shape(x)[1], self.n_units), tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_141": {
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(out)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_409": {
                "values": {
                    "value": "[inputs, state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_413": {
                "values": {
                    "value": "[inputs, r * state]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_initializer_414": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "expand_dims_437": {
                "input": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable(name, s, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "bidirectional_dynamic_rnn_613": {
                "cell_fw": {
                    "value": "fw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, x)[0]",
                            "Subscript"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "self.fw(is_train)",
                            "Call"
                        ]
                    ]
                },
                "cell_bw": {
                    "value": "bw",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._apply_transposed(is_train, tf.reverse_sequence(x, mask, 0, 1))[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, 0, 1)",
                            "Call"
                        ],
                        [
                            "cell(inputs, dtype=tf.float32, sequence_length=mask)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.reverse_sequence(bw, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ],
                        [
                            "bw_spec(is_train)",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(inputs, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.reverse_sequence(inputs, mask, seq_axis=0, batch_axis=1)",
                            "Call"
                        ]
                    ]
                },
                "sequence_length": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "swap_memory": {
                    "value": "self.swap_memory",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reshape_82": {
                "tensor": {
                    "value": "r_init((self.n_units, self.n_units), w.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "tf.shape(w)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "floor_104": {
                "x": {
                    "value": "tf.random_uniform((n_params,)) + recurrent_mask",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reverse_sequence_134": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                },
                "seq_lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "NoneType"
                        ],
                        [
                            "tf.reshape(mask, (-1,))",
                            "Call"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "True",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "seq_axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "batch_axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_82": {
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_84": {
                "input": {
                    "value": "w",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "shape_111": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_112": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_119": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_121": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "tf.transpose(x, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_141": {
                "input": {
                    "value": "out",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cell(x, initial_state_h, initial_state_c, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell(x, initial_state, parameters, True)",
                            "Call"
                        ],
                        [
                            "cell.canonical_to_params(init_weights, init_biases)",
                            "Call"
                        ],
                        [
                            "self._apply_transposed(is_train, x)[0]",
                            "Subscript"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ],
                        [
                            "out * tf.expand_dims(tf.cast(tf.sequence_mask(mask, tf.shape(out)[1]), tf.float32), 2)",
                            "BinOp"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.concat([fw, bw], axis=2)",
                            "Call"
                        ],
                        [
                            "tf.transpose(out, [1, 0, 2])",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/nn/similarity_layers.py": {
        "tensorflow": {
            "sequence_mask_14": {
                "variable": {
                    "value": "x_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "x_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(x_mask, x_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "x_word_dim",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "sequence_mask_15": {
                "variable": {
                    "value": "mem_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "mem_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mem_mask, key_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "key_word_dim",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "logical_and_16": {
                "variable": {
                    "value": "join_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(x_mask, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(mem_mask, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "matmul_56": {
                "variable": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "tensor_1",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "tensor_2",
                    "type": "variable",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_80": {
                "variable": {
                    "value": "project1",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "project1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x1.shape.as_list()[-1], self.project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "tensordot_81": {
                "variable": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x1, project1, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "x1 + tf.get_variable('bias1', (1, 1, self.project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "project1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project1', (x1.shape.as_list()[-1], self.project_size), initializer=init)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_89": {
                "variable": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x2, project2, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "x2 + tf.get_variable('bias2', (1, 1, self.project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "project2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('project2', (x2.shape.as_list()[-1], self.project_size), initializer=init)",
                            "Call"
                        ],
                        [
                            "project1",
                            "variable"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "matmul_95": {
                "variable": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x1, project1, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "x1 + tf.get_variable('bias1', (1, 1, self.project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "x2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(x2, project2, [[2], [0]])",
                            "Call"
                        ],
                        [
                            "x2 + tf.get_variable('bias2', (1, 1, self.project_size), initializer=tf.zeros_initializer())",
                            "BinOp"
                        ]
                    ]
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_variable_109": {
                "variable": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "key_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "keys.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_110": {
                "variable": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=(keys.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_112": {
                "variable": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "x_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_113": {
                "variable": {
                    "value": "x_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('x_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "key_w",
                            "variable"
                        ],
                        [
                            "tf.get_variable('x_w', shape=(x.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('input_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_131": {
                "variable": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "key_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(keys.shape.as_list()[-1], self.projected_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_132": {
                "variable": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=(keys.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensordot_139": {
                "variable": {
                    "value": "x_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('x_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "key_w",
                            "variable"
                        ],
                        [
                            "tf.get_variable('x_w', shape=(x.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('input_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_145": {
                "variable": {
                    "value": "combine_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "combine_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "self.projected_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_159": {
                "variable": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "key_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "keys.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_160": {
                "variable": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "key_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=(keys.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('key_w', shape=keys.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_162": {
                "variable": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "input_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_163": {
                "variable": {
                    "value": "x_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "b": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('x_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "key_w",
                            "variable"
                        ],
                        [
                            "tf.get_variable('x_w', shape=(x.shape.as_list()[-1], self.projected_size), initializer=init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.get_variable('input_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[2], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_165": {
                "variable": {
                    "value": "dot_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "dot_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape.as_list()[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "matmul_169": {
                "variable": {
                    "value": "dot_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "x_dots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x * tf.expand_dims(tf.expand_dims(dot_w, 0), 0)",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "keys",
                    "type": "variable",
                    "possible_values": []
                },
                "transpose_b": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "expand_dims_16": {
                "input": {
                    "value": "mem_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mem_mask, key_word_dim)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_29": {
                "input": {
                    "value": "self.get_scores(tf.expand_dims(tensor_1, 1), tensor_2)",
                    "type": "Call",
                    "possible_values": []
                },
                "squeeze_dims": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "get_variable_40": {
                "variable": {
                    "value": "bias",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "bias",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_variable_88": {
                "variable": {
                    "value": "project2",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "project2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x2.shape.as_list()[-1], self.project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_variable_137": {
                "variable": {
                    "value": "x_w",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "x_w",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(x.shape.as_list()[-1], self.projected_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "get_keras_initialization(self.init)",
                            "Call"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ],
                        [
                            "'glorot_uniform'",
                            "Method Argument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tensordot_147": {
                "a": {
                    "value": "summed",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(x_logits, axis=2) + tf.expand_dims(key_logits, axis=1)",
                            "BinOp"
                        ],
                        [
                            "get_keras_activation(self.activation)(summed)",
                            "Call"
                        ]
                    ]
                },
                "b": {
                    "value": "combine_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('combine_w', shape=self.projected_size, initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axes": {
                    "value": "[[3], [0]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_60": {
                "variable": {
                    "value": "last_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(dots)[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sqrt_61": {
                "x": {
                    "value": "last_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "dots.shape.as_list()[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.cast(tf.shape(dots)[-1], tf.float32)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_92": {
                "name": {
                    "value": "bias1",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_variable_93": {
                "name": {
                    "value": "bias2",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, 1, self.project_size)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.zeros_initializer()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "sqrt_97": {
                "x": {
                    "value": "tf.cast(self.project_size, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "expand_dims_116": {
                "input": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_141": {
                "input": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_168": {
                "input": {
                    "value": "dot_w",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('dot_w', shape=x.shape.as_list()[-1], initializer=init, dtype=tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_171": {
                "input": {
                    "value": "key_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ],
                        [
                            "tf.tensordot(keys, key_w, axes=[[2], [0]])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_29": {
                "input": {
                    "value": "tensor_1",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_97": {
                "x": {
                    "value": "self.project_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_initializer_92": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_93": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "shape_60": {
                "input": {
                    "value": "dots",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.matmul(tensor_1, tensor_2, transpose_b=True)",
                            "Call"
                        ],
                        [
                            "dots / tf.sqrt(tf.cast(self.project_size, tf.float32))",
                            "BinOp"
                        ],
                        [
                            "tf.matmul(x1, x2, transpose_b=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/nn/span_prediction.py": {
        "tensorflow": {
            "sequence_mask_45": {
                "variable": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(self.start_logits)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_46": {
                "variable": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "argmax_55": {
                "variable": {
                    "value": "argmax",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_56": {
                "variable": {
                    "value": "self.best_score",
                    "type": "Attribute",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_85": {
                "variable": {
                    "value": "self.start_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_86": {
                "variable": {
                    "value": "self.end_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "logits": {
                    "value": "end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m2",
                            "variable"
                        ],
                        [
                            "fully_connected(m2, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "sequence_mask_97": {
                "variable": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "maxlen": {
                    "value": "tf.shape(self.start_logits)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_98": {
                "variable": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sequence_mask_173": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, l)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(mask, 2), tf.expand_dims(mask, 1))",
                            "Call"
                        ],
                        [
                            "tf.matrix_band_part(mask, 0, self.bound)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(mask_lst, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(context_embed)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "logical_and_174": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(mask, 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(mask, 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_180": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, l)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(mask, 2), tf.expand_dims(mask, 1))",
                            "Call"
                        ],
                        [
                            "tf.matrix_band_part(mask, 0, self.bound)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(mask_lst, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_326": {
                "variable": {
                    "value": "span_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "span_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(span_logits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sequence_mask_389": {
                "variable": {
                    "value": "bool_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "lengths": {
                    "value": "context_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "maxlen": {
                    "value": "tf.shape(context_embed)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "concat_410": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "mask_lst",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_411": {
                "variable": {
                    "value": "span_vectors",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "span_vector_lst",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_420": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_562": {
                "variable": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_569": {
                "variable": {
                    "value": "end_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m2",
                            "variable"
                        ],
                        [
                            "fully_connected(m2, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "einsum_574": {
                "variable": {
                    "value": "start_atten",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ajk,aj->ak",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "m1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pre_process.apply(is_train, m1, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.nn.softmax(masked_start_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "einsum_575": {
                "variable": {
                    "value": "end_atten",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "ajk,aj->ak",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "m2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.pre_process.apply(is_train, m2, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "tf.nn.softmax(masked_end_logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_593": {
                "variable": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_dim, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_598": {
                "variable": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_logits, tf.expand_dims(none_logit, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_599": {
                "variable": {
                    "value": "log_norms",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_602": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(answer[0], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(answer[1], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_603": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_dim, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_604": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_613": {
                "variable": {
                    "value": "log_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(correct_mask, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_614": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-(log_correct - log_norms)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_615": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "exp_41": {
                "x": {
                    "value": "tf.expand_dims(self.start_logits, 2) + tf.expand_dims(self.end_logits, 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "argmax_66": {
                "variable": {
                    "value": "argmax",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_max_67": {
                "variable": {
                    "value": "best_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_93": {
                "x": {
                    "value": "tf.expand_dims(self.start_logits, 2) + tf.expand_dims(self.end_logits, 1)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_124": {
                "variable": {
                    "value": "losses1",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "answer_spans[:, 0]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "sparse_softmax_cross_entropy_with_logits_126": {
                "variable": {
                    "value": "losses2",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "answer_spans[:, 1]",
                    "type": "Subscript",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "add_n_128": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.reduce_mean(losses1), tf.reduce_mean(losses2)]",
                    "type": "List",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "add_to_collection_148": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_185": {
                "variable": {
                    "value": "span_scores",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "span_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(start_logits, 2) + tf.expand_dims(end_logits, 1)",
                            "BinOp"
                        ],
                        [
                            "span_scores * mask + (1 - mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(span_scores, (tf.shape(start_logits)[0], -1))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(tf.shape(start_logits)[0], -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_187": {
                "variable": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "span_scores",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.expand_dims(start_logits, 2) + tf.expand_dims(end_logits, 1)",
                            "BinOp"
                        ],
                        [
                            "span_scores * mask + (1 - mask) * VERY_NEGATIVE_NUMBER",
                            "BinOp"
                        ],
                        [
                            "tf.reshape(span_scores, (tf.shape(start_logits)[0], -1))",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[:, 0] * l + answer[:, 1]",
                            "BinOp"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "reduce_mean_188": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_scores, labels=answer)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_to_collection_191": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "get_variable_214": {
                "variable": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "none-logit",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "self.non_init",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "tile_215": {
                "variable": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(none_logit, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[batch_dim]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_217": {
                "variable": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "(batch_dim, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_222": {
                "variable": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[all_logits, tf.expand_dims(none_logit, 1)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_223": {
                "variable": {
                    "value": "log_norms",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_and_226": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.expand_dims(answer[0], 1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.expand_dims(answer[1], 2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_227": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(batch_dim, -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "concat_228": {
                "variable": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_231": {
                "variable": {
                    "value": "log_correct",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "all_logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(correct_mask, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_233": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-(log_correct - log_norms)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "softmax_234": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "all_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.reshape(tf.expand_dims(masked_start_logits, 1) + tf.expand_dims(masked_end_logits, 2), (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([all_logits, tf.expand_dims(none_logit, 1)], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "unique_255": {
                "variable": {
                    "value": "(_, group_segments)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "x": {
                    "value": "group_ids",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[2]",
                            "Subscript"
                        ]
                    ]
                },
                "out_idx": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_266": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_scores, labels=answer)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "add_to_collection_269": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_299": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.reduce_mean(loss, name='sigmoid-loss')",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "add_to_collection_359": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_455": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "squeeze_476": {
                "variable": {
                    "value": "logits1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits1, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_480": {
                "variable": {
                    "value": "logits2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "logits2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fully_connected(m2, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits2, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_521": {
                "variable": {
                    "value": "l1",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "l1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(l1, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "squeeze_524": {
                "variable": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "l2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "fully_connected(m2, 1, activation_fn=None, weights_initializer=init)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(l2, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "squeeze_dims": {
                    "value": "[2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_580": {
                "variable": {
                    "value": "enc",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "enc",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.encoder.apply(is_train, context_embed, context_mask)",
                            "Call"
                        ],
                        [
                            "tf.reshape(enc, (-1, encodings * fe))",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(-1, encodings * fe)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "squeeze_588": {
                "variable": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('none-logit', initializer=self.non_init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(none_logit, 0), [batch_dim])",
                            "Call"
                        ],
                        [
                            "self.confidence_predictor.apply(is_train, tf.concat(conf, axis=1))",
                            "Call"
                        ],
                        [
                            "fully_connected(none_logit, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(none_logit, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "add_to_collection_616": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_47": {
                "input_tensor": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_99": {
                "input_tensor": {
                    "value": "bol_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.sequence_mask(self.mask, tf.shape(self.start_logits)[1])",
                            "Call"
                        ],
                        [
                            "tf.cast(bol_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_145": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_scores, labels=answer)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "softmax_149": {
                "logits": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_150": {
                "logits": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_165": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_170": {
                "input": {
                    "value": "end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m2",
                            "variable"
                        ],
                        [
                            "fully_connected(m2, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(end_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_174": {
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, l)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(mask, 2), tf.expand_dims(mask, 1))",
                            "Call"
                        ],
                        [
                            "tf.matrix_band_part(mask, 0, self.bound)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(mask_lst, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "softmax_192": {
                "logits": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_193": {
                "logits": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_211": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "add_to_collection_235": {
                "name": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_270": {
                "logits": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_271": {
                "logits": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_296": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "losses",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_scores, labels=answer)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_mean_299": {
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.add_n([tf.reduce_mean(losses1), tf.reduce_mean(losses2)], name='loss')",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.cast(answer_mask, tf.float32), logits=logits)",
                            "Call"
                        ],
                        [
                            "tf.add_n(losses)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix))",
                            "Call"
                        ],
                        [
                            "-tf.reduce_mean(tf.log(tf.reduce_sum(probs * f1_mask, axis=1)))",
                            "UnaryOp"
                        ],
                        [
                            "tf.reduce_mean(-(log_score - log_norm))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(-(log_correct - log_norms))",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "sigmoid-loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "sigmoid_300": {
                "x": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "sigmoid_301": {
                "x": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_327": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_345": {
                "variable": {
                    "value": "log_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "span_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(span_logits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_355": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-(log_score - log_norm)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_391": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_402": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_417": {
                "name_or_scope": {
                    "value": "compute_logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_423": {
                "input": {
                    "value": "context_embed",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_441": {
                "variable": {
                    "value": "log_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_451": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-(log_score - log_norm)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "variable_scope_470": {
                "name_or_scope": {
                    "value": "bounds_encoding",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_473": {
                "name_or_scope": {
                    "value": "start_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_478": {
                "name_or_scope": {
                    "value": "end_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_482": {
                "name_or_scope": {
                    "value": "predict_span",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_509": {
                "name_or_scope": {
                    "value": "map_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_511": {
                "name_or_scope": {
                    "value": "encode_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_513": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_515": {
                "name_or_scope": {
                    "value": "predict",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_519": {
                "name_or_scope": {
                    "value": "logits1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_522": {
                "name_or_scope": {
                    "value": "logits2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_526": {
                "name_or_scope": {
                    "value": "predict_span",
                    "type": "str",
                    "possible_values": []
                }
            },
            "softmax_574": {
                "logits": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "softmax_575": {
                "logits": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                }
            },
            "variable_scope_576": {
                "name_or_scope": {
                    "value": "encode_context",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_582": {
                "name_or_scope": {
                    "value": "confidence",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_585": {
                "name_or_scope": {
                    "value": "confidence_logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "shape_590": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "expand_dims_602": {
                "input": {
                    "value": "answer[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_41": {
                "input": {
                    "value": "self.end_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_45": {
                "input": {
                    "value": "self.start_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "expand_dims_93": {
                "input": {
                    "value": "self.end_logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_97": {
                "input": {
                    "value": "self.start_logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_134": {
                "variable": {
                    "value": "log_norm",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_215": {
                "input": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('none-logit', initializer=self.non_init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(none_logit, 0), [batch_dim])",
                            "Call"
                        ],
                        [
                            "self.confidence_predictor.apply(is_train, tf.concat(conf, axis=1))",
                            "Call"
                        ],
                        [
                            "fully_connected(none_logit, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(none_logit, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_226": {
                "input": {
                    "value": "answer[1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_290": {
                "variable": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(answer_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_cross_entropy_with_logits_291": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "labels": {
                    "value": "tf.cast(answer_mask, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_334": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=span_logits, labels=answer_ix)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_342": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "span_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(span_logits, axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_347": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "span_logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_389": {
                "input": {
                    "value": "context_embed",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "variable_scope_395": {
                "name_or_scope": {
                    "value": "pre-process1",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_397": {
                "name_or_scope": {
                    "value": "pre-process2",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_406": {
                "name_or_scope": {
                    "value": "merge",
                    "type": "str",
                    "possible_values": []
                },
                "reuse": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "variable_scope_414": {
                "name_or_scope": {
                    "value": "post-process",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_mean_430": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=answer_ix)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "softmax_438": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_443": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "variable_scope_557": {
                "name_or_scope": {
                    "value": "start_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "variable_scope_565": {
                "name_or_scope": {
                    "value": "end_pred",
                    "type": "str",
                    "possible_values": []
                }
            },
            "concat_584": {
                "values": {
                    "value": "conf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[start_atten, end_atten, enc]",
                            "List"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_593": {
                "input": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_594": {
                "input": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_598": {
                "input": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('none-logit', initializer=self.non_init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(none_logit, 0), [batch_dim])",
                            "Call"
                        ],
                        [
                            "self.confidence_predictor.apply(is_train, tf.concat(conf, axis=1))",
                            "Call"
                        ],
                        [
                            "fully_connected(none_logit, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(none_logit, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_not_604": {
                "x": {
                    "value": "tf.reduce_any(answer[0], axis=1, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_128": {
                "input_tensor": {
                    "value": "losses2",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.nn.sparse_softmax_cross_entropy_with_logits(logits=masked_end_logits, labels=answer_spans[:, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_136": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer_mask, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_217": {
                "input": {
                    "value": "masked_start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(start_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_218": {
                "input": {
                    "value": "masked_end_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, mask)",
                            "Call"
                        ],
                        [
                            "exp_mask(end_logits, context_mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_222": {
                "input": {
                    "value": "none_logit",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_variable('none-logit', initializer=self.non_init, dtype=tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(none_logit, 0), [batch_dim])",
                            "Call"
                        ],
                        [
                            "self.confidence_predictor.apply(is_train, tf.concat(conf, axis=1))",
                            "Call"
                        ],
                        [
                            "fully_connected(none_logit, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(none_logit, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "logical_not_228": {
                "x": {
                    "value": "tf.reduce_any(answer[0], axis=1, keep_dims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_265": {
                "input_tensor": {
                    "value": "-(log_score - group_norms)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_351": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "span_logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_421": {
                "x": {
                    "value": "tf.concat(mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_447": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_any_604": {
                "input_tensor": {
                    "value": "answer[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_max_140": {
                "variable": {
                    "value": "log_score",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(answer_mask, tf.float32))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_144": {
                "input_tensor": {
                    "value": "-(log_score - log_norm)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "shape_185": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "m1",
                            "variable"
                        ],
                        [
                            "fully_connected(m1, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(start_logits, squeeze_dims=[2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_any_228": {
                "input_tensor": {
                    "value": "answer[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                },
                "keep_dims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_335": {
                "logits": {
                    "value": "span_logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(span_logits, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "labels": {
                    "value": "answer_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_packed_coordinates(answer, l, bound)",
                            "Call"
                        ],
                        [
                            "to_packed_coordinates(answer, l, self.bound)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_343": {
                "input_tensor": {
                    "value": "tf.log(tf.reduce_sum(probs * f1_mask, axis=1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "concat_421": {
                "values": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.sequence_mask(mask, l)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(mask, 2), tf.expand_dims(mask, 1))",
                            "Call"
                        ],
                        [
                            "tf.matrix_band_part(mask, 0, self.bound)",
                            "Call"
                        ],
                        [
                            "tf.cast(mask, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.concat(mask_lst, axis=1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "sparse_softmax_cross_entropy_with_logits_430": {
                "logits": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(self.start_logits + self.end_logits) / 2.0",
                            "BinOp"
                        ],
                        [
                            "self.logits[:, :cutoff]",
                            "Subscript"
                        ],
                        [
                            "self.start_logits + self.end_logits",
                            "BinOp"
                        ],
                        [
                            "fully_connected(span_vectors, 1, activation_fn=None, weights_initializer=init_fn)",
                            "Call"
                        ],
                        [
                            "tf.squeeze(logits, squeeze_dims=[2])",
                            "Call"
                        ],
                        [
                            "logits + VERY_NEGATIVE_NUMBER * (1 - tf.cast(tf.concat(mask, axis=1), tf.float32))",
                            "BinOp"
                        ]
                    ]
                },
                "labels": {
                    "value": "answer_ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "to_packed_coordinates(answer, l, bound)",
                            "Call"
                        ],
                        [
                            "to_packed_coordinates(answer, l, self.bound)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_439": {
                "input_tensor": {
                    "value": "tf.log(tf.reduce_sum(probs * f1_mask, axis=1))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "cast_613": {
                "x": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_232": {
                "x": {
                    "value": "correct_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.logical_and(tf.expand_dims(answer[0], 1), tf.expand_dims(answer[1], 2))",
                            "Call"
                        ],
                        [
                            "tf.reshape(correct_mask, (batch_dim, -1))",
                            "Call"
                        ],
                        [
                            "tf.concat([correct_mask, tf.logical_not(tf.reduce_any(answer[0], axis=1, keep_dims=True))], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_292": {
                "x": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(answer_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_340": {
                "indices": {
                    "value": "to_packed_coordinates(answer, l, bound)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(context_embed)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "log_343": {
                "x": {
                    "value": "tf.reduce_sum(probs * f1_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_435": {
                "indices": {
                    "value": "to_packed_coordinates(answer, l, self.bound)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "l",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(start_logits)[1]",
                            "Subscript"
                        ],
                        [
                            "tf.shape(context_embed)[1]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "log_439": {
                "x": {
                    "value": "tf.reduce_sum(probs * f1_mask, axis=1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_343": {
                "input_tensor": {
                    "value": "probs * f1_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_439": {
                "input_tensor": {
                    "value": "probs * f1_mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_261": {
                "x": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(answer_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_348": {
                "x": {
                    "value": "answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[:, 0] * l + answer[:, 1]",
                            "BinOp"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_444": {
                "x": {
                    "value": "answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[:, 0] * l + answer[:, 1]",
                            "BinOp"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_137": {
                "x": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(answer_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_351": {
                "x": {
                    "value": "answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[:, 0] * l + answer[:, 1]",
                            "BinOp"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_447": {
                "x": {
                    "value": "answer",
                    "type": "variable",
                    "possible_values": [
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[:, 0] * l + answer[:, 1]",
                            "BinOp"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ],
                        [
                            "answer[0]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_141": {
                "x": {
                    "value": "answer_mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(answer_mask, tf.float32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/nn/span_prediction_ops.py": {
        "tensorflow": {
            "top_k_19": {
                "variable": {
                    "value": "top_k",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_logits + end_logits",
                    "type": "BinOp",
                    "possible_values": []
                },
                "k": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_23": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[indices, tf.fill((b,), 0)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "while_loop_43": {
                "variable": {
                    "value": "(_, values, indices)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "cond": {
                    "value": "lambda ix, values, indices: ix < n_lengths",
                    "type": "Lambda",
                    "possible_values": []
                },
                "body": {
                    "value": "compute",
                    "type": "variable",
                    "possible_values": []
                },
                "loop_vars": {
                    "value": "[1, values, indices]",
                    "type": "List",
                    "possible_values": []
                },
                "back_prop": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "stack_49": {
                "variable": {
                    "value": "spans",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[indices[:, 0], indices[:, 0] + indices[:, 1]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_60": {
                "variable": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(starts, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(starts, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "concat_61": {
                "variable": {
                    "value": "ends",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(ends, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(ends, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "tile_62": {
                "variable": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(starts, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(spans)[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_63": {
                "variable": {
                    "value": "ends",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.expand_dims(ends, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[tf.shape(spans)[0], 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cast_65": {
                "variable": {
                    "value": "pred_len",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ends - starts + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "maximum_67": {
                "variable": {
                    "value": "span_start",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(starts, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(starts, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "spans[:, 0:1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "minimum_68": {
                "variable": {
                    "value": "span_stop",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(ends, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(ends, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "spans[:, 1:2]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cast_70": {
                "variable": {
                    "value": "overlap_len",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "span_stop - span_start + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_71": {
                "variable": {
                    "value": "true_len",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "spans[:, 1:2] - spans[:, 0:1] + 1",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_99": {
                "variable": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(ix, tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_106": {
                "variable": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "np.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(lens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(lens, ix)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_107": {
                "variable": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "np.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(lens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(lens, ix)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "ix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(ix, tf.int32)",
                            "Call"
                        ]
                    ]
                }
            },
            "minimum_32": {
                "variable": {
                    "value": "n_lengths",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "bound",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                },
                "y": {
                    "value": "tf.shape(start_logits)[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "top_k_35": {
                "variable": {
                    "value": "top_k",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "start_logits[:, :-i] + end_logits[:, i:]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_38": {
                "variable": {
                    "value": "b_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[b_indices, tf.fill((b,), i)]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "where_39": {
                "variable": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "b_values > values",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "b_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([b_indices, tf.fill((b,), i)], axis=1)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([indices, tf.fill((b,), 0)], axis=1)",
                            "Call"
                        ],
                        [
                            "tf.where(b_values > values, b_indices, indices)",
                            "Call"
                        ]
                    ]
                }
            },
            "maximum_40": {
                "variable": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "values",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.maximum(values, b_values)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "b_values",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "range_57": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "where_75": {
                "condition": {
                    "value": "overlap_len > 0",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "2 * p * r / (p + r)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.zeros(tf.shape(starts))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "minimum_84": {
                "variable": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "lens",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "tf.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "spans[:, 1] - spans[:, 0]",
                            "BinOp"
                        ],
                        [
                            "np.minimum(lens, bound - 1)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(lens, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.gather(lens, ix)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "bound - 1",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_109": {
                "values": {
                    "value": "[answer_start, answer_start + lens]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_15": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squeeze_20": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "expand_dims_62": {
                "input": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(starts, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(starts, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "expand_dims_63": {
                "input": {
                    "value": "ends",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(ends, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(ends, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "zeros_75": {
                "shape": {
                    "value": "tf.shape(starts)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "fill_23": {
                "dims": {
                    "value": "(b,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "shape_29": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "squeeze_36": {
                "input": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "[1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "shape_75": {
                "input": {
                    "value": "starts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.concat(starts, axis=0)",
                            "Call"
                        ],
                        [
                            "tf.tile(tf.expand_dims(starts, 0), [tf.shape(spans)[0], 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "fill_105": {
                "dims": {
                    "value": "(l - i,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(bound)",
                            "Call"
                        ],
                        [
                            "range(bound)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_32": {
                "input": {
                    "value": "start_logits",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "fill_38": {
                "dims": {
                    "value": "(b,)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "value": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": [
                        [
                            "range(bound)",
                            "Call"
                        ],
                        [
                            "range(bound)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_62": {
                "input": {
                    "value": "spans",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([indices[:, 0], indices[:, 0] + indices[:, 1]], axis=1)",
                            "Call"
                        ]
                    ]
                }
            },
            "shape_63": {
                "input": {
                    "value": "spans",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([indices[:, 0], indices[:, 0] + indices[:, 1]], axis=1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/scripts/ablate_triviaqa.py": {
        "tensorflow": {
            "TruncatedNormal_42": {
                "stddev": {
                    "value": "0.05",
                    "type": "float",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/scripts/convert_to_cpu.py": {
        "tensorflow": {
            "get_variable_29": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Session_34": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_106": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "to_save + other",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Session_135": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_143": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_63": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reset_default_graph_114": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "initialize_variables_105": {
                "var_list": {
                    "value": "to_init",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "latest_checkpoint_144": {
                "checkpoint_dir": {
                    "value": "save_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "join(output_dir, 'save')",
                            "Call"
                        ]
                    ]
                }
            },
            "constant_initializer_30": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "Variable_96": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "sess.run(spec.tensor)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "spec.name.split('/')",
                            "Call"
                        ],
                        [
                            "'/'.join(name)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_103": {
                "key": {
                    "value": "tf.GraphKeys.GLOBAL_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_103": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "docqa/scripts/run_on_user_documents.py": {
        "tensorflow": {
            "Session_93": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_93": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/scripts/show_parameters.py": {
        "tensorflow": {
            "NewCheckpointReader_21": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": [
                        [
                            "model_dir.get_best_weights()",
                            "Call"
                        ],
                        [
                            "model_dir.get_latest_checkpoint()",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "docqa/server/qa_system.py": {
        "tensorflow": {
            "Session_106": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "ConfigProto_106": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/server/server.py": {
        "tensorflow": {
            "placeholder_113": {
                "variable": {
                    "value": "self.context_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(2,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_116": {
                "variable": {
                    "value": "self.context_size",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(2,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/test/test_embedder.py": {
        "tensorflow": {
            "constant_33": {
                "variable": {
                    "value": "original_mat",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.arange(n_words).reshape((n_words, 1)).astype(np.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Session_22": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Session_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "docqa/test/test_lstm.py": {
        "tensorflow": {
            "placeholder_23": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batches, num_inputs)",
                            "Tuple"
                        ],
                        [
                            "(batches, num_inputs)",
                            "Tuple"
                        ]
                    ]
                }
            },
            "placeholder_24": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batches, num_units)",
                            "Tuple"
                        ],
                        [
                            "(batches, num_units)",
                            "Tuple"
                        ]
                    ]
                }
            },
            "Session_30": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_50": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "input_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batches, num_inputs)",
                            "Tuple"
                        ],
                        [
                            "(batches, num_inputs)",
                            "Tuple"
                        ]
                    ]
                }
            },
            "placeholder_51": {
                "variable": {
                    "value": "h",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "hidden_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(batches, num_units)",
                            "Tuple"
                        ],
                        [
                            "(batches, num_units)",
                            "Tuple"
                        ]
                    ]
                }
            },
            "Session_57": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_25": {
                "name_or_scope": {
                    "value": "test_bias",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_31": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "variable_scope_52": {
                "name_or_scope": {
                    "value": "test_inits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "global_variables_initializer_58": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "zeros_initializer_27": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "constant_initializer_54": {
                "value": {
                    "value": "100",
                    "type": "int",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/test/test_span_prediction.py": {
        "tensorflow": {
            "Session_16": {
                "variable": {
                    "value": "self.sess",
                    "type": "Attribute",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_57": {
                "variable": {
                    "value": "start_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_58": {
                "variable": {
                    "value": "end_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, None)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_84": {
                "variable": {
                    "value": "spans_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(None, 2)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_85": {
                "variable": {
                    "value": "coordinate_pl",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1,)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/test/test_ut_coordinates.py": {
        "tensorflow": {
            "Session_12": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "placeholder_14": {
                "variable": {
                    "value": "matrix_size_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "placeholder_15": {
                "variable": {
                    "value": "span_placeholder",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "np.int32",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "[None, 2]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "docqa/trainer.py": {
        "tensorflow": {
            "get_variable_158": {
                "variable": {
                    "value": "global_step",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "global_step",
                    "type": "str",
                    "possible_values": []
                },
                "shape": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                },
                "initializer": {
                    "value": "tf.constant_initializer(0)",
                    "type": "Call",
                    "possible_values": []
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "get_collection_161": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "add_n_164": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.LOSSES)",
                            "Call"
                        ],
                        [
                            "tf.add_n(loss, name='loss')",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "get_collection_175": {
                "variable": {
                    "value": "regularizers",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "tf.GraphKeys.REGULARIZATION_LOSSES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "latest_checkpoint_293": {
                "variable": {
                    "value": "latest",
                    "type": "variable",
                    "possible_values": []
                },
                "checkpoint_dir": {
                    "value": "out.save_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_351": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_370": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "train_params.max_checkpoints_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_371": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "out.log_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FIFOQueue_482": {
                "variable": {
                    "value": "train_queue",
                    "type": "variable",
                    "possible_values": []
                },
                "capacity": {
                    "value": "train_params.async_encoding",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtypes": {
                    "value": "[x.dtype for x in placeholders]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "name": {
                    "value": "train_queue",
                    "type": "str",
                    "possible_values": []
                }
            },
            "placeholder_487": {
                "variable": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.bool",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "()",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "cond_488": {
                "variable": {
                    "value": "input_tensors",
                    "type": "variable",
                    "possible_values": []
                },
                "pred": {
                    "value": "is_train",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.placeholder(tf.bool, ())",
                            "Call"
                        ]
                    ]
                },
                "true_fn": {
                    "value": "lambda : train_queue.dequeue()",
                    "type": "Lambda",
                    "possible_values": []
                },
                "false_fn": {
                    "value": "lambda : evaluator_runner.eval_queue.dequeue()",
                    "type": "Lambda",
                    "possible_values": []
                }
            },
            "Session_496": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "global_variables_509": {
                "variable": {
                    "value": "all_vars",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_531": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "max_to_keep": {
                    "value": "train_params.max_checkpoints_to_keep",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "FileWriter_532": {
                "variable": {
                    "value": "summary_writer",
                    "type": "variable",
                    "possible_values": []
                },
                "logdir": {
                    "value": "out.log_dir",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Session_654": {
                "variable": {
                    "value": "sess",
                    "type": "variable",
                    "possible_values": []
                },
                "config": {
                    "value": "tf.ConfigProto(allow_soft_placement=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Saver_660": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "merge_168": {
                "variable": {
                    "value": "summary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[[tf.summary.tensor_summary('loss', loss)] + tf.get_collection(tf.GraphKeys.SUMMARIES)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_summary_171": {
                "variable": {
                    "value": "summary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.LOSSES)",
                            "Call"
                        ],
                        [
                            "tf.add_n(loss, name='loss')",
                            "Call"
                        ]
                    ]
                }
            },
            "add_n_177": {
                "variable": {
                    "value": "regularization_loss",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "regularizers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES)",
                            "Call"
                        ]
                    ]
                },
                "name": {
                    "value": "regularization_loss",
                    "type": "str",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_189": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "train_params.ema",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "get_default_graph_199": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_208": {
                "variable": {
                    "value": "monitor_ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "train_params.monitor_ema",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "MonitorEMA",
                    "type": "str",
                    "possible_values": []
                },
                "zero_debias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "group_210": {
                "variable": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "opt.apply_gradients(opt.compute_gradients(train_objective), global_step=global_step)",
                            "Call"
                        ],
                        [
                            "tf.group(ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, monitor_ema.apply(list(to_monitor.values())))",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "monitor_ema.apply(list(to_monitor.values()))",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "merge_211": {
                "variable": {
                    "value": "summary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar(col, monitor_ema.average(v)) for (col, v) in to_monitor.items()] + [summary_tensor]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_217": {
                "variable": {
                    "value": "loss_ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "train_params.loss_ema",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "LossEMA",
                    "type": "str",
                    "possible_values": []
                },
                "zero_debias": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Saver_359": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "tf.trainable_variables()",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "get_default_graph_389": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_504": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Saver_525": {
                "variable": {
                    "value": "best_weight_saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "lst",
                    "type": "variable",
                    "possible_values": [
                        [
                            "all_vars",
                            "variable"
                        ]
                    ]
                },
                "max_to_keep": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_default_graph_544": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ExponentialMovingAverage_666": {
                "variable": {
                    "value": "ema",
                    "type": "variable",
                    "possible_values": []
                },
                "decay": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "NewCheckpointReader_667": {
                "variable": {
                    "value": "reader",
                    "type": "variable",
                    "possible_values": []
                },
                "filepattern": {
                    "value": "checkpoint",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "get_default_graph_675": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "group_193": {
                "variable": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "ema_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ema.apply(tf.trainable_variables())",
                            "Call"
                        ],
                        [
                            "loss_ema.apply([loss])",
                            "Call"
                        ],
                        [
                            "loss_ema.apply(to_track)",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_201": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "key": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_default_graph().get_all_collection_keys()",
                            "Call"
                        ]
                    ]
                }
            },
            "group_221": {
                "variable": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "opt.apply_gradients(opt.compute_gradients(train_objective), global_step=global_step)",
                            "Call"
                        ],
                        [
                            "tf.group(ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, monitor_ema.apply(list(to_monitor.values())))",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "ema_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ema.apply(tf.trainable_variables())",
                            "Call"
                        ],
                        [
                            "loss_ema.apply([loss])",
                            "Call"
                        ],
                        [
                            "loss_ema.apply(to_track)",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_223": {
                "variable": {
                    "value": "summary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.summary.scalar('training-ema/loss', ema_var), summary_tensor]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "group_227": {
                "variable": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "train_opt",
                    "type": "variable",
                    "possible_values": [
                        [
                            "opt.apply_gradients(opt.compute_gradients(train_objective), global_step=global_step)",
                            "Call"
                        ],
                        [
                            "tf.group(ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, monitor_ema.apply(list(to_monitor.values())))",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ],
                        [
                            "tf.group(train_opt, ema_op)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "ema_op",
                    "type": "variable",
                    "possible_values": [
                        [
                            "ema.apply(tf.trainable_variables())",
                            "Call"
                        ],
                        [
                            "loss_ema.apply([loss])",
                            "Call"
                        ],
                        [
                            "loss_ema.apply(to_track)",
                            "Call"
                        ]
                    ]
                }
            },
            "merge_234": {
                "variable": {
                    "value": "summary_tensor",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tensor_vars, summary_tensor]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Saver_672": {
                "variable": {
                    "value": "saver",
                    "type": "variable",
                    "possible_values": []
                },
                "var_list": {
                    "value": "expected_ema_names",
                    "type": "variable",
                    "possible_values": [
                        [
                            "{ema.average_name(x): x for x in tf.trainable_variables() if reader.has_tensor(ema.average_name(x))}",
                            "DictComp"
                        ]
                    ]
                }
            },
            "constant_initializer_159": {
                "value": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "get_collection_166": {
                "key": {
                    "value": "tf.GraphKeys.SUMMARIES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "trainable_variables_190": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "control_dependencies_191": {
                "control_inputs": {
                    "value": "[train_opt]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "add_n_204": {
                "variable": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(col)",
                            "Call"
                        ],
                        [
                            "tf.add_n(v)",
                            "Call"
                        ],
                        [
                            "weight_ema.average(x)",
                            "Call"
                        ]
                    ]
                }
            },
            "ConfigProto_351": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "trainable_variables_359": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_496": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "global_variables_initializer_541": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "ConfigProto_654": {
                "allow_soft_placement": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "AdamOptimizer_44": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "scalar_229": {
                "name": {
                    "value": "training-ema/loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_ema.average(loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_230": {
                "name": {
                    "value": "training-ema/objective",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_ema.average(train_objective)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_231": {
                "name": {
                    "value": "training-ema/regularization-loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "loss_ema.average(regularization_loss)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "variables_initializer_383": {
                "var_list": {
                    "value": "vars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[x for x in tf.global_variables() if x not in tf.get_collection(tf.GraphKeys.TRAINABLE_VARIABLES)]",
                            "ListComp"
                        ]
                    ]
                }
            },
            "global_variables_initializer_386": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "trainable_variables_668": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "AdadeltaOptimizer_49": {
                "name": {
                    "value": "name",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "get_collection_169": {
                "key": {
                    "value": "tf.GraphKeys.SUMMARIES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scalar_212": {
                "name": {
                    "value": "col",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_default_graph().get_all_collection_keys()",
                            "Call"
                        ]
                    ]
                },
                "data": {
                    "value": "monitor_ema.average(v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "scalar_223": {
                "name": {
                    "value": "training-ema/loss",
                    "type": "str",
                    "possible_values": []
                },
                "data": {
                    "value": "ema_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "loss_ema.average(loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "global_variables_382": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Summary_429": {
                "value": {
                    "value": "[tf.Summary.Value(tag='time', simple_value=batch_time)]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tensor_summary_168": {
                "name": {
                    "value": "loss",
                    "type": "str",
                    "possible_values": []
                },
                "tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.get_collection(tf.GraphKeys.LOSSES)",
                            "Call"
                        ],
                        [
                            "tf.add_n(loss, name='loss')",
                            "Call"
                        ]
                    ]
                }
            },
            "get_collection_382": {
                "key": {
                    "value": "tf.GraphKeys.TRAINABLE_VARIABLES",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Summary_602": {
                "value": {
                    "value": "[tf.Summary.Value(tag='time', simple_value=batch_time)]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    }
}