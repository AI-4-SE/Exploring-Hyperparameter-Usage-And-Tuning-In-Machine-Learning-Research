{
    "model/evaluate.py": {
        "tensorflow": {
            "KLDivergence_132": {
                "variable": {
                    "value": "kld",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "decode_image_91": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "tf.io.read_file(label_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "resize_104": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, conf.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "conf.label_resize_shape[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "method": {
                    "value": "tf.image.ResizeMethod.NEAREST_NEIGHBOR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_109": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map[..., 1:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_111": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, conf.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "255.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "read_file_91": {
                "filename": {
                    "value": "label_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "files_label[k]",
                            "Subscript"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_mean_136": {
                "input_tensor": {
                    "value": "u",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.evidences_to_masses(prediction)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_138": {
                "input_tensor": {
                    "value": "prob[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_140": {
                "input_tensor": {
                    "value": "prob[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_204": {
                "input_tensor": {
                    "value": "u_naive",
                    "type": "variable",
                    "possible_values": [
                        [
                            "utils.evidences_to_masses(naive_ogm)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_206": {
                "input_tensor": {
                    "value": "prob_naive[..., 0]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "reduce_mean_208": {
                "input_tensor": {
                    "value": "prob_naive[..., 1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "model/metrics.py": {
        "tensorflow": {
            "concat_43": {
                "variable": {
                    "value": "masses_true",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[prob_true, u_true]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_46": {
                "variable": {
                    "value": "masses_pred",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[prob_pred, u_pred]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_48": {
                "input": {
                    "value": "masses_true",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([prob_true, u_true], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "argmax_49": {
                "input": {
                    "value": "masses_pred",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.concat([prob_pred, u_pred], axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "model/model.py": {
        "tensorflow": {
            "Model_49": {
                "*args": {
                    "value": "[input_pillars, input_indices]",
                    "type": "List",
                    "possible_values": []
                },
                "**kwargs": {
                    "value": "[prediction]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_62": {
                "variable": {
                    "value": "self.epoch_num",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "0.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "add_68": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_sum((y_true - prob) ** 2, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.reduce_sum(prob * (1 - prob) / (S + 1), axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "where_79": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "condition": {
                    "value": "y_true[..., 1] > 0.5",
                    "type": "Compare",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.squeeze(loss * weight_occupied, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.squeeze(loss, axis=-1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_mean_82": {
                "variable": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.add(tf.reduce_sum((y_true - prob) ** 2, axis=-1, keepdims=True), tf.reduce_sum(prob * (1 - prob) / (S + 1), axis=-1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "loss + KL_reg",
                            "BinOp"
                        ],
                        [
                            "tf.where(y_true[..., 1] > 0.5, tf.squeeze(loss * weight_occupied, axis=-1), tf.squeeze(loss, axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ]
                    ]
                }
            },
            "ones_like_87": {
                "variable": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y_pred * (1 - y_true) + 1",
                            "BinOp"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "reduce_sum_88": {
                "variable": {
                    "value": "S_alpha",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y_pred * (1 - y_true) + 1",
                            "BinOp"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "add_n_89": {
                "variable": {
                    "value": "KL",
                    "type": "variable",
                    "possible_values": []
                },
                "inputs": {
                    "value": "[tf.reduce_sum((alpha - beta) * (tf.math.digamma(alpha) - tf.math.digamma(S_alpha)), axis=-1, keepdims=True), tf.math.lgamma(S_alpha) - tf.reduce_sum(tf.math.lgamma(alpha), axis=-1, keepdims=True), tf.reduce_sum(tf.math.lgamma(beta), axis=-1, keepdims=True) - tf.math.lgamma(tf.reduce_sum(beta, axis=-1, keepdims=True))]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Conv2D_44": {
                "filters": {
                    "value": "2",
                    "type": "int",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "ogm/conv2d",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "reduce_sum_69": {
                "input_tensor": {
                    "value": "(y_true - prob) ** 2",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_70": {
                "input_tensor": {
                    "value": "prob * (1 - prob) / (S + 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "minimum_72": {
                "x": {
                    "value": "1.0",
                    "type": "float",
                    "possible_values": []
                },
                "y": {
                    "value": "tf.cast(self.epoch_num / 10, tf.float32)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "squeeze_80": {
                "input": {
                    "value": "loss * weight_occupied",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "squeeze_81": {
                "input": {
                    "value": "loss",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.add(tf.reduce_sum((y_true - prob) ** 2, axis=-1, keepdims=True), tf.reduce_sum(prob * (1 - prob) / (S + 1), axis=-1, keepdims=True))",
                            "Call"
                        ],
                        [
                            "loss + KL_reg",
                            "BinOp"
                        ],
                        [
                            "tf.where(y_true[..., 1] > 0.5, tf.squeeze(loss * weight_occupied, axis=-1), tf.squeeze(loss, axis=-1))",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(loss)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_72": {
                "x": {
                    "value": "self.epoch_num / 10",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_90": {
                "input_tensor": {
                    "value": "(alpha - beta) * (tf.math.digamma(alpha) - tf.math.digamma(S_alpha))",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "lgamma_94": {
                "x": {
                    "value": "S_alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(alpha, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_95": {
                "input_tensor": {
                    "value": "tf.math.lgamma(alpha)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "reduce_sum_96": {
                "input_tensor": {
                    "value": "tf.math.lgamma(beta)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "lgamma_97": {
                "x": {
                    "value": "tf.reduce_sum(beta, axis=-1, keepdims=True)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "lgamma_95": {
                "x": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "y_pred * (1 - y_true) + 1",
                            "BinOp"
                        ],
                        [
                            "alpha",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "lgamma_96": {
                "x": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(alpha)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_97": {
                "input_tensor": {
                    "value": "beta",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.ones_like(alpha)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "digamma_91": {
                "x": {
                    "value": "S_alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(alpha, axis=-1, keepdims=True)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model/predict.py": {
        "tensorflow": {
            "decode_image_71": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "tf.io.read_file(label_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "resize_84": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, conf.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "conf.label_resize_shape[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "method": {
                    "value": "tf.image.ResizeMethod.NEAREST_NEIGHBOR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_89": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map[..., 1:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_91": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, conf.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "255.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "read_file_71": {
                "filename": {
                    "value": "label_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    },
    "model/third_party/point_pillars.py": {
        "tensorflow": {
            "Input_29": {
                "variable": {
                    "value": "input_pillars",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(max_pillars, max_points, nb_features)",
                            "Tuple"
                        ]
                    ]
                },
                "name": {
                    "value": "pillars/input",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Input_31": {
                "variable": {
                    "value": "input_indices",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(max_pillars, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "pillars/indices",
                    "type": "str",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "scatter_nd_55": {
                "variable": {
                    "value": "pillars",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "input_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.Input((max_pillars, 3), name='pillars/indices', dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "updates": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.Conv2D(nb_channels, (1, 1), activation='linear', use_bias=False, name='pillars/conv2d')(input_pillars)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.BatchNormalization(name='pillars/batchnorm', fused=True, epsilon=0.001, momentum=0.99)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Activation('relu', name='pillars/relu')(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.MaxPool2D((1, max_points), name='pillars/maxpooling2d')(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Reshape(reshape_shape, name='pillars/reshape')(x)",
                            "Call"
                        ],
                        [
                            "pillars",
                            "variable"
                        ],
                        [
                            "tf.keras.layers.Conv2D(nb_channels, (3, 3), strides=S, padding='same', activation='relu', name='cnn/block1/conv2d%i' % n)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.BatchNormalization(name='cnn/block1/bn%i' % n, fused=True)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Dropout(0.1, name='cnn/block1/dropout%i' % n)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Conv2D(2 * nb_channels, (3, 3), strides=S, padding='same', activation='relu', name='cnn/block2/conv2d%i' % n)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.BatchNormalization(name='cnn/block2/bn%i' % n, fused=True)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Dropout(0.1, name='cnn/block2/dropout%i' % n)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Conv2D(4 * nb_channels, (3, 3), strides=S, padding='same', activation='relu', name='cnn/block3/conv2d%i' % n)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.BatchNormalization(name='cnn/block3/bn%i' % n, fused=True)(x)",
                            "Call"
                        ],
                        [
                            "tf.keras.layers.Dropout(0.1, name='cnn/block3/dropout%i' % n)(x)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(tf.shape(input_indices)[0],) + image_size + (nb_channels,)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reverse_59": {
                "variable": {
                    "value": "pillars",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "pillars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.scatter_nd(input_indices, x, (tf.shape(input_indices)[0],) + image_size + (nb_channels,))",
                            "Call"
                        ],
                        [
                            "tf.reverse(pillars, [1, 2])",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[1, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "image_data_format_24": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Conv2D_36": {
                "filters": {
                    "value": "nb_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nb_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "activation": {
                    "value": "linear",
                    "type": "str",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "name": {
                    "value": "pillars/conv2d",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_40": {
                "name": {
                    "value": "pillars/batchnorm",
                    "type": "str",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "epsilon": {
                    "value": "0.001",
                    "type": "float",
                    "possible_values": []
                },
                "momentum": {
                    "value": "0.99",
                    "type": "float",
                    "possible_values": []
                }
            },
            "Activation_44": {
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "pillars/relu",
                    "type": "str",
                    "possible_values": []
                }
            },
            "MaxPool2D_45": {
                "pool_size": {
                    "value": "(1, max_points)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "name": {
                    "value": "pillars/maxpooling2d",
                    "type": "str",
                    "possible_values": []
                }
            },
            "image_data_format_48": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Reshape_53": {
                "target_shape": {
                    "value": "reshape_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(nb_channels, max_pillars)",
                            "Tuple"
                        ],
                        [
                            "(max_pillars, nb_channels)",
                            "Tuple"
                        ]
                    ]
                },
                "name": {
                    "value": "pillars/reshape",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_104": {
                "filters": {
                    "value": "2 * nb_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(1, 1)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "cnn/up1/conv2dt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_109": {
                "name": {
                    "value": "cnn/up1/bn",
                    "type": "str",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_113": {
                "filters": {
                    "value": "2 * nb_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(2, 2)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "cnn/up2/conv2dt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_118": {
                "name": {
                    "value": "cnn/up2/bn",
                    "type": "str",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Conv2DTranspose_122": {
                "filters": {
                    "value": "2 * nb_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "(4, 4)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "cnn/up3/conv2dt",
                    "type": "str",
                    "possible_values": []
                }
            },
            "BatchNormalization_127": {
                "name": {
                    "value": "cnn/up3/bn",
                    "type": "str",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Concatenate_131": {
                "name": {
                    "value": "cnn/concatenate",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Conv2D_67": {
                "filters": {
                    "value": "nb_channels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "nb_channels",
                            "Method Argument"
                        ]
                    ]
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ]
                    ]
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block1/conv2d%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "BatchNormalization_72": {
                "name": {
                    "value": "'cnn/block1/bn%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Dropout_74": {
                "rate": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block1/dropout%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Conv2D_80": {
                "filters": {
                    "value": "2 * nb_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ]
                    ]
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block2/conv2d%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "BatchNormalization_85": {
                "name": {
                    "value": "'cnn/block2/bn%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Dropout_87": {
                "rate": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block2/dropout%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "Conv2D_93": {
                "filters": {
                    "value": "4 * nb_channels",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_size": {
                    "value": "(3, 3)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "strides": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ],
                        [
                            "(2, 2) if n == 0 else (1, 1)",
                            "IfExp"
                        ]
                    ]
                },
                "padding": {
                    "value": "same",
                    "type": "str",
                    "possible_values": []
                },
                "activation": {
                    "value": "relu",
                    "type": "str",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block3/conv2d%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "BatchNormalization_98": {
                "name": {
                    "value": "'cnn/block3/bn%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                },
                "fused": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "Dropout_100": {
                "rate": {
                    "value": "0.1",
                    "type": "float",
                    "possible_values": []
                },
                "name": {
                    "value": "'cnn/block3/dropout%i' % n",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "shape_56": {
                "input": {
                    "value": "input_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.layers.Input((max_pillars, 3), name='pillars/indices', dtype=tf.int32)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "model/train.py": {
        "tensorflow": {
            "Adam_144": {
                "variable": {
                    "value": "optimizer",
                    "type": "variable",
                    "possible_values": []
                },
                "learning_rate": {
                    "value": "conf.learning_rate",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "TensorBoard_163": {
                "variable": {
                    "value": "tensorboard_cb",
                    "type": "variable",
                    "possible_values": []
                },
                "log_dir": {
                    "value": "tensorboard_dir",
                    "type": "variable",
                    "possible_values": [
                        [
                            "os.path.join(model_output_dir, 'TensorBoard')",
                            "Call"
                        ]
                    ]
                },
                "update_freq": {
                    "value": "epoch",
                    "type": "str",
                    "possible_values": []
                },
                "profile_batch": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "ModelCheckpoint_166": {
                "variable": {
                    "value": "checkpoint_cb",
                    "type": "variable",
                    "possible_values": []
                },
                "filepath": {
                    "value": "os.path.join(checkpoint_dir, 'e{epoch:03d}_weights.hdf5')",
                    "type": "Call",
                    "possible_values": []
                },
                "period": {
                    "value": "conf.save_interval",
                    "type": "Attribute",
                    "possible_values": []
                },
                "save_weights_only": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "ModelCheckpoint_170": {
                "variable": {
                    "value": "best_checkpoint_cb",
                    "type": "variable",
                    "possible_values": []
                },
                "filepath": {
                    "value": "os.path.join(checkpoint_dir, 'best_weights.hdf5')",
                    "type": "Call",
                    "possible_values": []
                },
                "save_best_only": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                },
                "monitor": {
                    "value": "val_loss",
                    "type": "str",
                    "possible_values": []
                },
                "save_weights_only": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "squeeze_271": {
                "variable": {
                    "value": "pillars",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "pillars",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx, label_file], Tout=[tf.float32, tf.int32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx], Tout=[tf.float32, tf.int32])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(pillars, axis=0)",
                            "Call"
                        ],
                        [
                            "utils.make_point_pillars(lidar, self.max_points_per_pillar, self.max_pillars, self.step_x_size, self.step_y_size, self.x_min, self.x_max, self.y_min, self.y_max, self.z_min, self.z_max, min_distance=self.min_point_distance)",
                            "Call"
                        ],
                        [
                            "pillars.astype(np.float32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "squeeze_272": {
                "variable": {
                    "value": "voxels",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "voxels",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx, label_file], Tout=[tf.float32, tf.int32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx], Tout=[tf.float32, tf.int32])",
                            "Call"
                        ],
                        [
                            "tf.squeeze(voxels, axis=0)",
                            "Call"
                        ],
                        [
                            "utils.make_point_pillars(lidar, self.max_points_per_pillar, self.max_pillars, self.step_x_size, self.step_y_size, self.x_min, self.x_max, self.y_min, self.y_max, self.z_min, self.z_max, min_distance=self.min_point_distance)",
                            "Call"
                        ],
                        [
                            "voxels.astype(np.int32)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "numpy_function_254": {
                "variable": {
                    "value": "(pillars, voxels, grid_map)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "parseSampleFn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "parseSampleFn",
                            "Call"
                        ]
                    ]
                },
                "inp": {
                    "value": "[input_file, sample_idx, label_file]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32, tf.float32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "numpy_function_259": {
                "variable": {
                    "value": "(pillars, voxels)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "func": {
                    "value": "parseSampleFn",
                    "type": "variable",
                    "possible_values": [
                        [
                            "parseSampleFn",
                            "Call"
                        ]
                    ]
                },
                "inp": {
                    "value": "[input_file, sample_idx]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "[tf.float32, tf.int32]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "assert_cardinality_103": {
                "expected_cardinality": {
                    "value": "cardinality",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conf.epochs * self.n_training_samples",
                            "BinOp"
                        ],
                        [
                            "conf.epochs * self.n_validation_samples",
                            "BinOp"
                        ]
                    ]
                }
            },
            "assert_cardinality_127": {
                "expected_cardinality": {
                    "value": "cardinality",
                    "type": "variable",
                    "possible_values": [
                        [
                            "conf.epochs * self.n_training_samples",
                            "BinOp"
                        ],
                        [
                            "conf.epochs * self.n_validation_samples",
                            "BinOp"
                        ]
                    ]
                }
            },
            "KLDivergence_146": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "decode_image_219": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "tf.io.read_file(label_file)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "resize_239": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx, label_file], Tout=[tf.float32, tf.int32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "self.augmentSample(lidar, grid_map)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, self.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "size": {
                    "value": "self.label_resize_shape[0:2]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "method": {
                    "value": "tf.image.ResizeMethod.NEAREST_NEIGHBOR",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_244": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map[..., 1:3]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "divide_246": {
                "variable": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "grid_map",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.numpy_function(func=parseSampleFn, inp=[input_file, sample_idx, label_file], Tout=[tf.float32, tf.int32, tf.float32])",
                            "Call"
                        ],
                        [
                            "tf.image.decode_image(tf.io.read_file(label_file))",
                            "Call"
                        ],
                        [
                            "self.augmentSample(lidar, grid_map)",
                            "Call"
                        ],
                        [
                            "tf.image.resize(grid_map, self.label_resize_shape[0:2], method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)",
                            "Call"
                        ],
                        [
                            "tf.cast(grid_map[..., 1:3], tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.divide(grid_map, 255.0)",
                            "Call"
                        ]
                    ]
                },
                "y": {
                    "value": "255.0",
                    "type": "float",
                    "possible_values": []
                }
            },
            "read_file_219": {
                "filename": {
                    "value": "label_file",
                    "type": "variable",
                    "possible_values": [
                        [
                            "bytes.decode(label_file)",
                            "Call"
                        ],
                        [
                            "label_file",
                            "Method Argument"
                        ],
                        [
                            "None",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "repeat_95": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_96": {},
            "repeat_119": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "range_120": {}
        }
    },
    "model/utils.py": {
        "tensorflow": {
            "read_file_78": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "filename": {
                    "value": "filename",
                    "type": "variable",
                    "possible_values": [
                        [
                            "filename",
                            "Method Argument"
                        ],
                        [
                            "filename",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "decode_png_79": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "contents": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(filename)",
                            "Call"
                        ],
                        [
                            "cv2.cvtColor(img, cv2.COLOR_BGR2RGB)",
                            "Call"
                        ],
                        [
                            "tf.io.read_file(filename)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(img, channels=3)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, (0, 0), fx=factor, fy=factor, interpolation=interpolation)",
                            "Call"
                        ],
                        [
                            "img[:, left:right]",
                            "Subscript"
                        ],
                        [
                            "img[left:right, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, 0, int((fromShape[1] - crop) / 2), fromShape[0], int(crop))",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, int((fromShape[0] - crop) / 2), 0, int(crop), fromShape[1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ]
                    ]
                },
                "channels": {
                    "value": "3",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_144": {
                "variable": {
                    "value": "S",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "alpha",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits + tf.ones(tf.shape(logits))",
                            "BinOp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                },
                "keepdims": {
                    "value": "True",
                    "type": "bool",
                    "possible_values": []
                }
            },
            "cast_146": {
                "variable": {
                    "value": "num_classes",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.shape(logits)[-1]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.dtypes.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "resize_114": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(filename)",
                            "Call"
                        ],
                        [
                            "cv2.cvtColor(img, cv2.COLOR_BGR2RGB)",
                            "Call"
                        ],
                        [
                            "tf.io.read_file(filename)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(img, channels=3)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, (0, 0), fx=factor, fy=factor, interpolation=interpolation)",
                            "Call"
                        ],
                        [
                            "img[:, left:right]",
                            "Subscript"
                        ],
                        [
                            "img[left:right, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, 0, int((fromShape[1] - crop) / 2), fromShape[0], int(crop))",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, int((fromShape[0] - crop) / 2), 0, int(crop), fromShape[1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "toShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "toShape",
                            "Method Argument"
                        ]
                    ]
                },
                "method": {
                    "value": "interpolation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.INTER_CUBIC",
                            "Method Argument"
                        ],
                        [
                            "tf.image.ResizeMethod.BICUBIC",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "resize_134": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "images": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(filename)",
                            "Call"
                        ],
                        [
                            "cv2.cvtColor(img, cv2.COLOR_BGR2RGB)",
                            "Call"
                        ],
                        [
                            "tf.io.read_file(filename)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(img, channels=3)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, (0, 0), fx=factor, fy=factor, interpolation=interpolation)",
                            "Call"
                        ],
                        [
                            "img[:, left:right]",
                            "Subscript"
                        ],
                        [
                            "img[left:right, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, 0, int((fromShape[1] - crop) / 2), fromShape[0], int(crop))",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, int((fromShape[0] - crop) / 2), 0, int(crop), fromShape[1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ]
                    ]
                },
                "size": {
                    "value": "toShape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "toShape",
                            "Method Argument"
                        ]
                    ]
                },
                "method": {
                    "value": "interpolation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.INTER_CUBIC",
                            "Method Argument"
                        ],
                        [
                            "tf.image.ResizeMethod.BICUBIC",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "crop_to_bounding_box_124": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(filename)",
                            "Call"
                        ],
                        [
                            "cv2.cvtColor(img, cv2.COLOR_BGR2RGB)",
                            "Call"
                        ],
                        [
                            "tf.io.read_file(filename)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(img, channels=3)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, (0, 0), fx=factor, fy=factor, interpolation=interpolation)",
                            "Call"
                        ],
                        [
                            "img[:, left:right]",
                            "Subscript"
                        ],
                        [
                            "img[left:right, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, 0, int((fromShape[1] - crop) / 2), fromShape[0], int(crop))",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, int((fromShape[0] - crop) / 2), 0, int(crop), fromShape[1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "int((fromShape[1] - crop) / 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "target_height": {
                    "value": "fromShape[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "target_width": {
                    "value": "int(crop)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "crop_to_bounding_box_129": {
                "variable": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": []
                },
                "image": {
                    "value": "img",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cv2.imread(filename)",
                            "Call"
                        ],
                        [
                            "cv2.cvtColor(img, cv2.COLOR_BGR2RGB)",
                            "Call"
                        ],
                        [
                            "tf.io.read_file(filename)",
                            "Call"
                        ],
                        [
                            "tf.image.decode_png(img, channels=3)",
                            "Call"
                        ],
                        [
                            "cv2.resize(img, (0, 0), fx=factor, fy=factor, interpolation=interpolation)",
                            "Call"
                        ],
                        [
                            "img[:, left:right]",
                            "Subscript"
                        ],
                        [
                            "img[left:right, :]",
                            "Subscript"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, 0, int((fromShape[1] - crop) / 2), fromShape[0], int(crop))",
                            "Call"
                        ],
                        [
                            "tf.image.crop_to_bounding_box(img, int((fromShape[0] - crop) / 2), 0, int(crop), fromShape[1])",
                            "Call"
                        ],
                        [
                            "tf.image.resize(img, toShape, method=interpolation)",
                            "Call"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ],
                        [
                            "img",
                            "Method Argument"
                        ]
                    ]
                },
                "offset_height": {
                    "value": "int((fromShape[0] - crop) / 2)",
                    "type": "Call",
                    "possible_values": []
                },
                "offset_width": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "target_height": {
                    "value": "int(crop)",
                    "type": "Call",
                    "possible_values": []
                },
                "target_width": {
                    "value": "fromShape[1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "ones_141": {
                "shape": {
                    "value": "tf.shape(logits)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "shape_141": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            },
            "shape_146": {
                "input": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": [
                        [
                            "logits",
                            "Method Argument"
                        ],
                        [
                            "logits",
                            "Method Argument"
                        ]
                    ]
                }
            }
        }
    }
}