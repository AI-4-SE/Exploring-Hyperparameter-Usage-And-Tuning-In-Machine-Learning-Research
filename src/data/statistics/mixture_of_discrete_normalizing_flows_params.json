{
    "mdnf/gmvi.py": {
        "sklearn": {
            "euclidean_distances_31": {
                "variable": {
                    "value": "costs",
                    "type": "variable",
                    "possible_values": []
                },
                "X": {
                    "value": "X1",
                    "type": "variable",
                    "possible_values": []
                },
                "Y": {
                    "value": "X2",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "KMeans_435": {
                "variable": {
                    "value": "kmeans",
                    "type": "variable",
                    "possible_values": []
                },
                "n_clusters": {
                    "value": "self.n_components",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        },
        "tensorflow": {
            "reduce_min_39": {
                "variable": {
                    "value": "minv",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_max_41": {
                "variable": {
                    "value": "maxv",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "batch_49": {
                "variable": {
                    "value": "d",
                    "type": "variable",
                    "possible_values": []
                },
                "tensors": {
                    "value": "batch_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "10000",
                            "MethodArgument"
                        ],
                        [
                            "512",
                            "MethodArgument"
                        ],
                        [
                            "512",
                            "MethodArgument"
                        ]
                    ]
                },
                "batch_size": {
                    "value": "drop_remainder",
                    "type": "variable",
                    "possible_values": [
                        [
                            "False",
                            "MethodArgument"
                        ],
                        [
                            "False",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "inv_195": {
                "variable": {
                    "value": "ilambdas",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "lambdas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_lambda.sample()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_232": {
                "variable": {
                    "value": "component_size_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "r_tf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(zs, 0) + 1e-16",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_256": {
                "variable": {
                    "value": "lik",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "zs * x_log_probs",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-1, -2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_mean_265": {
                "variable": {
                    "value": "r_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_269": {
                "variable": {
                    "value": "log_prob_zs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "zs * tf.math.log(pis[:, None, :])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-1, -2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reduce_sum_302": {
                "variable": {
                    "value": "log_prior_lambdas",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "prior_lambda.log_prob(lambdas)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_314": {
                "variable": {
                    "value": "log_prior_mus",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "prior_mu.log_prob(mus)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_365": {
                "variable": {
                    "value": "r_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_366": {
                "variable": {
                    "value": "E_log_q_Z",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "r_tf * tf.math.log(r_tf + 1e-61)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_392": {
                "variable": {
                    "value": "E_log_q_pi",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "E_log_q_pi",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.E_log_q_pi()",
                            "Call"
                        ],
                        [
                            "self.E_log_q_pi()",
                            "Call"
                        ],
                        [
                            "posterior_pi.log_prob(pis)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(E_log_q_pi)",
                            "Call"
                        ],
                        [
                            "self.E_log_q_pi()",
                            "Call"
                        ],
                        [
                            "self.E_log_q_pi()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_395": {
                "variable": {
                    "value": "E_log_q_mu_lambda",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "E_log_q_mu_lambda",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.E_log_q_mu_lambda()",
                            "Call"
                        ],
                        [
                            "self.E_log_q_mu_lambda()",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(posterior_mu.log_prob(mus), -1) + tf.reduce_sum(posterior_lambda.log_prob(lambdas), -1)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(E_log_q_mu_lambda)",
                            "Call"
                        ],
                        [
                            "self.E_log_q_mu_lambda()",
                            "Call"
                        ],
                        [
                            "self.E_log_q_mu_lambda()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_396": {
                "variable": {
                    "value": "r_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_397": {
                "variable": {
                    "value": "E_log_q_Z",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "r_tf * tf.math.log(r_tf + 1e-61)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_580": {
                "variable": {
                    "value": "self.r",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.reduce_mean(zs, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_any_38": {
                "input_tensor": {
                    "value": "tf.math.is_nan(v)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "inv_176": {
                "variable": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "precisions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambdas * beta[None, :, None, None]",
                            "BinOp"
                        ],
                        [
                            "lambdas * beta0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "stack_200": {
                "values": {
                    "value": "x_log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[d.log_prob(X[n]) for n in range(X.shape[0])]",
                            "ListComp"
                        ],
                        [
                            "VariationalGaussianMixtureELBO.get_norm_log_probs(mus, lambdas, X)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_mean_257": {
                "input_tensor": {
                    "value": "lik",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(zs * x_log_probs, [-1, -2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_266": {
                "input_tensor": {
                    "value": "r_tf * ln_pi",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_mean_270": {
                "input_tensor": {
                    "value": "log_prob_zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(zs * tf.math.log(pis[:, None, :]), [-1, -2])",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_279": {
                "input_tensor": {
                    "value": "log_prior_pis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "prior_pi.log_prob(pis)",
                            "Call"
                        ]
                    ]
                }
            },
            "inv_306": {
                "variable": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "precisions",
                    "type": "variable",
                    "possible_values": [
                        [
                            "lambdas * beta[None, :, None, None]",
                            "BinOp"
                        ],
                        [
                            "lambdas * beta0",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reduce_mean_315": {
                "input_tensor": {
                    "value": "log_prior_lambdas + log_prior_mus",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "is_nan_38": {
                "x": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_229": {
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_sum_235": {
                "input_tensor": {
                    "value": "tf.transpose(r_tf)[..., None] * X",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_239": {
                "input_tensor": {
                    "value": "r_tf[..., None, None] * (d[..., None] * d[..., None, :])",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "trace_247": {
                "*args": {
                    "value": "tf.matmul(S_tf, self.W)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_249": {
                "input_tensor": {
                    "value": "tf.matmul(d[:, None], self.W)[:, 0, :] * d",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_251": {
                "input_tensor": {
                    "value": "component_size_tf * (ln_Lambda + part2 + part3_tf + part4_tf + part5)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_sum_393": {
                "input_tensor": {
                    "value": "posterior_mu.log_prob(mus)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_394": {
                "input_tensor": {
                    "value": "posterior_lambda.log_prob(lambdas)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_543": {
                "x": {
                    "value": "log_joint_probs(tf.cast(zs, X.dtype)) - E_log_q_pi - E_log_q_mu_lambda",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inference.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_572": {
                "x": {
                    "value": "tf.reduce_mean(zs, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "reduce_mean_580": {
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_639": {
                "x": {
                    "value": "log_joint_probs(tf.cast(zs, X.dtype)) - E_log_q_pi - E_log_q_mu_lambda",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.inference.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cholesky_170": {
                "input": {
                    "value": "W1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.tile(self.W, [nsamples, 1, 1, 1])",
                            "Call"
                        ]
                    ]
                }
            },
            "transpose_196": {
                "a": {
                    "value": "ilambdas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(lambdas)",
                            "Call"
                        ],
                        [
                            "0.5 * (ilambdas + tf.transpose(ilambdas, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cholesky_198": {
                "input": {
                    "value": "ilambdas",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(lambdas)",
                            "Call"
                        ],
                        [
                            "0.5 * (ilambdas + tf.transpose(ilambdas, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "matmul_247": {
                "a": {
                    "value": "S_tf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(r_tf[..., None, None] * (d[..., None] * d[..., None, :]), 0) / component_size_tf[..., None, None]",
                            "BinOp"
                        ]
                    ]
                },
                "b": {
                    "value": "self.W",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_269": {
                "x": {
                    "value": "pis[:, None, :]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "cholesky_301": {
                "input": {
                    "value": "self.W0",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "log_366": {
                "x": {
                    "value": "r_tf + 1e-61",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "log_397": {
                "x": {
                    "value": "r_tf + 1e-61",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "gather_531": {
                "params": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "minibatch_ixs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "yield_indices1(x_train, batch_size, drop_remainder=False)",
                            "Call"
                        ],
                        [
                            "next(minibatch_ixs_generator)",
                            "Call"
                        ],
                        [
                            "next(minibatch_ixs_generator)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_627": {
                "params": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "minibatch_ixs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "yield_indices1(x_train, batch_size, drop_remainder=False)",
                            "Call"
                        ],
                        [
                            "next(minibatch_ixs_generator)",
                            "Call"
                        ],
                        [
                            "next(minibatch_ixs_generator)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "transpose_177": {
                "a": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cholesky_179": {
                "input": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_307": {
                "a": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                },
                "perm": {
                    "value": "[0, 1, 3, 2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "cholesky_309": {
                "input": {
                    "value": "covs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ],
                        [
                            "tf.linalg.inv(precisions)",
                            "Call"
                        ],
                        [
                            "0.5 * (covs + tf.transpose(covs, [0, 1, 3, 2]))",
                            "BinOp"
                        ]
                    ]
                }
            },
            "transpose_235": {
                "a": {
                    "value": "r_tf",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_mean(zs, 0) + 1e-16",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ],
                        [
                            "tf.reduce_mean(zs, 0)",
                            "Call"
                        ]
                    ]
                }
            },
            "matmul_249": {
                "a": {
                    "value": "d[:, None]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "b": {
                    "value": "self.W",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_mean_572": {
                "input_tensor": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "cast_544": {
                "x": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "X.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_640": {
                "x": {
                    "value": "zs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "posterior_z.sample(nsamples)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ],
                        [
                            "self.inference.flow(base_samples, mask)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "X.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/base_categorical.py": {
        "tensorflow": {
            "stack_44": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_42": {
                "variable": {
                    "value": "probs_x1",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.multiply(x1, probs[d])",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_58": {
                "x": {
                    "value": "self.log_prob(x_one_hot)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "floatx_25": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "softmax_71": {
                "logits": {
                    "value": "self._logits",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "multiply_42": {
                "x": {
                    "value": "x1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "x_one_hot[..., d, :]",
                            "Subscript"
                        ]
                    ]
                },
                "y": {
                    "value": "probs[d]",
                    "type": "Subscript",
                    "possible_values": []
                }
            },
            "log_43": {
                "x": {
                    "value": "probs_x1",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(tf.multiply(x1, probs[d]), 1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "mdnf/base_constructors.py": {
        "tensorflow": {
            "floatx_79": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "log_101": {
                "variable": {
                    "value": "mixing_logits",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "[1.0 / B] * B",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "one_hot_53": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "probability_concentrantion",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(list(product(*[range(i) for i in [K] * N])))",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/base_mixtures.py": {
        "tensorflow": {
            "log_78": {
                "variable": {
                    "value": "log_mixing_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mixing_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mixing_probs",
                            "Attribute"
                        ],
                        [
                            "mixing_probs.numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_122": {
                "variable": {
                    "value": "component_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "component_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self._distributions[i].sample(n) for i in range(self.B)]",
                            "ListComp"
                        ],
                        [
                            "tf.stack(component_samples, axis=-2)",
                            "Call"
                        ],
                        [
                            "self._components_distribution.sample(n)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "transpose_125": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "selected_components",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._mixing_distribution.sample(n)",
                            "Call"
                        ]
                    ]
                }
            },
            "broadcast_to_126": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(selected_components)",
                            "Call"
                        ],
                        [
                            "tf.broadcast_to(mask, (self.N, self.K, self.B, n))",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[3, 0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self._sample_mask(n)",
                            "Call"
                        ],
                        [
                            "mask[..., None, :, None]",
                            "Subscript"
                        ],
                        [
                            "mask[..., None]",
                            "Subscript"
                        ]
                    ]
                },
                "shape": {
                    "value": "(self.N, self.K, self.B, n)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "transpose_127": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(selected_components)",
                            "Call"
                        ],
                        [
                            "tf.broadcast_to(mask, (self.N, self.K, self.B, n))",
                            "Call"
                        ],
                        [
                            "tf.transpose(mask, perm=[3, 0, 2, 1])",
                            "Call"
                        ],
                        [
                            "self._sample_mask(n)",
                            "Call"
                        ],
                        [
                            "mask[..., None, :, None]",
                            "Subscript"
                        ],
                        [
                            "mask[..., None]",
                            "Subscript"
                        ]
                    ]
                },
                "perm": {
                    "value": "[3, 0, 2, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "log_205": {
                "variable": {
                    "value": "log_mixing_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.mixing_probs",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_227": {
                "variable": {
                    "value": "self._components_probs",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "tf.stack([component.probs for component in self.components], -2)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "log_233": {
                "variable": {
                    "value": "log_mixing_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mixing_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mixing_probs",
                            "Attribute"
                        ],
                        [
                            "mixing_probs.numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_234": {
                "variable": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "component_probs * x_ext",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_235": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(component_probs * x_ext, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(component_probs * x_ext, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_236": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_238": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_285": {
                "variable": {
                    "value": "log_mixing_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mixing_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mixing_probs",
                            "Attribute"
                        ],
                        [
                            "mixing_probs.numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "stack_293": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs, 0)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_probs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_294": {
                "variable": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs, 0)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_probs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "log_320": {
                "variable": {
                    "value": "log_mixing_probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "mixing_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.mixing_probs",
                            "Attribute"
                        ],
                        [
                            "mixing_probs.numpy()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_sum_321": {
                "variable": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "component_probs * x_ext",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "log_322": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(component_probs * x_ext, -1)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(component_probs * x_ext, -1)",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_logsumexp_324": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_85": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_87": {
                "input_tensor": {
                    "value": "tf.stack(log_probs, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_104": {
                "x": {
                    "value": "self.log_prob_ext(x_ext)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_195": {
                "input_tensor": {
                    "value": "samples_ext",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sample_ext(n)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_209": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_211": {
                "input_tensor": {
                    "value": "tf.stack(log_probs, 0)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "exp_215": {
                "x": {
                    "value": "self.log_prob(x_one_hot)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_295": {
                "input_tensor": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs, 0)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_probs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_325": {
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "self._distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "tf.reduce_sum(log_prob, -2)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ],
                        [
                            "distributions[b].log_prob(x_one_hot)",
                            "Call"
                        ],
                        [
                            "tf.math.log(prob)",
                            "Call"
                        ],
                        [
                            "log_prob + log_mixing_probs",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "floatx_30": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "stack_87": {
                "values": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs, 0)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_probs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_211": {
                "values": {
                    "value": "log_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(log_probs, 0)",
                            "Call"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_probs, 0)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                }
            },
            "stack_227": {
                "values": {
                    "value": "[component.probs for component in self.components]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_253": {
                "indices": {
                    "value": "(np.arange(n) + np.random.randint(self.B)) % self.B",
                    "type": "BinOp",
                    "possible_values": []
                },
                "depth": {
                    "value": "self.B",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self._mixing_distribution.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/bayesian_networks.py": {
        "tensorflow": {
            "reduce_sum_80": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "probs[None, ...]",
                            "Subscript"
                        ],
                        [
                            "p * tf.reshape(sample_var, shp)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(p, range(1, N + 1))",
                            "Call"
                        ],
                        [
                            "tf.constant(probs[None, ...], dtype=sample.dtype)",
                            "Call"
                        ],
                        [
                            "p * tf.reshape(sample_var, shp)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(p, range(1 + 1, N + 1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "range(1, N + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_96": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "probs[None, ...]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "dtype": {
                    "value": "sample.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_sum_106": {
                "variable": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "p",
                    "type": "variable",
                    "possible_values": [
                        [
                            "probs[None, ...]",
                            "Subscript"
                        ],
                        [
                            "p * tf.reshape(sample_var, shp)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(p, range(1, N + 1))",
                            "Call"
                        ],
                        [
                            "tf.constant(probs[None, ...], dtype=sample.dtype)",
                            "Call"
                        ],
                        [
                            "p * tf.reshape(sample_var, shp)",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(p, range(1 + 1, N + 1))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "range(1 + 1, N + 1)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_116": {
                "input_tensor": {
                    "value": "prob_array",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "list(axes)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_223": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "enumeration",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.enumerate_variables(evidence)",
                            "Call"
                        ],
                        [
                            "np.array(list(product(*[range(i) for i in cards])))",
                            "Call"
                        ],
                        [
                            "enumeration[enumeration[:, col] == val, :]",
                            "Subscript"
                        ]
                    ]
                },
                "depth": {
                    "value": "self.cardinality",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "exp_224": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self.log_prob(samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_225": {
                "input_tensor": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(cpd.cardinality)",
                            "Call"
                        ],
                        [
                            "tf.math.exp(self.log_prob(samples))",
                            "Call"
                        ],
                        [
                            "probs / tf.reduce_sum(probs)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_259": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "(1, self.N, self.cardinality)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "broadcast_to_274": {
                "variable": {
                    "value": "var_tf",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "tf.one_hot(value_no, depth=sample.shape[-1])",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "var_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "sample.shape[:-2] + [1] + sample.shape[-1:]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "concat_275": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[sample[..., :var_no, :], var_tf, sample[..., var_no + 1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_294": {
                "variable": {
                    "value": "var_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((1, self.N, self.cardinality))",
                            "Call"
                        ],
                        [
                            "tf.concat([sample[..., :var_no, :], var_tf, sample[..., var_no + 1:, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "var_nos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_308": {
                "variable": {
                    "value": "var_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((1, self.N, self.cardinality))",
                            "Call"
                        ],
                        [
                            "tf.concat([sample[..., :var_no, :], var_tf, sample[..., var_no + 1:, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "var_nos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_321": {
                "variable": {
                    "value": "var_sample",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.zeros((1, self.N, self.cardinality))",
                            "Call"
                        ],
                        [
                            "tf.concat([sample[..., :var_no, :], var_tf, sample[..., var_no + 1:, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "indices": {
                    "value": "var_nos",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ],
                        [
                            "[self._var2no[name] for name in cpd.variables]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reshape_78": {
                "tensor": {
                    "value": "sample_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wrap_categories1(sample[..., var, :], card)",
                            "Call"
                        ],
                        [
                            "wrap_categories1(sample[..., var, :], card)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.ones((N,), dtype=int)",
                            "Call"
                        ],
                        [
                            "[-1] + list(shp)",
                            "BinOp"
                        ],
                        [
                            "np.ones((N,), dtype=int)",
                            "Call"
                        ],
                        [
                            "[-1] + list(shp)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "reshape_105": {
                "tensor": {
                    "value": "sample_var",
                    "type": "variable",
                    "possible_values": [
                        [
                            "wrap_categories1(sample[..., var, :], card)",
                            "Call"
                        ],
                        [
                            "wrap_categories1(sample[..., var, :], card)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "shp",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.ones((N,), dtype=int)",
                            "Call"
                        ],
                        [
                            "[-1] + list(shp)",
                            "BinOp"
                        ],
                        [
                            "np.ones((N,), dtype=int)",
                            "Call"
                        ],
                        [
                            "[-1] + list(shp)",
                            "BinOp"
                        ]
                    ]
                }
            },
            "log_296": {
                "x": {
                    "value": "var_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "calc_sample_prob(var_sample, probs)",
                            "Call"
                        ]
                    ]
                }
            },
            "log_309": {
                "x": {
                    "value": "calc_sample_prob(var_sample, probs)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "one_hot_274": {
                "indices": {
                    "value": "value_no",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self._variable2values[variable].get(value, value)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "sample.shape[-1]",
                    "type": "Subscript",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/cardinality.py": {
        "tensorflow": {
            "transpose_26": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "unsorted_segment_sum_28": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "data": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                },
                "segment_ids": {
                    "value": "_group_category_columns(K, card)",
                    "type": "Call",
                    "possible_values": []
                },
                "num_segments": {
                    "value": "card",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "transpose_29": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "a": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                }
            },
            "tile_37": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                },
                "multiples": {
                    "value": "repeat",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[1] * (len(sample.shape) - 1) + [int(np.ceil(card / K))]",
                            "BinOp"
                        ]
                    ]
                }
            },
            "zeros_48": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "t.shape[:-1] + [K - K0]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "stack_71": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(s, axis=axis)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(s, axis=axis)",
                            "Call"
                        ],
                        [
                            "range(0, sample.shape[-1], card)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-2",
                            "MethodArgument"
                        ],
                        [
                            "-2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stack_96": {
                "variable": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(s, axis=axis)",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "tf.stack(s, axis=axis)",
                            "Call"
                        ],
                        [
                            "range(0, sample.shape[-1], card)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-2",
                            "MethodArgument"
                        ],
                        [
                            "-2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "concat_49": {
                "values": {
                    "value": "[t, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_68": {
                "variable": {
                    "value": "sample_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-2",
                            "MethodArgument"
                        ],
                        [
                            "-2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_92": {
                "variable": {
                    "value": "sample_dim",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.math.unsorted_segment_sum(sample, _group_category_columns(K, card), card)",
                            "Call"
                        ],
                        [
                            "tf.transpose(sample)",
                            "Call"
                        ],
                        [
                            "tf.tile(sample, repeat)",
                            "Call"
                        ],
                        [
                            "sample[..., :card]",
                            "Subscript"
                        ]
                    ]
                },
                "indices": {
                    "value": "var",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-2",
                            "MethodArgument"
                        ],
                        [
                            "-2",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "zeros_111": {
                "variable": {
                    "value": "padding",
                    "type": "variable",
                    "possible_values": []
                },
                "shape": {
                    "value": "part.shape[:-1] + [card - part.shape[-1]]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "dtype": {
                    "value": "part.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "concat_112": {
                "variable": {
                    "value": "part",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[part, padding]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows.py": {
        "tensorflow": {
            "Sequential_55": {
                "variable": {
                    "value": "self.sequential",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "layers",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[]",
                            "List"
                        ],
                        [
                            "parse_layers_specification(self._layers, N, K, self._temperature, dtype=self.dtype)",
                            "Call"
                        ],
                        [
                            "[('M'",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "gather_139": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_141": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_145": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_147": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "floatx_179": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "Variable_195": {
                "variable": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(temperature, trainable=False, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                },
                "trainable": {
                    "value": "False",
                    "type": "bool",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "reverse_157": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reverse_160": {
                "tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.sequential(x)",
                            "Call"
                        ],
                        [
                            "f.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-2)",
                            "Call"
                        ],
                        [
                            "self.flow.reverse(x)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "[-2]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "is_tensor_194": {
                "x": {
                    "value": "temperature",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.Variable(temperature, trainable=False, dtype=dtype)",
                            "Call"
                        ],
                        [
                            "1.0",
                            "MethodArgument"
                        ],
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "constant_260": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "np.random.choice([0, 1], N)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "int32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_282": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_288": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "normal_282": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_294": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_295": {
                "variable": {
                    "value": "logits_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_288": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_301": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_302": {
                "variable": {
                    "value": "logits_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones((N, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "normal_294": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "normal_295": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_310": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, len(categories)), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_301": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_302": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Variable_318": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.ones((N, len(categories)), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "normal_310": {
                "shape": {
                    "value": "(N, len(categories))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "ones_318": {
                "shape": {
                    "value": "(N, len(categories))",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.keras.backend.floatx()",
                            "MethodArgument"
                        ]
                    ]
                }
            }
        }
    },
    "mdnf/flows_edward2.py": {
        "tensorflow": {
            "TensorShape_52": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ],
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_65": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_90": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0]] * batch_ndims + [[0, length - 1], [0, 0]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_117": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[current_outputs, new_inputs[..., tf.newaxis, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pad_120": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0]] * batch_ndims + [[0, length - timestep - 1], [0, 0]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_131": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[current_outputs, new_outputs[..., -1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_147": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "convert_to_tensor_182": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "pad_199": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0]] * batch_ndims + [[0, length - 1], [0, 0]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_227": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[current_outputs, new_inputs[..., tf.newaxis, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "pad_230": {
                "variable": {
                    "value": "padded_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "paddings": {
                    "value": "[[0, 0]] * batch_ndims + [[0, length - timestep - 1], [0, 0]]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_252": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[current_outputs, new_outputs[..., -1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_267": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_271": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_276": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_277": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "TensorShape_304": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ],
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_322": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_324": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(self.mask, inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1] * batch_ndims + [-1, 1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_342": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "new_inputs[..., tf.newaxis, :]",
                            "Subscript"
                        ],
                        [
                            "tf.concat([current_outputs, new_inputs[..., tf.newaxis, :]], axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "reshape_344": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "tf.cast(self.mask, inputs.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1] * batch_ndims + [-1, 1]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "cast_353": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_95": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_127": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_152": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_204": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_208": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_213": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_214": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_237": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "gather_241": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_246": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_247": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "inputs",
                            "Name"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "cast_330": {
                "variable": {
                    "value": "loc",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "utils.one_hot_argmax(loc, self.temperature)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_359": {
                "x": {
                    "value": "0",
                    "type": "int",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "executing_eagerly_132": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "executing_eagerly_253": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "cast_324": {
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_344": {
                "x": {
                    "value": "self.mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_edward2_made.py": {
        "tensorflow": {
            "cast_220": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "degrees[-1][:, np.newaxis] < degrees[0]",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "GlorotUniform_226": {
                "variable": {
                    "value": "initializer",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "get_77": {
                "variable": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "identifier": {
                    "value": "activation",
                    "type": "variable",
                    "possible_values": [
                        [
                            "None",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "Sequential_79": {
                "variable": {
                    "value": "self.network",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "[]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "TensorShape_82": {
                "variable": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": []
                },
                "dims": {
                    "value": "input_shape",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.TensorShape(input_shape)",
                            "Call"
                        ]
                    ]
                }
            },
            "tile_98": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask[:, tf.newaxis, :]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, channels, 1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_99": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(input_degrees[:, np.newaxis] <= output_degrees, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(degrees[-1][:, np.newaxis] < degrees[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "masks[0]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(mask[:, tf.newaxis, :], [1, channels, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [mask.shape[0] * channels, mask.shape[-1]])",
                            "Call"
                        ],
                        [
                            "masks[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(mask[..., tf.newaxis], [1, 1, self.units])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [mask.shape[0], mask.shape[1] * self.units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[mask.shape[0] * channels, mask.shape[-1]]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "tile_124": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "mask[..., tf.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, 1, self.units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "reshape_125": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(input_degrees[:, np.newaxis] <= output_degrees, tf.float32)",
                            "Call"
                        ],
                        [
                            "tf.cast(degrees[-1][:, np.newaxis] < degrees[0], tf.float32)",
                            "Call"
                        ],
                        [
                            "masks[0]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(mask[:, tf.newaxis, :], [1, channels, 1])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [mask.shape[0] * channels, mask.shape[-1]])",
                            "Call"
                        ],
                        [
                            "masks[-1]",
                            "Subscript"
                        ],
                        [
                            "tf.tile(mask[..., tf.newaxis], [1, 1, self.units])",
                            "Call"
                        ],
                        [
                            "tf.reshape(mask, [mask.shape[0], mask.shape[1] * self.units])",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "[mask.shape[0], mask.shape[1] * self.units]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Dense_126": {
                "variable": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "length * self.units",
                    "type": "BinOp",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "make_masked_initializer(mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_constraint": {
                    "value": "make_masked_constraint(mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "activation": {
                    "value": "None",
                    "type": "NoneType",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "cast_216": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "input_degrees[:, np.newaxis] <= output_degrees",
                    "type": "Compare",
                    "possible_values": []
                },
                "dtype": {
                    "value": "tf.float32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_101": {
                "variable": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "self.hidden_dims[0]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "make_masked_initializer(mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_constraint": {
                    "value": "make_masked_constraint(mask)",
                    "type": "Call",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Dense_111": {
                "variable": {
                    "value": "layer",
                    "type": "variable",
                    "possible_values": []
                },
                "units": {
                    "value": "self.hidden_dims[l]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "kernel_initializer": {
                    "value": "make_masked_initializer(masks[l])",
                    "type": "Call",
                    "possible_values": []
                },
                "kernel_constraint": {
                    "value": "make_masked_constraint(masks[l])",
                    "type": "Call",
                    "possible_values": []
                },
                "activation": {
                    "value": "self.activation",
                    "type": "Attribute",
                    "possible_values": []
                },
                "use_bias": {
                    "value": "self.use_bias",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "Reshape_94": {
                "target_shape": {
                    "value": "[length * channels]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Reshape_133": {
                "target_shape": {
                    "value": "[length, self.units]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_factorized.py": {
        "tensorflow": {
            "concat_88": {
                "variable": {
                    "value": "self._logits_scale_mask",
                    "type": "Attribute",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.ones((N, 1)) * -1e+30, tf.zeros((N, K - 1))]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "1",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_145": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_149": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_150": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_155": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_159": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[x1, x2]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_160": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.shuffling, axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.concat([x1, x2], axis=-1)",
                            "Call"
                        ],
                        [
                            "tf.gather(x, self.inverted_shuffling, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "self.inverted_shuffling",
                    "type": "Attribute",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Variable_23": {
                "variable": {
                    "value": "logits",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, K), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Variable_84": {
                "variable": {
                    "value": "logits_scale",
                    "type": "variable",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, K), dtype=self.dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "logits_scale",
                    "type": "str",
                    "possible_values": []
                }
            },
            "normal_23": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "normal_84": {
                "shape": {
                    "value": "(N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "zeros_88": {
                "shape": {
                    "value": "(N, K - 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "ones_88": {
                "shape": {
                    "value": "(N, 1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_factorized_mixture.py": {
        "tensorflow": {
            "one_hot_21": {
                "variable": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "np.random.choice(np.arange(K), (N, B))",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.dtype",
                            "Attribute"
                        ],
                        [
                            "self.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "Variable_24": {
                "variable": {
                    "value": "self.logits",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal((N, B, K), dtype=dtype)",
                    "type": "Call",
                    "possible_values": []
                },
                "name": {
                    "value": "logits",
                    "type": "str",
                    "possible_values": []
                }
            },
            "one_hot_36": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "selected_flows",
                    "type": "variable",
                    "possible_values": [
                        [
                            "(np.arange(n) + np.random.randint(B)) % B",
                            "BinOp"
                        ]
                    ]
                },
                "depth": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.components.probs.shape[-2]",
                            "Subscript"
                        ],
                        [
                            "self.components.probs.shape[-2]",
                            "Subscript"
                        ]
                    ]
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.dtype",
                            "Attribute"
                        ],
                        [
                            "self.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "reduce_sum_38": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "sample * mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_51": {
                "variable": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "component_probs * sample + eps_prob",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_logsumexp_53": {
                "variable": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.log(prob) + np.log(1.0 / B)",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_54": {
                "input_tensor": {
                    "value": "log_prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.log(prob) + np.log(1.0 / B)",
                            "BinOp"
                        ],
                        [
                            "tf.math.reduce_logsumexp(log_prob, -1)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "normal_24": {
                "shape": {
                    "value": "(N, B, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "self.dtype",
                            "Attribute"
                        ],
                        [
                            "self.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "log_52": {
                "x": {
                    "value": "prob",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.reduce_sum(component_probs * sample + eps_prob, -1)",
                            "Call"
                        ]
                    ]
                }
            }
        }
    },
    "mdnf/flows_mixture.py": {
        "tensorflow": {
            "stack_78": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "blocks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[flow(x[..., b, :]) for (b, flow) in enumerate(self.flows)]",
                            "ListComp"
                        ],
                        [
                            "[flow.reverse(x) for flow in self.flows]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_81": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack(blocks, axis=-2)",
                            "Call"
                        ],
                        [
                            "x * mask",
                            "BinOp"
                        ],
                        [
                            "tf.reduce_sum(x, axis=-2)",
                            "Call"
                        ],
                        [
                            "tf.stack(blocks, -2)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "stack_91": {
                "variable": {
                    "value": "x",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "blocks",
                    "type": "variable",
                    "possible_values": [
                        [
                            "[flow(x[..., b, :]) for (b, flow) in enumerate(self.flows)]",
                            "ListComp"
                        ],
                        [
                            "[flow.reverse(x) for flow in self.flows]",
                            "ListComp"
                        ]
                    ]
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "is_tensor_111": {
                "x": {
                    "value": "t",
                    "type": "variable",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_mixture_test.py": {
        "tensorflow": {
            "cast_45": {
                "variable": {
                    "value": "self.base_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "base.sample(256)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "set_seed_34": {
                "seed": {
                    "value": "13",
                    "type": "int",
                    "possible_values": []
                }
            },
            "set_seed_58": {
                "seed": {
                    "value": "13",
                    "type": "int",
                    "possible_values": []
                }
            },
            "gather_138": {
                "variable": {
                    "value": "bth_flow_out_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "out_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_samples[..., 0, :]",
                            "Subscript"
                        ],
                        [
                            "mixture(base_samples)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "bth_flow_sample_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.nonzero(bs == b)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "validate_indices": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "gather_142": {
                "variable": {
                    "value": "bth_flow1_out_samples",
                    "type": "variable",
                    "possible_values": []
                },
                "params": {
                    "value": "flow1_out_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "flows1[b](base_samples[..., b, :])",
                            "Call"
                        ],
                        [
                            "flows1[b](base_samples[..., b, :])",
                            "Call"
                        ]
                    ]
                },
                "indices": {
                    "value": "bth_flow_sample_indices",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.nonzero(bs == b)[0]",
                            "Subscript"
                        ]
                    ]
                },
                "validate_indices": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "GradientTape_154": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_158": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_163": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "one_hot_130": {
                "indices": {
                    "value": "bs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.random.choice(range(B), base_samples.shape[0])",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_155": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_160": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_165": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_all_90": {
                "input_tensor": {
                    "value": "tf.reduce_sum(out_samples, -1) == B",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_113": {
                "input_tensor": {
                    "value": "flow1_out_samples == out_samples",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_133": {
                "input_tensor": {
                    "value": "tf.reduce_sum(out_samples, -1) == 1",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_75": {
                "input_tensor": {
                    "value": "f.reverse(out_samples) == inv_samples[..., b, :]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "one_hot_107": {
                "indices": {
                    "value": "[b]",
                    "type": "List",
                    "possible_values": []
                },
                "depth": {
                    "value": "B",
                    "type": "variable",
                    "possible_values": [
                        [
                            "3",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_all_110": {
                "input_tensor": {
                    "value": "tf.reduce_sum(out_samples, -1) == 1",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_146": {
                "input_tensor": {
                    "value": "bth_flow_out_samples == bth_flow1_out_samples",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_sum_90": {
                "input_tensor": {
                    "value": "out_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_samples[..., 0, :]",
                            "Subscript"
                        ],
                        [
                            "mixture(base_samples)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_133": {
                "input_tensor": {
                    "value": "out_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_samples[..., 0, :]",
                            "Subscript"
                        ],
                        [
                            "mixture(base_samples)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_sum_110": {
                "input_tensor": {
                    "value": "out_samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base_samples[..., 0, :]",
                            "Subscript"
                        ],
                        [
                            "mixture(base_samples)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ],
                        [
                            "mixture(base_samples, mask=mask)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_test.py": {
        "tensorflow": {
            "cast_40": {
                "variable": {
                    "value": "self.base_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "x": {
                    "value": "base.sample(256)",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "float32",
                    "type": "str",
                    "possible_values": []
                }
            },
            "zeros_43": {
                "variable": {
                    "value": "self.empty_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "(256, N, K)",
                    "type": "Tuple",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.base_samples.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_48": {
                "variable": {
                    "value": "self.equal_samples",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((100, N, K))",
                            "Call"
                        ],
                        [
                            "np.zeros((100, N, K))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.base_samples.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "constant_53": {
                "variable": {
                    "value": "self.equal_samples2",
                    "type": "Attribute",
                    "possible_values": []
                },
                "value": {
                    "value": "s",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros((100, N, K))",
                            "Call"
                        ],
                        [
                            "np.zeros((100, N, K))",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.base_samples.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "reduce_max_163": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(backward(flow, z) - self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_171": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "abs(forward(flow, z) - self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_179": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(backward(flow, z) - self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_187": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "abs(forward(flow, z) - self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_195": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "tf.math.abs(backward(flow, z) - self.empty_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_max_202": {
                "variable": {
                    "value": "error",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "abs(forward(flow, z) - self.empty_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "set_seed_33": {
                "seed": {
                    "value": "13",
                    "type": "int",
                    "possible_values": []
                }
            },
            "set_seed_72": {
                "seed": {
                    "value": "13",
                    "type": "int",
                    "possible_values": []
                }
            },
            "GradientTape_134": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_138": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "GradientTape_143": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            },
            "reduce_sum_135": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_140": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reduce_sum_145": {
                "input_tensor": {
                    "value": "forward(flow, self.base_samples)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "abs_163": {
                "x": {
                    "value": "backward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_179": {
                "x": {
                    "value": "backward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_195": {
                "x": {
                    "value": "backward(flow, z) - self.empty_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_164": {
                "x": {
                    "value": "backward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_172": {
                "x": {
                    "value": "forward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_180": {
                "x": {
                    "value": "backward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_188": {
                "x": {
                    "value": "forward(flow, z) - self.base_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_196": {
                "x": {
                    "value": "backward(flow, z) - self.empty_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "abs_203": {
                "x": {
                    "value": "forward(flow, z) - self.empty_samples",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "reduce_all_90": {
                "input_tensor": {
                    "value": "out[n] == out[n + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_94": {
                "input_tensor": {
                    "value": "out[n] == out[n + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_107": {
                "input_tensor": {
                    "value": "out[n] == out[n + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_all_111": {
                "input_tensor": {
                    "value": "out[n] == out[n + 1]",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "reduce_any_126": {
                "input_tensor": {
                    "value": "out[0, n] != out2[0, n]",
                    "type": "Compare",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/flows_transformations.py": {
        "tensorflow": {
            "Sequential_47": {
                "variable": {
                    "value": "rnn",
                    "type": "variable",
                    "possible_values": []
                },
                "name": {
                    "value": "'%s%i [K=%s, units=%s, embed=%s]' % (rnn_type.__name__, build_rnn_model._counter, vocab_size, rnn_units, embedding_dim)",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "broadcast_to_38": {
                "variable": {
                    "value": "output0",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "self.logits0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "shape": {
                    "value": "x.shape[:-2] + [1, K]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "concat_40": {
                "variable": {
                    "value": "output",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[output0, output1]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "concat_87": {
                "variable": {
                    "value": "input_extended",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[condition, input]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "Sequential_131": {
                "variable": {
                    "value": "result.network",
                    "type": "Attribute",
                    "possible_values": []
                },
                "layers": {
                    "value": "copy.deepcopy(self.network.layers)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "reshape_145": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "[0] * K + [-10000000000.0] + [0] * (K - 1)",
                    "type": "BinOp",
                    "possible_values": []
                },
                "shape": {
                    "value": "[1, 1, 2 * K]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "Variable_31": {
                "variable": {
                    "value": "self.logits0",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "tf.random.normal([K])",
                    "type": "Call",
                    "possible_values": []
                },
                "dtype": {
                    "value": "self.dtype",
                    "type": "Attribute",
                    "possible_values": []
                },
                "name": {
                    "value": "logits0",
                    "type": "str",
                    "possible_values": []
                }
            },
            "Dense_58": {
                "units": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "Dense_52": {
                "units": {
                    "value": "embedding_dim",
                    "type": "variable",
                    "possible_values": [
                        [
                            "0",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "normal_31": {
                "shape": {
                    "value": "[K]",
                    "type": "List",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/inference.py": {
        "tensorflow": {
            "reshape_46": {
                "variable": {
                    "value": "sample_flattened",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": [
                        [
                            "cardinality.wrap_categories(sample, cardinalities)",
                            "Call"
                        ],
                        [
                            "cardinality.unwrap_categories(sample, self.cardinalities, axis=self.axis)",
                            "Call"
                        ],
                        [
                            "self.flow(base_sample, mask)",
                            "Call"
                        ],
                        [
                            "self.flow_prev_C(base_sample, mask)",
                            "Call"
                        ],
                        [
                            "self.flow(base_sample, mask)",
                            "Call"
                        ]
                    ]
                },
                "shape": {
                    "value": "(sample.shape[0], -1)",
                    "type": "Tuple",
                    "possible_values": []
                }
            },
            "reduce_mean_62": {
                "variable": {
                    "value": "entropy",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "-base.log_prob_ext(inv_sample)",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_mean_166": {
                "variable": {
                    "value": "log_joint_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.log_prob(sample)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "constant_239": {
                "variable": {
                    "value": "rho",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "mixing_probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.zeros(self.B)",
                            "Call"
                        ],
                        [
                            "mixing_probs / np.sum(mixing_probs)",
                            "BinOp"
                        ]
                    ]
                },
                "dtype": {
                    "value": "self.base.mixing_probs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "sigmoid_283": {
                "variable": {
                    "value": "rho_C",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "self._rho_C_unconstrained",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_285": {
                "variable": {
                    "value": "rho",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "rho",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.constant(mixing_probs, dtype=self.base.mixing_probs.dtype)",
                            "Call"
                        ],
                        [
                            "[(1.0 - rho_C) * r for r in prev_rho] + [rho_C] + [ZERO_WEIGHT] * (self.B - self._C - 1)",
                            "BinOp"
                        ],
                        [
                            "tf.stack(rho)",
                            "Call"
                        ],
                        [
                            "self.get_weights()",
                            "Call"
                        ]
                    ]
                }
            },
            "reduce_mean_315": {
                "variable": {
                    "value": "log_joint_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.log_prob(sample)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "RMSprop_98": {
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "reduce_mean_306": {
                "variable": {
                    "value": "log_joint_prob",
                    "type": "variable",
                    "possible_values": []
                },
                "input_tensor": {
                    "value": "self.log_prob(sample)",
                    "type": "Call",
                    "possible_values": []
                }
            },
            "Variable_342": {
                "variable": {
                    "value": "self._rho_C_unconstrained",
                    "type": "Attribute",
                    "possible_values": []
                },
                "initial_value": {
                    "value": "np.random.random() if C != 0 else 100.0",
                    "type": "IfExp",
                    "possible_values": []
                },
                "name": {
                    "value": "'rho_C%i_unconstrained' % C",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "RMSprop_383": {
                "lr": {
                    "value": "0.01",
                    "type": "float",
                    "possible_values": []
                }
            },
            "GradientTape_180": {
                "params": {
                    "value": "default",
                    "type": null,
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/one_hot.py": {
        "tensorflow": {
            "one_hot_31": {
                "variable": {
                    "value": "hard",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "tf.argmax(inputs, axis=axis)",
                    "type": "Call",
                    "possible_values": []
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "MethodArgument"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "softmax_35": {
                "variable": {
                    "value": "soft",
                    "type": "variable",
                    "possible_values": []
                },
                "logits": {
                    "value": "inputs / temperature",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "convert_to_tensor_42": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_43": {
                "variable": {
                    "value": "shift",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "shift",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(shift, inputs.dtype)",
                            "Call"
                        ],
                        [
                            "tf.concat([shift[..., :1], inv_shift], -1)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_48": {
                "variable": {
                    "value": "shift_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.roll(shift, i, axis=-1) for i in range(vocab_size)]",
                    "type": "ListComp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_50": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "...v,...uv->...u",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "shift_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.stack([tf.roll(shift, i, axis=-1) for i in range(vocab_size)], axis=-2)",
                            "Call"
                        ]
                    ]
                }
            },
            "reverse_56": {
                "variable": {
                    "value": "inv_shift",
                    "type": "variable",
                    "possible_values": []
                },
                "tensor": {
                    "value": "shift[..., 1:]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "axis": {
                    "value": "[-1]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "concat_57": {
                "variable": {
                    "value": "shift",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[shift[..., :1], inv_shift]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "convert_to_tensor_75": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_76": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(scale, inputs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floormod_83": {
                "variable": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "one_hot_86": {
                "variable": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floormod(tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis], vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(permutation_matrix, depth=vocab_size, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_88": {
                "variable": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "...v,avu->...au",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floormod(tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis], vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(permutation_matrix, depth=vocab_size, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_89": {
                "variable": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(batch_shape + [1, vocab_size]), scaled_inputs[..., 1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_93": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "...v,...vu->...u",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(scale, inputs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('...v,avu->...au', inputs, permutation_matrix)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.zeros(batch_shape + [1, vocab_size]), scaled_inputs[..., 1:, :]], axis=-2)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_137": {
                "variable": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.nditer(batched_a)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(a)",
                            "Call"
                        ]
                    ]
                }
            },
            "convert_to_tensor_138": {
                "variable": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "n",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(n)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_143": {
                "variable": {
                    "value": "sparse_a",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "a",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.nditer(batched_a)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(a)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "py_func_145": {
                "variable": {
                    "value": "sparse_outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "func": {
                    "value": "py_multiplicative_inverse",
                    "type": "variable",
                    "possible_values": []
                },
                "inp": {
                    "value": "[sparse_a, n]",
                    "type": "List",
                    "possible_values": []
                },
                "Tout": {
                    "value": "tf.int32",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "one_hot_148": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "sparse_outputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf1.py_func(py_multiplicative_inverse, [sparse_a, n], tf.int32)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                },
                "dtype": {
                    "value": "a_dtype",
                    "type": "variable",
                    "possible_values": [
                        [
                            "a.dtype",
                            "Attribute"
                        ]
                    ]
                }
            },
            "convert_to_tensor_166": {
                "variable": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "value": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                }
            },
            "cast_167": {
                "variable": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(scale, inputs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "dtype": {
                    "value": "inputs.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "floormod_174": {
                "variable": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "x": {
                    "value": "tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis]",
                    "type": "BinOp",
                    "possible_values": []
                },
                "y": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                }
            },
            "one_hot_177": {
                "variable": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floormod(tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis], vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(permutation_matrix, depth=vocab_size, axis=-1)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "vocab_size",
                    "type": "variable",
                    "possible_values": [
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "inputs.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ],
                        [
                            "a.shape[-1]",
                            "Subscript"
                        ],
                        [
                            "vocab_size.value",
                            "Attribute"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_179": {
                "variable": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "...v,avu->...au",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "permutation_matrix",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.math.floormod(tf.tile(tf.range(vocab_size)[:, tf.newaxis], [1, vocab_size]) * tf.range(vocab_size)[tf.newaxis], vocab_size)",
                            "Call"
                        ],
                        [
                            "tf.one_hot(permutation_matrix, depth=vocab_size, axis=-1)",
                            "Call"
                        ]
                    ]
                }
            },
            "concat_180": {
                "variable": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": []
                },
                "values": {
                    "value": "[tf.zeros(batch_shape + [1, vocab_size]), scaled_inputs[..., 1:, :]]",
                    "type": "List",
                    "possible_values": []
                },
                "axis": {
                    "value": "-2",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "einsum_184": {
                "variable": {
                    "value": "outputs",
                    "type": "variable",
                    "possible_values": []
                },
                "equation": {
                    "value": "...v,...vu->...u",
                    "type": "str",
                    "possible_values": []
                },
                "*inputs": {
                    "value": "scale",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(scale, inputs.dtype)",
                            "Call"
                        ]
                    ]
                },
                "**kwargs": {
                    "value": "scaled_inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.einsum('...v,avu->...au', inputs, permutation_matrix)",
                            "Call"
                        ],
                        [
                            "tf.concat([tf.zeros(batch_shape + [1, vocab_size]), scaled_inputs[..., 1:, :]], axis=-2)",
                            "Call"
                        ]
                    ]
                }
            },
            "argmax_31": {
                "input": {
                    "value": "inputs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ],
                        [
                            "tf.convert_to_tensor(inputs)",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "axis",
                    "type": "variable",
                    "possible_values": [
                        [
                            "-1",
                            "MethodArgument"
                        ]
                    ]
                }
            },
            "stop_gradient_36": {
                "input": {
                    "value": "hard - soft",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "roll_48": {
                "input": {
                    "value": "shift",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.cast(shift, inputs.dtype)",
                            "Call"
                        ],
                        [
                            "tf.concat([shift[..., :1], inv_shift], -1)",
                            "Call"
                        ]
                    ]
                },
                "shift": {
                    "value": "i",
                    "type": "variable",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "tile_84": {
                "input": {
                    "value": "tf.range(vocab_size)[:, tf.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_89": {
                "shape": {
                    "value": "batch_shape + [1, vocab_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            },
            "tile_175": {
                "input": {
                    "value": "tf.range(vocab_size)[:, tf.newaxis]",
                    "type": "Subscript",
                    "possible_values": []
                },
                "multiples": {
                    "value": "[1, vocab_size]",
                    "type": "List",
                    "possible_values": []
                }
            },
            "zeros_180": {
                "shape": {
                    "value": "batch_shape + [1, vocab_size]",
                    "type": "BinOp",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/one_hot_test.py": {
        "tensorflow": {
            "set_seed_24": {
                "seed": {
                    "value": "13",
                    "type": "int",
                    "possible_values": []
                }
            },
            "reduce_all_27": {
                "input_tensor": {
                    "value": "a == b",
                    "type": "Compare",
                    "possible_values": []
                }
            },
            "one_hot_34": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_37": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_38": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_39": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_48": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_51": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_52": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_53": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_62": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_65": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_66": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_67": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_78": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_81": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_82": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_83": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_93": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_96": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_97": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_98": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_108": {
                "indices": {
                    "value": "shifts",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.array([7.0, 3.0, 1.0])",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(K), N)",
                            "Call"
                        ],
                        [
                            "np.random.choice(range(1, K), N)",
                            "Call"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": [
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ],
                        [
                            "8",
                            "Constant"
                        ]
                    ]
                }
            },
            "reduce_sum_111": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_max_112": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_min_113": {
                "input_tensor": {
                    "value": "sums",
                    "type": "variable",
                    "possible_values": [
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_add(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_minus(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ],
                        [
                            "one_hot.one_hot_multiply(tf.one_hot(vals, K), tf.one_hot(shifts, K))",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    },
    "mdnf/prob_recovery.py": {
        "tensorflow": {
            "argmax_21": {
                "variable": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": []
                },
                "input": {
                    "value": "samples",
                    "type": "variable",
                    "possible_values": [
                        [
                            "tf.argmax(samples, -1).numpy()",
                            "Call"
                        ]
                    ]
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "one_hot_39": {
                "variable": {
                    "value": "sample",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "combinations",
                    "type": "variable",
                    "possible_values": [
                        [
                            "generate_combinations(K, N)",
                            "Call"
                        ],
                        [
                            "generate_combinations(K, N)",
                            "Call"
                        ],
                        [
                            "[[]]",
                            "MethodArgument"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                }
            },
            "one_hot_78": {
                "variable": {
                    "value": "mask",
                    "type": "variable",
                    "possible_values": []
                },
                "indices": {
                    "value": "v",
                    "type": "variable",
                    "possible_values": [
                        [
                            "np.array(probs[2])",
                            "Call"
                        ],
                        [
                            "combinations",
                            "Name"
                        ]
                    ]
                },
                "depth": {
                    "value": "K",
                    "type": "variable",
                    "possible_values": []
                },
                "dtype": {
                    "value": "samples.dtype",
                    "type": "Attribute",
                    "possible_values": []
                }
            },
            "stack_81": {
                "values": {
                    "value": "probs",
                    "type": "variable",
                    "possible_values": [
                        [
                            "base.prob_ext(run(sample))",
                            "Call"
                        ],
                        [
                            "[]",
                            "List"
                        ]
                    ]
                }
            },
            "reduce_sum_79": {
                "input_tensor": {
                    "value": "samples * mask",
                    "type": "BinOp",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            },
            "reduce_prod_79": {
                "input_tensor": {
                    "value": "tf.reduce_sum(samples * mask, -1)",
                    "type": "Call",
                    "possible_values": []
                },
                "axis": {
                    "value": "-1",
                    "type": "UnaryOp",
                    "possible_values": []
                }
            }
        }
    }
}